{"version":3,"file":"fdp.js","sources":["../src/ml.js","../src/bounty.js","../src/ml2dsl.js","../src/cutter.js","../src/deduper.js","../src/dsl2ml.js","../src/minimizer.js","../src/problem.js","../src/fdp.js"],"sourcesContent":["import {\n  ASSERT,\n  TRACE,\n  TRACE_SILENT,\n  domain__debug,\n  getTerm,\n  THROW,\n} from 'fdlib';\n\nlet ml_opcodeCounter = 0;\n\n// Note: all ops accept vars and literals\n// - a var is signified by a V\n// - an 8bit literal signified by 8\n// - a 16bit literal signified by F\n\nconst ML_START = ml_opcodeCounter++;\n\nconst ML_ALL = ml_opcodeCounter++; // &     all()\nconst ML_DIFF = ml_opcodeCounter++; // !=    diff()\nconst ML_IMP = ml_opcodeCounter++; // ->                (logical implication)\nconst ML_LT = ml_opcodeCounter++; // <\nconst ML_LTE = ml_opcodeCounter++; // <=\nconst ML_NALL = ml_opcodeCounter++; // !&    nall()\nconst ML_NIMP = ml_opcodeCounter++; // !(->)\nconst ML_NONE = ml_opcodeCounter++; // ==0   none()\nconst ML_SAME = ml_opcodeCounter++; // ==    same()\nconst ML_SOME = ml_opcodeCounter++; // |     some()\nconst ML_XNOR = ml_opcodeCounter++; // !^    xnor()\nconst ML_XOR = ml_opcodeCounter++; // ^     xor()\n\nconst ML_ISALL = ml_opcodeCounter++;\nconst ML_ISDIFF = ml_opcodeCounter++;\nconst ML_ISLT = ml_opcodeCounter++;\nconst ML_ISLTE = ml_opcodeCounter++;\nconst ML_ISNALL = ml_opcodeCounter++;\nconst ML_ISNONE = ml_opcodeCounter++;\nconst ML_ISSAME = ml_opcodeCounter++;\nconst ML_ISSOME = ml_opcodeCounter++;\n\nconst ML_SUM = ml_opcodeCounter++;\nconst ML_PRODUCT = ml_opcodeCounter++;\nconst ML_MINUS = ml_opcodeCounter++;\nconst ML_DIV = ml_opcodeCounter++;\n\nconst ML_NOLEAF = ml_opcodeCounter++;\nconst ML_NOBOOL = ml_opcodeCounter++;\nconst ML_JMP = ml_opcodeCounter++;\nconst ML_JMP32 = ml_opcodeCounter++;\nconst ML_NOOP = ml_opcodeCounter++;\nconst ML_NOOP2 = ml_opcodeCounter++;\nconst ML_NOOP3 = ml_opcodeCounter++;\nconst ML_NOOP4 = ml_opcodeCounter++;\nconst ML_STOP = 0xff;\n\nASSERT(ml_opcodeCounter < 0xff, 'All opcodes are 8bit');\nASSERT(ML_START === 0);\nASSERT(ML_STOP === 0xff);\n\nconst SIZEOF_V = 1 + 2; // 16bit\nconst SIZEOF_W = 1 + 4; // 32bit\nconst SIZEOF_VV = 1 + 2 + 2;\nconst SIZEOF_VVV = 1 + 2 + 2 + 2;\nconst SIZEOF_C = 1 + 2; // + 2*count\nconst SIZEOF_C_2 = SIZEOF_C + 2 * 2; // Fixed 2 var without result\nconst SIZEOF_CR_2 = SIZEOF_C + 2 * 2 + 2; // Fixed 2 var with result\n\nconst OFFSET_C_A = SIZEOF_C;\nconst OFFSET_C_B = SIZEOF_C + 2;\nconst OFFSET_C_C = SIZEOF_C + 4;\nconst OFFSET_C_R = OFFSET_C_C;\n\nlet ml_typeCounter = 0;\nconst ML_NO_ARGS = ++ml_typeCounter;\nconst ML_V = ++ml_typeCounter;\nconst ML_W = ++ml_typeCounter;\nconst ML_VV = ++ml_typeCounter;\nconst ML_VVV = ++ml_typeCounter;\nconst ML_C = ++ml_typeCounter;\nconst ML_C_2 = ++ml_typeCounter;\nconst ML_CR = ++ml_typeCounter;\nconst ML_C8R = ++ml_typeCounter;\n\nfunction ml_sizeof(ml, offset, op) {\n  switch (op) {\n    case ML_IMP:\n    case ML_LT:\n    case ML_LTE:\n    case ML_NIMP:\n    case ML_XOR:\n      ASSERT(ml_dec16(ml, offset + 1) === 2);\n      return SIZEOF_C_2; // Always\n\n    case ML_START:\n      return 1;\n\n    case ML_ISLT:\n    case ML_ISLTE:\n    case ML_MINUS:\n    case ML_DIV:\n      return SIZEOF_VVV;\n\n    case ML_ALL:\n    case ML_DIFF:\n    case ML_NALL:\n    case ML_NONE:\n    case ML_SAME:\n    case ML_SOME:\n    case ML_XNOR:\n      if (ml && offset >= 0) return SIZEOF_C + _dec16(ml, offset + 1) * 2;\n      return -1;\n\n    case ML_ISALL:\n    case ML_ISDIFF:\n    case ML_ISNALL:\n    case ML_ISNONE:\n    case ML_ISSAME:\n    case ML_ISSOME:\n      if (ml && offset >= 0) return SIZEOF_C + _dec16(ml, offset + 1) * 2 + 2;\n      ASSERT(false, 'dont allow this');\n      return -1;\n\n    case ML_SUM:\n    case ML_PRODUCT:\n      if (ml && offset >= 0) return SIZEOF_C + _dec16(ml, offset + 1) * 2 + 2;\n      ASSERT(false, 'dont allow this');\n      return -1;\n\n    case ML_NOBOOL:\n    case ML_NOLEAF:\n      return SIZEOF_V;\n    case ML_JMP:\n      return SIZEOF_V + _dec16(ml, offset + 1);\n    case ML_JMP32:\n      return SIZEOF_W + _dec32(ml, offset + 1);\n    case ML_NOOP:\n      return 1;\n    case ML_NOOP2:\n      return 2;\n    case ML_NOOP3:\n      return 3;\n    case ML_NOOP4:\n      return 4;\n    case ML_STOP:\n      return 1;\n    default:\n      getTerm().log('(ml) unknown op', op, ' at', offset);\n      TRACE('(ml_sizeof) unknown op: ' + ml[offset], ' at', offset);\n      THROW('(ml_sizeof) unknown op: ' + ml[offset], ' at', offset);\n  }\n}\n\nfunction _dec8(ml, pc) {\n  return ml[pc];\n}\n\nfunction ml_dec8(ml, pc) {\n  ASSERT(ml instanceof Uint8Array, 'ml should be Uint8Array');\n  ASSERT(\n    typeof pc === 'number' && pc >= 0 && pc < ml.length,\n    'Invalid or OOB',\n    pc,\n    '>=',\n    ml.length\n  );\n  const num = _dec8(ml, pc);\n  TRACE_SILENT(' . dec8pc decoding', num, 'from', pc);\n\n  return num;\n}\n\nfunction _dec16(ml, pc) {\n  return (ml[pc++] << 8) | ml[pc];\n}\n\nfunction ml_dec16(ml, pc) {\n  ASSERT(ml instanceof Uint8Array, 'ml should be Uint8Array');\n  ASSERT(\n    typeof pc === 'number' && pc >= 0 && pc < ml.length,\n    'Invalid or OOB',\n    pc,\n    '>=',\n    ml.length\n  );\n\n  const n = _dec16(ml, pc);\n\n  TRACE_SILENT(\n    ' . dec16pc decoding',\n    ml[pc] << 8,\n    'from',\n    pc,\n    'and',\n    ml[pc + 1],\n    'from',\n    pc + 1,\n    '-->',\n    n\n  );\n  return n;\n}\n\nfunction _dec32(ml, pc) {\n  return (ml[pc++] << 24) | (ml[pc++] << 16) | (ml[pc++] << 8) | ml[pc];\n}\n\nfunction ml_dec32(ml, pc) {\n  ASSERT(ml instanceof Uint8Array, 'ml should be Uint8Array');\n  ASSERT(\n    typeof pc === 'number' && pc >= 0 && pc < ml.length,\n    'Invalid or OOB',\n    pc,\n    '>=',\n    ml.length\n  );\n\n  const n = _dec32(ml, pc);\n\n  TRACE_SILENT(\n    ' . dec32pc decoding',\n    ml[pc],\n    ml[pc + 1],\n    ml[pc + 2],\n    ml[pc + 3],\n    '( x' +\n      ml[pc].toString(16) +\n      ml[pc + 1].toString(16) +\n      ml[pc + 2].toString(16) +\n      ml[pc + 3].toString(16),\n    ') from',\n    pc,\n    '-->',\n    n\n  );\n  return n;\n}\n\nfunction ml_enc8(ml, pc, num) {\n  TRACE_SILENT(\n    ' . enc8(' + pc + ', ' + num + '/x' + (num && num.toString(16)) + ') at',\n    pc,\n    ' '\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml should be Uint8Array');\n  ASSERT(\n    typeof pc === 'number' && pc >= 0 && pc < ml.length,\n    'Invalid or OOB',\n    pc,\n    '>=',\n    ml.length\n  );\n  ASSERT(typeof num === 'number', 'Encoding numbers', num);\n  ASSERT(\n    num >= 0 && num <= 0xff,\n    'Only encode 8bit values',\n    num,\n    '0x' + num.toString(16)\n  );\n  ASSERT(num >= 0, 'only expecting non-negative nums', num);\n\n  ml[pc] = num;\n}\n\nfunction ml_enc16(ml, pc, num) {\n  TRACE_SILENT(\n    ' - enc16(' + pc + ', ' + num + '/x' + num.toString(16) + ')',\n    (num >> 8) & 0xff,\n    'at',\n    pc,\n    'and',\n    num & 0xff,\n    'at',\n    pc + 1\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml should be Uint8Array');\n  ASSERT(\n    typeof pc === 'number' && pc >= 0 && pc < ml.length,\n    'Invalid or OOB',\n    pc,\n    '>=',\n    ml.length\n  );\n  ASSERT(typeof num === 'number', 'Encoding numbers');\n  ASSERT(num <= 0xffff, 'implement 32bit index support if this breaks', num);\n  ASSERT(num >= 0, 'only expecting non-negative nums', num);\n\n  ml[pc++] = (num >> 8) & 0xff;\n  ml[pc] = num & 0xff;\n}\n\nfunction ml_enc32(ml, pc, num) {\n  TRACE_SILENT(\n    ' - enc32(' + pc + ', ' + num + '/x' + num.toString(16) + ')',\n    ml[pc],\n    ml[pc + 1],\n    ml[pc + 2],\n    ml[pc + 3],\n    '( x' +\n      ml[pc].toString(16) +\n      ml[pc + 1].toString(16) +\n      ml[pc + 2].toString(16) +\n      ml[pc + 3].toString(16),\n    ') at',\n    pc + 1\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml should be Uint8Array');\n  ASSERT(\n    typeof pc === 'number' && pc >= 0 && pc < ml.length,\n    'Invalid or OOB',\n    pc,\n    '>=',\n    ml.length\n  );\n  ASSERT(typeof num === 'number', 'Encoding numbers');\n  ASSERT(\n    num <= 0xffffffff,\n    'implement 64bit index support if this breaks',\n    num\n  );\n  ASSERT(num >= 0, 'only expecting non-negative nums', num);\n\n  ml[pc++] = (num >> 24) & 0xff;\n  ml[pc++] = (num >> 16) & 0xff;\n  ml[pc++] = (num >> 8) & 0xff;\n  ml[pc] = num & 0xff;\n}\n\nfunction ml_eliminate(ml, offset, sizeof) {\n  ASSERT(ml instanceof Uint8Array, 'ml should be Uint8Array', ml);\n  // ASSERT(ml_validateSkeleton(ml, 'ml_eliminate; before'));\n  TRACE(\n    ' - ml_eliminate: eliminating constraint at',\n    offset,\n    'with size =',\n    sizeof,\n    ', ml=',\n    ml.length < 50 ? ml.join(' ') : '<BIG>'\n  );\n  ASSERT(\n    typeof offset === 'number' && offset >= 0 && offset < ml.length,\n    'valid offset required'\n  );\n  ASSERT(typeof sizeof === 'number' && sizeof >= 0, 'valid sizeof required');\n  ASSERT(\n    sizeof === ml_getOpSizeSlow(ml, offset),\n    'sizeof should match size of op at offset',\n    sizeof,\n    ml_getOpSizeSlow(ml, offset),\n    ml__debug(ml, offset, 1, undefined, true, true)\n  ); // Maybe we should move to do this permanently \"slow\"\n  ml_compileJumpSafe(ml, offset, sizeof);\n  TRACE(\n    '    - after ml_eliminate:',\n    ml.length < 50 ? ml.join(' ') : '<trunced>'\n  );\n  ASSERT(ml_validateSkeleton(ml, 'ml_eliminate; after'));\n}\n\nfunction ml_compileJumpAndConsolidate(ml, offset, len) {\n  TRACE('  - ml_jump: offset = ', offset, 'len = ', len);\n\n  switch (ml[offset + len]) {\n    case ML_NOOP:\n      TRACE('  - jmp target is another jmp (noop), merging them');\n      return ml_compileJumpAndConsolidate(ml, offset, len + 1);\n    case ML_NOOP2:\n      TRACE('  - jmp target is another jmp (noop2), merging them');\n      return ml_compileJumpAndConsolidate(ml, offset, len + 2);\n    case ML_NOOP3:\n      TRACE('  - jmp target is another jmp (noop3), merging them');\n      return ml_compileJumpAndConsolidate(ml, offset, len + 3);\n    case ML_NOOP4:\n      TRACE('  - jmp target is another jmp (noop4), merging them');\n      return ml_compileJumpAndConsolidate(ml, offset, len + 4);\n    case ML_JMP:\n      const jmplen = ml_dec16(ml, offset + len + 1);\n      ASSERT(jmplen > 0, 'dont think zero is a valid jmp len');\n      ASSERT(jmplen <= 0xffff, 'oob');\n      TRACE(\n        '  - jmp target is another jmp (len =',\n        SIZEOF_V + jmplen,\n        '), merging them'\n      );\n      return ml_compileJumpAndConsolidate(ml, offset, len + SIZEOF_V + jmplen);\n    case ML_JMP32:\n      const jmplen32 = ml_dec32(ml, offset + len + 1);\n      ASSERT(jmplen32 > 0, 'dont think zero is a valid jmp len');\n      ASSERT(jmplen32 <= 0xffffffff, 'oob');\n      TRACE(\n        '  - jmp target is a jmp32 (len =',\n        SIZEOF_W + jmplen32,\n        '), merging them'\n      );\n      return ml_compileJumpAndConsolidate(\n        ml,\n        offset,\n        len + SIZEOF_W + jmplen32\n      );\n  }\n\n  ml_compileJumpSafe(ml, offset, len);\n}\n\nfunction ml_compileJumpSafe(ml, offset, len) {\n  switch (len) {\n    case 0:\n      return THROW('this is a bug');\n    case 1:\n      TRACE('  - compiling a NOOP');\n      return ml_enc8(ml, offset, ML_NOOP);\n    case 2:\n      TRACE('  - compiling a NOOP2');\n      return ml_enc8(ml, offset, ML_NOOP2);\n    case 3:\n      TRACE('  - compiling a NOOP3');\n      return ml_enc8(ml, offset, ML_NOOP3);\n    case 4:\n      TRACE('  - compiling a NOOP4');\n      return ml_enc8(ml, offset, ML_NOOP4);\n    default:\n      if (len < 0xffff) {\n        TRACE(\n          '  - compiling a ML_JMP of',\n          len,\n          '(compiles',\n          len - SIZEOF_V,\n          'because SIZEOF_V=',\n          SIZEOF_V,\n          ')'\n        );\n        ml_enc8(ml, offset, ML_JMP);\n        ml_enc16(ml, offset + 1, len - SIZEOF_V);\n      } else {\n        TRACE(\n          '  - compiling a ML_JMP32 of',\n          len,\n          '(compiles',\n          len - SIZEOF_W,\n          'because SIZEOF_W=',\n          SIZEOF_W,\n          ')'\n        );\n        ml_enc8(ml, offset, ML_JMP32);\n        ml_enc32(ml, offset + 1, len - SIZEOF_W);\n      }\n  }\n  // ASSERT(ml_validateSkeleton(ml, 'ml_jump; after'));\n}\n\nfunction ml_pump(ml, offset, from, to, len) {\n  TRACE(' - pumping from', offset + from, 'to', offset + to, '(len=', len, ')');\n  let fromOffset = offset + from;\n  let toOffset = offset + to;\n  for (let i = 0; i < len; ++i) {\n    TRACE(' - pump', fromOffset, toOffset, '(1)');\n    ml[fromOffset++] = ml[toOffset++];\n  }\n}\n\nfunction ml_countConstraints(ml) {\n  let pc = 0;\n  let constraints = 0;\n\n  while (pc < ml.length) {\n    const pcStart = pc;\n    const op = ml[pc];\n    switch (op) {\n      case ML_START:\n        if (pc !== 0)\n          return THROW(\n            'mlConstraints: zero op @',\n            pcStart,\n            'Uint8Array(' + ml.toString('hex').replace(/(..)/g, '$1 ') + ')'\n          );\n        ++pc;\n        break;\n\n      case ML_STOP:\n        return constraints;\n\n      case ML_NOOP:\n        ++pc;\n        break;\n      case ML_NOOP2:\n        pc += 2;\n        break;\n      case ML_NOOP3:\n        pc += 3;\n        break;\n      case ML_NOOP4:\n        pc += 4;\n        break;\n      case ML_JMP:\n        pc += SIZEOF_V + _dec16(ml, pc + 1);\n        break;\n      case ML_JMP32:\n        pc += SIZEOF_W + _dec32(ml, pc + 1);\n        break;\n\n      default:\n        const size = ml_sizeof(ml, pc, op); // Throws if op is unknown\n        ++constraints;\n        pc += size;\n    }\n  }\n\n  THROW('ML OOB');\n}\n\nfunction ml_hasConstraint(ml) {\n  // Technically this should be cheap; either the first\n  // op is a constraint or it's a jump directly to stop.\n  // (all jumps should be consolidated)\n  let pc = 0;\n\n  while (pc < ml.length) {\n    switch (ml[pc]) {\n      case ML_START:\n        if (pc !== 0) return ml_throw('oops');\n        ++pc;\n        break;\n\n      case ML_STOP:\n        return false;\n\n      case ML_NOOP:\n        ++pc;\n        break;\n      case ML_NOOP2:\n        pc += 2;\n        break;\n      case ML_NOOP3:\n        pc += 3;\n        break;\n      case ML_NOOP4:\n        pc += 4;\n        break;\n      case ML_JMP:\n        pc += SIZEOF_V + _dec16(ml, pc + 1);\n        break;\n      case ML_JMP32:\n        pc += SIZEOF_W + _dec32(ml, pc + 1);\n        break;\n\n      default:\n        return true;\n    }\n  }\n\n  THROW('ML OOB');\n}\n\nfunction ml_c2vv(ml, offset, argCount, opCode, indexA, indexB) {\n  // \"count without result\" (diff, some, nall, etc)\n  TRACE(\n    ' -| ml_c2vv | from',\n    offset,\n    ', argCount=',\n    argCount,\n    'to op',\n    ml__opName(opCode),\n    ', args:',\n    indexA,\n    indexB\n  );\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) >= SIZEOF_VV,\n    'the c2 should fit the existing space entirely'\n  );\n  ASSERT(ml_dec16(ml, offset + 1) === argCount, 'argcount should match');\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, indexA);\n  ml_enc16(ml, offset + 3, indexB);\n\n  const oldLen = SIZEOF_C + argCount * 2;\n  if (SIZEOF_VV < oldLen)\n    ml_compileJumpSafe(ml, offset + SIZEOF_VV, oldLen - SIZEOF_VV);\n  ASSERT(ml_validateSkeleton(ml, 'ml_c2vv'));\n}\n\nfunction ml_c2c2(ml, offset, argCount, opCode, indexA, indexB) {\n  // \"count without result\" (diff, some, nall, etc) to same count type with 2 args without result\n  TRACE(\n    ' -| ml_c2c2 | from',\n    offset,\n    ', argCount=',\n    argCount,\n    'to op',\n    ml__opName(opCode),\n    ', args:',\n    indexA,\n    indexB\n  );\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) >= SIZEOF_C_2,\n    'the c2 should fit the existing space entirely'\n  );\n  ASSERT(ml_dec16(ml, offset + 1) === argCount, 'argcount should match');\n  ASSERT(\n    argCount > 1,\n    'this fails with count<2 because theres not enough space'\n  );\n\n  // ASSERT(ml_validateSkeleton(ml, 'ml_c2c2-before'));\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, 2);\n  ml_enc16(ml, offset + OFFSET_C_A, indexA);\n  ml_enc16(ml, offset + OFFSET_C_B, indexB);\n\n  const oldLen = SIZEOF_C + argCount * 2;\n  if (SIZEOF_C_2 < oldLen)\n    ml_compileJumpSafe(ml, offset + SIZEOF_C_2, oldLen - SIZEOF_C_2);\n  ASSERT(ml_validateSkeleton(ml, 'ml_c2c2'));\n}\n\nfunction ml_cx2cx(ml, offset, argCount, opCode, args) {\n  TRACE(\n    ' -| ml_cx2cx | from',\n    offset,\n    'was argCount=',\n    argCount,\n    'to op',\n    ml__opName(opCode),\n    'with args',\n    args,\n    ', new size should be',\n    SIZEOF_C + args.length * 2\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(\n    typeof argCount === 'number' && argCount > 0 && argCount < ml.length,\n    'valid argCount',\n    argCount\n  );\n  ASSERT(Array.isArray(args), 'args is list of indexes', args);\n  ASSERT(\n    argCount === args.length,\n    'this function excepts to morph one count op into another count op of the same size',\n    argCount,\n    args.length,\n    args\n  );\n\n  args.sort((a, b) => a - b); // Compile args sorted\n  const opSize = SIZEOF_C + argCount * 2;\n  ASSERT(\n    (argCount === args.length) === (ml_getOpSizeSlow(ml, offset) === opSize),\n    'if same argcount then same size'\n  );\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) === opSize,\n    'the should fit the existing space entirely'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, argCount);\n  for (let i = 0; i < argCount; ++i) {\n    ml_enc16(ml, offset + SIZEOF_C + i * 2, args[i]);\n  }\n\n  ASSERT(ml_validateSkeleton(ml, 'ml_cx2cx'));\n}\n\nfunction ml_any2c(ml, offset, oldSizeof, opCode, args) {\n  TRACE(\n    ' -| ml_any2c | from',\n    offset,\n    'was len=',\n    oldSizeof,\n    'to op',\n    ml__opName(opCode),\n    'with args',\n    args,\n    ', new size should be',\n    SIZEOF_C + args.length * 2\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(\n    typeof oldSizeof === 'number' && offset > 0 && offset < ml.length,\n    'valid oldSizeof',\n    oldSizeof\n  );\n  ASSERT(Array.isArray(args), 'args is list of indexes', args);\n  const count = args.length;\n  const opSize = SIZEOF_C + count * 2;\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) >= opSize,\n    'the c2 should fit the existing space entirely'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, count);\n  for (let i = 0; i < count; ++i) {\n    ml_enc16(ml, offset + SIZEOF_C + i * 2, args[i]);\n  }\n\n  if (opSize < oldSizeof)\n    ml_compileJumpSafe(ml, offset + opSize, oldSizeof - opSize);\n  ASSERT(ml_validateSkeleton(ml, 'ml_any2c'));\n}\n\nfunction ml_any2cr(ml, offset, oldSizeof, opCode, args, indexR) {\n  TRACE(\n    ' -| ml_any2cr | from',\n    offset,\n    'was len=',\n    oldSizeof,\n    'to op',\n    ml__opName(opCode),\n    'with args',\n    args,\n    ', indexR=',\n    indexR,\n    ', new size should be',\n    SIZEOF_C + args.length * 2 + 2\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(\n    typeof oldSizeof === 'number' && offset > 0 && offset < ml.length,\n    'valid oldSizeof',\n    oldSizeof\n  );\n  ASSERT(Array.isArray(args), 'args is list of indexes', args);\n  ASSERT(typeof indexR === 'number', 'valid indexR', indexR);\n  const count = args.length;\n  const opSize = SIZEOF_C + count * 2 + 2;\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) >= opSize,\n    'the cr should fit the existing space entirely'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, count);\n  for (let i = 0; i < count; ++i) {\n    ml_enc16(ml, offset + SIZEOF_C + i * 2, args[i]);\n  }\n\n  ml_enc16(ml, offset + SIZEOF_C + count * 2, indexR);\n\n  ASSERT(opSize <= oldSizeof, 'should fit!');\n  if (opSize < oldSizeof)\n    ml_compileJumpSafe(ml, offset + opSize, oldSizeof - opSize);\n  ASSERT(ml_validateSkeleton(ml, 'ml_any2cr'));\n}\n\nfunction ml_cr2vv(ml, offset, argCount, opCode, indexA, indexB) {\n  TRACE(\n    ' -| ml_cr2vv | from',\n    offset,\n    ', argCount=',\n    argCount,\n    'to op',\n    ml__opName(opCode),\n    'with args:',\n    indexA,\n    indexB\n  );\n  ASSERT(\n    argCount >= 1,\n    'if this is called for count ops with 0 args then we have a problem... a vv wont fit that'\n  );\n  // \"count with result\"\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(typeof indexA === 'number' && indexA >= 0, 'valid indexA', indexA);\n  ASSERT(typeof indexB === 'number' && indexB >= 0, 'valid indexB', indexB);\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) >= SIZEOF_VV,\n    'the vv should fit the existing space entirely'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, indexA);\n  ml_enc16(ml, offset + 3, indexB);\n\n  const oldLen = SIZEOF_C + argCount * 2 + 2;\n  if (SIZEOF_VV < oldLen)\n    ml_compileJumpSafe(ml, offset + SIZEOF_VV, oldLen - SIZEOF_VV);\n  ASSERT(ml_validateSkeleton(ml, 'ml_cr2vv'));\n}\n\nfunction ml_cr2vvv(ml, offset, argCount, opCode, indexA, indexB, indexC) {\n  TRACE(\n    ' -| ml_cr2vvv | from',\n    offset,\n    ', argCount=',\n    argCount,\n    'to op',\n    ml__opName(opCode),\n    'with args:',\n    indexA,\n    indexB,\n    indexC\n  );\n  ASSERT(\n    argCount >= 2,\n    'if this is called for count ops with 1 or 0 args then we have a problem... a vvv wont fit that'\n  );\n  // \"count with result\"\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(typeof indexA === 'number' && indexA >= 0, 'valid indexA', indexA);\n  ASSERT(typeof indexB === 'number' && indexB >= 0, 'valid indexB', indexB);\n  ASSERT(typeof indexC === 'number' && indexC >= 0, 'valid indexC', indexC);\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) >= SIZEOF_VVV,\n    'the vvv should fit the existing space entirely'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, indexA);\n  ml_enc16(ml, offset + 3, indexB);\n  ml_enc16(ml, offset + 5, indexC);\n\n  const oldLen = SIZEOF_C + argCount * 2 + 2;\n  if (SIZEOF_VVV < oldLen)\n    ml_compileJumpSafe(ml, offset + SIZEOF_VVV, oldLen - SIZEOF_VVV);\n  ASSERT(ml_validateSkeleton(ml, 'ml_cr2vvv'));\n}\n\nfunction ml_cr2cr2(ml, offset, argCount, opCode, indexA, indexB, indexC) {\n  // \"count with result and any args to count with result with 2 args\"\n  TRACE(\n    ' -| ml_cr2cr2 | from',\n    offset,\n    ', argCount=',\n    argCount,\n    'to op',\n    ml__opName(opCode),\n    'with args:',\n    indexA,\n    indexB,\n    indexC\n  );\n  ASSERT(\n    argCount >= 2,\n    'if this is called for count ops with 1 or 0 args then we have a problem... a cr[' +\n      argCount +\n      '] wont fit that'\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(typeof indexA === 'number' && indexA >= 0, 'valid indexA', indexA);\n  ASSERT(typeof indexB === 'number' && indexB >= 0, 'valid indexB', indexB);\n  ASSERT(typeof indexC === 'number' && indexC >= 0, 'valid indexC', indexC);\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) >= SIZEOF_CR_2,\n    'the cr2 should fit the existing space entirely'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, 2); // Arg count\n  ml_enc16(ml, offset + OFFSET_C_A, indexA);\n  ml_enc16(ml, offset + OFFSET_C_B, indexB);\n  ml_enc16(ml, offset + OFFSET_C_C, indexC);\n\n  const oldLen = SIZEOF_C + argCount * 2 + 2;\n  if (SIZEOF_CR_2 < oldLen)\n    ml_compileJumpSafe(ml, offset + SIZEOF_CR_2, oldLen - SIZEOF_CR_2);\n  ASSERT(ml_validateSkeleton(ml, 'ml_cr2cr2'));\n}\n\nfunction ml_cr2c2(ml, offset, argCount, opCode, indexA, indexB) {\n  // \"count with result\"\n  const oldArgCount = ml_dec16(ml, offset + 1);\n  TRACE(\n    ' -| ml_cr2c2 | from',\n    offset,\n    ', with argCount=',\n    oldArgCount,\n    ' and a result var, to a argCount=',\n    argCount,\n    ' without result, op',\n    ml__opName(opCode),\n    ', args:',\n    indexA,\n    indexB\n  );\n  // Count with result and any args to count with result and (exactly) 2 args\n  ASSERT(\n    argCount >= 1,\n    'if this is called for count ops with 0 args then we have a problem... a c[' +\n      argCount +\n      '] wont fit that'\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(typeof indexA === 'number' && indexA >= 0, 'valid indexA', indexA);\n  ASSERT(typeof indexB === 'number' && indexB >= 0, 'valid indexB', indexB);\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) >= SIZEOF_C_2,\n    'the c2 should fit the existing space entirely'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, 2); // Arg count\n  ml_enc16(ml, offset + OFFSET_C_A, indexA);\n  ml_enc16(ml, offset + OFFSET_C_B, indexB);\n\n  const oldLen = SIZEOF_C + oldArgCount * 2 + 2;\n  if (SIZEOF_C_2 < oldLen)\n    ml_compileJumpSafe(ml, offset + SIZEOF_C_2, oldLen - SIZEOF_C_2);\n  ASSERT(ml_validateSkeleton(ml, 'ml_cr2c2'));\n}\n\nfunction ml_cr2c(ml, offset, oldArgCount, opCode, args) {\n  // \"count with result to count\"\n  // count with result and any args to count without result and any args\n  // not \"any\" because the number of new args can at most be only be one more than the old arg count\n  TRACE(\n    ' -| ml_cr2c | from',\n    offset,\n    ', with oldArgCount=',\n    oldArgCount,\n    ' and a result var, to a oldArgCount=',\n    oldArgCount,\n    ' without result, op',\n    ml__opName(opCode),\n    ', args:',\n    args\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof oldArgCount === 'number', 'valid oldArgCount', oldArgCount);\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(\n    Array.isArray(args) && args.every(v => typeof v === 'number' && v >= 0)\n  );\n  ASSERT(\n    oldArgCount + 1 >= args.length,\n    'cr can holds one index more than c so we can compile one more arg here',\n    oldArgCount,\n    '->',\n    args.length\n  );\n\n  const newArgCount = args.length;\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, newArgCount);\n  for (let i = 0; i < newArgCount; ++i) {\n    ml_enc16(ml, offset + SIZEOF_C + i * 2, args[i]);\n  }\n\n  const oldLen = SIZEOF_C + oldArgCount * 2 + 2;\n  const newLen = SIZEOF_C + newArgCount * 2;\n  if (newLen < oldLen) ml_compileJumpSafe(ml, offset + newLen, oldLen - newLen);\n  ASSERT(ml_validateSkeleton(ml, 'ml_cr2c'));\n}\n\nfunction ml_vv2vv(ml, offset, opCode, indexA, indexB) {\n  TRACE(\n    ' -| ml_vv2vv | from',\n    offset,\n    'to op',\n    ml__opName(opCode),\n    ', index AB:',\n    indexA,\n    indexB\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(typeof indexA === 'number' && indexA >= 0, 'valid indexA', indexA);\n  ASSERT(typeof indexB === 'number' && indexB >= 0, 'valid indexB', indexB);\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) === SIZEOF_VV,\n    'the existing space should be a vv'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, indexA);\n  ml_enc16(ml, offset + 3, indexB);\n\n  ASSERT(ml_validateSkeleton(ml, 'ml_vv2vv'));\n}\n\nfunction ml_vvv2vv(ml, offset, opCode, indexA, indexB) {\n  TRACE(\n    ' -| ml_vvv2vv |',\n    'to op',\n    ml__opName(opCode),\n    ', args:',\n    indexA,\n    indexB\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(typeof indexA === 'number' && indexA >= 0, 'valid indexA', indexA);\n  ASSERT(typeof indexB === 'number' && indexB >= 0, 'valid indexB', indexB);\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) === SIZEOF_VVV,\n    'the existing space should be a vvv'\n  );\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) > SIZEOF_VVV,\n    'the existing vvv should be larger than a vv'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, indexA);\n  ml_enc16(ml, offset + 3, indexB);\n  ml_compileJumpSafe(ml, offset + SIZEOF_VV, SIZEOF_VVV - SIZEOF_VV);\n\n  ASSERT(ml_validateSkeleton(ml, 'ml_vvv2vv'));\n}\n\nfunction ml_vvv2c2(ml, offset, opCode, indexA, indexB) {\n  TRACE(\n    ' -| ml_vvv2c2 |',\n    'to op',\n    ml__opName(opCode),\n    ', args:',\n    indexA,\n    indexB\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(typeof indexA === 'number' && indexA >= 0, 'valid indexA', indexA);\n  ASSERT(typeof indexB === 'number' && indexB >= 0, 'valid indexB', indexB);\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) === SIZEOF_C_2,\n    'the existing space should be a vvv and that should be a c2'\n  );\n  ASSERT(SIZEOF_VVV === SIZEOF_C_2, 'need to check here if this changes');\n\n  // Note: size(vvv) is same as size(c2)\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, 2);\n  ml_enc16(ml, offset + OFFSET_C_A, indexA);\n  ml_enc16(ml, offset + OFFSET_C_B, indexB);\n\n  ASSERT(ml_validateSkeleton(ml, 'ml_vvv2c2'));\n}\n\nfunction ml_vvv2vvv(ml, offset, opCode, indexA, indexB, indexR) {\n  TRACE(\n    ' -| cr_vvv2vvv |',\n    'to op',\n    ml__opName(opCode),\n    ', args:',\n    indexA,\n    indexB,\n    indexR\n  );\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset > 0 && offset < ml.length,\n    'valid offset',\n    offset\n  );\n  ASSERT(typeof opCode === 'number' && offset >= 0, 'valid opCode', opCode);\n  ASSERT(typeof indexA === 'number' && indexA >= 0, 'valid indexA', indexA);\n  ASSERT(typeof indexB === 'number' && indexB >= 0, 'valid indexB', indexB);\n  ASSERT(typeof indexR === 'number' && indexR >= 0, 'valid indexR', indexR);\n  ASSERT(\n    ml_getOpSizeSlow(ml, offset) === SIZEOF_VVV,\n    'the existing space should be a vvv'\n  );\n\n  ml_enc8(ml, offset, opCode);\n  ml_enc16(ml, offset + 1, indexA);\n  ml_enc16(ml, offset + 3, indexB);\n  ml_enc16(ml, offset + 5, indexR);\n\n  ASSERT(ml_validateSkeleton(ml, 'ml_vvv2vvv'));\n}\n\nfunction ml_walk(ml, offset, callback) {\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset >= 0 && offset < ml.length,\n    'offset should be valid and not oob'\n  );\n  ASSERT(typeof callback === 'function', 'callback should be callable');\n\n  const len = ml.length;\n  let op = ml[offset];\n  while (offset < len) {\n    op = ml[offset];\n    if (process.env.NODE_ENV !== 'production') {\n      if (offset !== 0 && op === ML_START) {\n        ml_throw(ml, offset, 'should not see op=0 unless offset=0')\n      }\n    }\n    const sizeof = ml_sizeof(ml, offset, op);\n    ASSERT(sizeof > 0, 'ops should occupy space');\n    const r = callback(ml, offset, op, sizeof);\n    if (r !== undefined) return r;\n    offset += sizeof;\n  }\n}\n\n/**\n * Walk the ml with a callback for each var encountered\n *\n * @param {Uint8Array} ml\n * @param {number} offset\n * @param {Function} callback Called as opCallback(ml, opoffset, optype, opcode, ...args) the actual `args` depend on the optype\n */\nfunction ml_stream(ml, offset, callback) {\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset >= 0 && offset < ml.length,\n    'offset should be valid and not oob'\n  );\n  ASSERT(typeof callback === 'function', 'callback should be callable');\n\n  let r;\n  const len = ml.length;\n  let op = ml[offset];\n  while (offset < len) {\n    op = ml[offset];\n    ASSERT(\n      offset === 0 || op !== ML_START,\n      'should not see op=0 unless offset=0',\n      'offset=',\n      offset,\n      'ml=',\n      ml\n    );\n\n    let sizeof = 0;\n    switch (op) {\n      case ML_IMP:\n      case ML_LT:\n      case ML_LTE:\n      case ML_NIMP:\n      case ML_XOR:\n        r = callback(\n          ml,\n          offset,\n          ML_C_2,\n          op,\n          ml_dec16(ml, offset + OFFSET_C_A),\n          ml_dec16(ml, offset + OFFSET_C_B)\n        );\n        sizeof = SIZEOF_C_2;\n        break;\n\n      case ML_ISLT:\n      case ML_ISLTE:\n      case ML_MINUS:\n      case ML_DIV:\n        r = callback(\n          ml,\n          offset,\n          ML_VVV,\n          op,\n          ml_dec16(ml, offset + 1),\n          ml_dec16(ml, offset + 3),\n          ml_dec16(ml, offset + 5)\n        );\n        sizeof = SIZEOF_CR_2;\n        break;\n\n      case ML_ALL:\n      case ML_DIFF:\n      case ML_NALL:\n      case ML_NONE:\n      case ML_SAME:\n      case ML_SOME:\n      case ML_XNOR:\n        r = callback(ml, offset, ML_C, op, ml_dec16(ml, offset + 1));\n        sizeof = SIZEOF_C + ml_dec16(ml, offset + 1) * 2;\n        break;\n\n      case ML_ISALL:\n      case ML_ISDIFF:\n      case ML_ISNALL:\n      case ML_ISNONE:\n      case ML_ISSAME:\n      case ML_ISSOME:\n      case ML_PRODUCT:\n      case ML_SUM:\n        r = callback(\n          ml,\n          offset,\n          ML_CR,\n          op,\n          ml_dec16(ml, offset + 1),\n          ml_dec16(ml, offset + SIZEOF_C + ml_dec16(ml, offset + 1) * 2)\n        );\n        sizeof = SIZEOF_C + ml_dec16(ml, offset + 1) * 2 + 2;\n        break;\n\n      case ML_NOBOOL:\n      case ML_NOLEAF:\n        r = callback(ml, offset, ML_V, op, ml_dec16(ml, offset + 1));\n        sizeof = SIZEOF_V;\n        break;\n\n      case ML_JMP:\n        r = callback(ml, offset, ML_V, op, ml_dec16(ml, offset + 1));\n        sizeof = SIZEOF_V + ml_dec16(ml, offset + 1);\n        break;\n      case ML_JMP32:\n        r = callback(ml, offset, ML_W, op, ml_dec32(ml, offset + 1));\n        sizeof = SIZEOF_W + ml_dec32(ml, offset + 1);\n        break;\n\n      case ML_NOOP2:\n        r = callback(ml, offset, ML_NO_ARGS, op);\n        sizeof = 2;\n        break;\n      case ML_NOOP3:\n        r = callback(ml, offset, ML_NO_ARGS, op);\n        sizeof = 3;\n        break;\n      case ML_NOOP4:\n        r = callback(ml, offset, ML_NO_ARGS, op);\n        sizeof = 4;\n        break;\n\n      case ML_NOOP:\n      case ML_START:\n      case ML_STOP:\n        r = callback(ml, offset, ML_NO_ARGS, op);\n        sizeof = 1;\n        break;\n\n      default:\n        TRACE('(ml_walkVars) unknown op: ' + ml[offset], ' at', offset);\n        ml_throw(ml, offset, '(ml_walkVars) unknown op');\n    }\n\n    ASSERT(sizeof > 0, 'ops should occupy space');\n    if (r !== undefined) return r;\n    offset += sizeof;\n  }\n}\n\nfunction ml_validateSkeleton(ml, msg) {\n  if (process.env.NODE_ENV !== 'production') {\n    TRACE_SILENT('--- ml_validateSkeleton', msg);\n    let started = false;\n    let stopped = false;\n    ml_walk(ml, 0, (ml, offset, op) => {\n      if (op === ML_START && offset === 0) started = true;\n      if (op === ML_START && offset !== 0)\n        ml_throw(\n          ml,\n          offset,\n          'ml_validateSkeleton: Found ML_START at offset',\n          offset\n        );\n      if (op === ML_STOP) stopped = true;\n      else if (stopped)\n        ml_throw(\n          ml,\n          offset,\n          'ml_validateSkeleton: Should stop after encountering a stop but did not'\n        );\n    });\n\n    if (!started || !stopped)\n      ml_throw(\n        ml,\n        ml.length,\n        'ml_validateSkeleton: Missing a ML_START or ML_STOP'\n      );\n    TRACE_SILENT('--- PASS ml_validateSkeleton');\n    return true;\n  }\n}\n\nfunction ml_getRecycleOffset(ml, fromOffset, requiredSize) {\n  TRACE(\n    ' - ml_getRecycleOffset looking for at least',\n    requiredSize,\n    'bytes of free space'\n  );\n  ASSERT(\n    typeof fromOffset === 'number' && fromOffset >= 0,\n    'expecting fromOffset',\n    fromOffset\n  );\n  ASSERT(\n    typeof requiredSize === 'number' && requiredSize > 0,\n    'expecting size',\n    requiredSize\n  );\n  // Find a jump which covers at least the requiredSize\n  return ml_walk(ml, fromOffset, (ml, offset, op) => {\n    TRACE('   - considering op', op, 'at', offset);\n    if (op === ML_JMP || op === ML_JMP32) {\n      const size = ml_getOpSizeSlow(ml, offset);\n      TRACE(\n        '   - found jump of',\n        size,\n        'bytes at',\n        offset + ', wanted',\n        requiredSize,\n        requiredSize <= size ? ' so is ok!' : ' so is too small'\n      );\n      if (size >= requiredSize) return offset;\n    }\n  });\n}\n\nfunction ml_getRecycleOffsets(ml, fromOffset, slotCount, sizePerSlot) {\n  TRACE(\n    ' - ml_getRecycleOffsets looking for empty spaces to fill',\n    slotCount,\n    'times',\n    sizePerSlot,\n    'bytes'\n  );\n  ASSERT(\n    typeof fromOffset === 'number' && fromOffset >= 0,\n    'expecting fromOffset',\n    fromOffset\n  );\n  ASSERT(\n    typeof slotCount === 'number' && slotCount > 0,\n    'expecting slotCount',\n    slotCount\n  );\n  ASSERT(\n    typeof sizePerSlot === 'number' && sizePerSlot > 0,\n    'expecting sizePerSlot',\n    sizePerSlot\n  );\n\n  const spaces = [];\n\n  // Find a jump which covers at least the requiredSize\n  ml_walk(ml, fromOffset, (ml, offset, op) => {\n    TRACE('   - considering op', op, 'at', offset);\n    if (op === ML_JMP || op === ML_JMP32) {\n      let size = ml_getOpSizeSlow(ml, offset);\n      TRACE(\n        '   - found jump of',\n        size,\n        'bytes at',\n        offset + ', wanted',\n        sizePerSlot,\n        sizePerSlot <= size ? ' so is ok!' : ' so is too small'\n      );\n      if (size >= sizePerSlot) {\n        spaces.push(offset); // Only add it once!\n        do {\n          // Remove as many from count as there fit in this empty space\n          --slotCount;\n          size -= sizePerSlot;\n        } while (slotCount && size >= sizePerSlot);\n\n        if (!slotCount) return true;\n      }\n    }\n  });\n\n  if (slotCount) return false; // Unable to collect enough spaces\n  return spaces;\n}\n\nfunction ml_recycles(ml, bins, loops, sizeofOp, callback) {\n  let i = 0;\n  while (i < loops) {\n    let currentRecycleOffset = bins.pop();\n    ASSERT(\n      ml_dec8(ml, currentRecycleOffset) === ML_JMP,\n      'should only get jumps here'\n    ); // Might trap a case where we clobber\n    let sizeLeft = ml_getOpSizeSlow(ml, currentRecycleOffset);\n    ASSERT(\n      sizeLeft >= sizeofOp,\n      'this is what should have been asked for when getting recycled spaces'\n    );\n    do {\n      const stop = callback(currentRecycleOffset, i, sizeLeft);\n      if (stop) return;\n      ++i;\n      sizeLeft -= sizeofOp;\n      currentRecycleOffset += sizeofOp;\n    } while (sizeLeft >= sizeofOp && i < loops);\n\n    if (sizeLeft) ml_compileJumpSafe(ml, currentRecycleOffset, sizeLeft);\n    ASSERT(ml_validateSkeleton(ml), 'ml_recycles'); // Cant check earlier\n  }\n}\n\nfunction ml_getOpSizeSlow(ml, offset) {\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset >= 0 && offset < ml.length,\n    'ml_getOpSizeSlow OOB'\n  );\n  // This is much slower compared to using the constants because it has to read from the ML\n  // this function exists to suplement recycling, where you must read the size of the jump\n  // otherwise you won't know how much space is left after recycling\n  const size = ml_sizeof(ml, offset, ml[offset]);\n  TRACE_SILENT(' - ml_getOpSizeSlow', offset, ml.length, '-->', size);\n  return size;\n}\n\nfunction ml_recycleC3(ml, offset, op, indexA, indexB, indexC) {\n  // Explicitly rewrite a count with len=3\n  const jumpOp = ml_dec8(ml, offset);\n  TRACE(\n    '- ml_recycleC3 | offset=',\n    offset,\n    ', op=',\n    op,\n    indexA,\n    indexB,\n    indexC,\n    jumpOp\n  );\n  ASSERT(\n    jumpOp === ML_JMP || jumpOp === ML_JMP32,\n    'expecting to recycle a space that starts with a jump'\n  );\n  ASSERT(\n    (jumpOp === ML_JMP\n      ? SIZEOF_V + ml_dec16(ml, offset + 1)\n      : SIZEOF_W + ml_dec32(ml, offset + 1)) >=\n      SIZEOF_C + 6,\n    'a c3 should fit'\n  ); // Op + len + 3*2\n\n  const currentSize =\n    jumpOp === ML_JMP\n      ? SIZEOF_V + ml_dec16(ml, offset + 1)\n      : SIZEOF_W + ml_dec32(ml, offset + 1);\n  const newSize = SIZEOF_C + 6;\n  const remainsEmpty = currentSize - newSize;\n  if (remainsEmpty < 0) THROW('recycled OOB');\n  TRACE(\n    '- putting a c3',\n    op,\n    'at',\n    offset,\n    ', old size=',\n    currentSize,\n    ', new size=',\n    newSize,\n    ', leaving',\n    remainsEmpty,\n    'for a jump'\n  );\n\n  ml_enc8(ml, offset, op);\n  ml_enc16(ml, offset + 1, 3);\n  ml_enc16(ml, offset + 3, indexA);\n  ml_enc16(ml, offset + 5, indexB);\n  ml_enc16(ml, offset + 7, indexC);\n\n  if (remainsEmpty) ml_compileJumpSafe(ml, offset + newSize, remainsEmpty);\n}\n\nfunction ml_recycleVV(ml, offset, op, indexA, indexB) {\n  const jumpOp = ml_dec8(ml, offset);\n  TRACE('- ml_recycleVV', offset, op, indexA, indexB, jumpOp);\n  ASSERT(\n    jumpOp === ML_JMP || jumpOp === ML_JMP32,\n    'expecting to recycle a space that starts with a jump'\n  );\n  ASSERT(\n    (jumpOp === ML_JMP\n      ? SIZEOF_V + ml_dec16(ml, offset + 1)\n      : SIZEOF_W + ml_dec32(ml, offset + 1)) >= SIZEOF_VV,\n    'a vv should fit'\n  ); // Op + len + 3*2\n\n  const currentSize =\n    jumpOp === ML_JMP\n      ? SIZEOF_V + ml_dec16(ml, offset + 1)\n      : SIZEOF_W + ml_dec32(ml, offset + 1);\n  const remainsEmpty = currentSize - SIZEOF_VV;\n  if (remainsEmpty < 0) THROW('recycled OOB');\n  TRACE(\n    '- putting a vv',\n    op,\n    'at',\n    offset,\n    'of size',\n    currentSize,\n    'leaving',\n    remainsEmpty,\n    'for a jump'\n  );\n\n  ml_enc8(ml, offset, op);\n  ml_enc16(ml, offset + 1, indexA);\n  ml_enc16(ml, offset + 3, indexB);\n\n  if (remainsEmpty) ml_compileJumpSafe(ml, offset + SIZEOF_VV, remainsEmpty);\n}\n\nfunction ml__debug(ml, offset, max, problem, mlAlways, _from_ml_throw) {\n  const getDomain = problem && problem.getDomain;\n  const names = problem && problem.varNames;\n\n  function ml_index(offset) {\n    const index = _dec16(ml, offset);\n    return (\n      '{index=' +\n      index +\n      (problem && index < names.length ? ',name=' + names[index] : '') +\n      (problem ? ',' + domain__debug(getDomain(index)) : '') +\n      '}'\n    );\n  }\n\n  function ml_16(offset) {\n    return _dec16(ml, offset);\n  }\n\n  let AB; // Grrr switches and let are annoying\n  const rv = [];\n\n  if (max < 0) max = ml.length;\n  let pc = offset;\n  let count = 0;\n  while (count++ < max && pc < ml.length) {\n    let name = '';\n    const op = ml[pc]; // Should have an option to allow it when explicitly stated like below...\n    /* eslint-disable no-fallthrough */ switch (op) {\n      case ML_START:\n        if (pc !== 0) {\n          TRACE('collected debugs up to error:', rv);\n          if (!_from_ml_throw) ml_throw(ml, pc, 'ML_START at non-zero');\n          rv.push('unused_error(0)');\n          return rv.join('\\n');\n        }\n\n        break;\n\n      case ML_IMP:\n        if (!name) name = '->';\n      /* Fall-through */\n      case ML_NIMP:\n        if (!name) name = '!->';\n      /* Fall-through */\n      case ML_LT:\n        if (!name) name = '<';\n      /* Fall-through */\n      case ML_LTE:\n        if (!name) name = '<=';\n      /* Fall-through */\n      case ML_XOR:\n        if (!name) name = '^';\n        rv.push(\n          ml_index(pc + OFFSET_C_A) +\n            ' ' +\n            name +\n            ' ' +\n            ml_index(pc + OFFSET_C_B)\n        );\n        break;\n\n      case ML_ISLT:\n        if (!name) name = '<?';\n      /* Fall-through */\n      case ML_ISLTE:\n        if (!name) name = '<=?';\n        AB = ml_index(pc + 1) + ' ' + name + ' ' + ml_index(pc + 3);\n        rv.push(ml_index(pc + 5) + ' = ' + AB);\n        break;\n\n      case ML_SUM:\n        if (!name) name = 'sum';\n      /* Fall-through */\n      case ML_PRODUCT:\n        if (!name) name = 'product';\n      /* Fall-through */\n      case ML_ISALL:\n        if (!name) name = 'isall';\n      /* Fall-through */\n      case ML_ISDIFF:\n        if (!name) name = 'isdiff';\n      /* Fall-through */\n      case ML_ISNALL:\n        if (!name) name = 'isnall';\n      /* Fall-through */\n      case ML_ISSAME:\n        if (!name) name = 'issame';\n      /* Fall-through */\n      case ML_ISSOME:\n        if (!name) name = 'issome';\n      /* Fall-through */\n      case ML_ISNONE:\n        if (!name) name = 'isnone';\n        let vars = '';\n        const varcount = ml_16(pc + 1);\n        for (let i = 0; i < varcount; ++i) {\n          vars += ml_index(pc + SIZEOF_C + i * 2) + ' ';\n        }\n\n        vars = name + '(' + vars + ')';\n        vars = ml_index(pc + SIZEOF_C + varcount * 2) + ' = ' + vars;\n        rv.push(vars);\n        break;\n\n      case ML_ALL:\n        if (!name) name = 'all';\n      /* Fall-through */\n      case ML_NALL:\n        if (!name) name = 'nall';\n      /* Fall-through */\n      case ML_SAME:\n        if (!name) name = 'same';\n      /* Fall-through */\n      case ML_SOME:\n        if (!name) name = 'some';\n      /* Fall-through */\n      case ML_NONE:\n        if (!name) name = 'none';\n      /* Fall-through */\n      case ML_XNOR:\n        if (!name) name = 'xnor';\n      /* Fall-through */\n      case ML_DIFF:\n        if (!name) name = 'diff';\n        let xvars = '';\n        const xvarcount = ml_16(pc + 1);\n        for (let i = 0; i < xvarcount; ++i) {\n          xvars += ml_index(pc + SIZEOF_C + i * 2) + ' ';\n        }\n\n        xvars = name + '(' + xvars + ')';\n        rv.push(xvars);\n        break;\n\n      case ML_MINUS:\n        if (!name) name = '-';\n      /* Fall-through */\n      case ML_DIV:\n        if (!name) name = '/';\n        AB = ml_index(pc + 1) + ' ' + name + ' ' + ml_index(pc + 3);\n        rv.push(ml_index(pc + 5) + ' = ' + AB);\n        break;\n\n      case ML_JMP:\n        rv.push('jmp(' + _dec16(ml, pc + 1) + ')');\n        break;\n      case ML_JMP32:\n        rv.push('jmp32(' + _dec32(ml, pc + 1) + ')');\n        break;\n\n      case ML_NOBOOL:\n        rv.push('nobool(' + _dec16(ml, pc + 1) + ')');\n        break;\n      case ML_NOLEAF:\n        rv.push('noleaf(' + _dec16(ml, pc + 1) + ')');\n        break;\n      case ML_NOOP:\n        rv.push('noop(1)');\n        break;\n      case ML_NOOP2:\n        rv.push('noop(2)');\n        break;\n      case ML_NOOP3:\n        rv.push('noop(3)');\n        break;\n      case ML_NOOP4:\n        rv.push('noop(4)');\n        break;\n      case ML_STOP:\n        rv.push('stop()');\n        break;\n\n      default:\n        THROW('add me [pc=' + pc + ', op=' + ml[pc] + ']');\n    }\n\n    const size = ml_sizeof(ml, pc, op);\n    // GetTerm().log('size was:', size, 'rv=', rv);\n    if (max !== 1 || mlAlways)\n      rv.push(\n        '\\u001B[90m' +\n          size +\n          'b (' +\n          pc +\n          ' ~ ' +\n          (pc + size) +\n          ') -> 0x   ' +\n          [...ml.slice(pc, pc + Math.min(size, 100))]\n            .map(c => (c < 16 ? '0' : '') + c.toString(16))\n            .join(' ') +\n          (size > 100 ? '... (trunced)' : '') +\n          '\\u001B[0m'\n      );\n    pc += size;\n  }\n\n  return max === 1\n    ? rv.join('\\n')\n    : ' ## ML Debug:\\n' +\n        rv.join('\\n') +\n        '\\n ## End of ML Debug' +\n        (offset || pc < ml.length\n          ? offset\n            ? ' (did not start at begin of ml!)'\n            : ' (did not list all ops, ml at ' +\n              pc +\n              ' / ' +\n              ml.length +\n              '))...'\n          : '') +\n        '\\n';\n}\n\nfunction ml__opName(op) {\n  ASSERT(typeof op === 'number', 'op should be a constant number');\n  switch (op) {\n    case ML_ALL:\n      return 'ML_ALL';\n    case ML_START:\n      return 'ML_START';\n    case ML_SAME:\n      return 'ML_SAME';\n    case ML_LT:\n      return 'ML_LT';\n    case ML_LTE:\n      return 'ML_LTE';\n    case ML_XOR:\n      return 'ML_XOR';\n    case ML_XNOR:\n      return 'ML_XNOR';\n    case ML_IMP:\n      return 'ML_IMP';\n    case ML_NIMP:\n      return 'ML_NIMP';\n    case ML_ISSAME:\n      return 'ML_ISSAME';\n    case ML_ISDIFF:\n      return 'ML_ISDIFF';\n    case ML_ISLT:\n      return 'ML_ISLT';\n    case ML_ISLTE:\n      return 'ML_ISLTE';\n    case ML_SUM:\n      return 'ML_SUM';\n    case ML_PRODUCT:\n      return 'ML_PRODUCT';\n    case ML_ISALL:\n      return 'ML_ISALL';\n    case ML_ISNALL:\n      return 'ML_ISNALL';\n    case ML_ISSOME:\n      return 'ML_ISSOME';\n    case ML_ISNONE:\n      return 'ML_ISNONE';\n    case ML_NALL:\n      return 'ML_NALL';\n    case ML_SOME:\n      return 'ML_SOME';\n    case ML_NONE:\n      return 'ML_NONE';\n    case ML_DIFF:\n      return 'ML_DISTINCT';\n    case ML_MINUS:\n      return 'ML_MINUS';\n    case ML_DIV:\n      return 'ML_DIV';\n    case ML_NOBOOL:\n      return 'ML_NOBOOL';\n    case ML_NOLEAF:\n      return 'ML_NOLEAF';\n    case ML_JMP:\n      return 'ML_JMP';\n    case ML_JMP32:\n      return 'ML_JMP32';\n    case ML_NOOP:\n      return 'ML_NOOP';\n    case ML_NOOP2:\n      return 'ML_NOOP2';\n    case ML_NOOP3:\n      return 'ML_NOOP3';\n    case ML_NOOP4:\n      return 'ML_NOOP4';\n    case ML_STOP:\n      return 'ML_STOP';\n    default:\n      THROW('[ML] unknown op, fixme [' + op + ']');\n  }\n}\n\nfunction ml_throw(ml, offset, msg) {\n  const term = getTerm();\n  term.error('\\nThere was an ML related error;', msg);\n  const before = ml.slice(Math.max(0, offset - 30), offset);\n  const after = ml.slice(offset, offset + 20);\n  term.error(\n    'ML at error (offset=' + offset + '/' + ml.length + '):',\n    before,\n    after\n  );\n  term.error('->', ml__debug(ml, offset, 1, undefined, true, true));\n  THROW(msg);\n}\n\nfunction ml_getOpList(ml) {\n  let pc = 0;\n  const rv = [];\n  while (pc < ml.length) {\n    const op = ml[pc];\n    switch (op) {\n      case ML_START:\n        if (pc !== 0) {\n          rv.push('error(0)');\n          return rv.join(',');\n        }\n\n        break;\n\n      case ML_SAME:\n        rv.push('same');\n        break;\n      case ML_LT:\n        rv.push('lt');\n        break;\n      case ML_LTE:\n        rv.push('lte');\n        break;\n      case ML_ALL:\n        rv.push('all');\n        break;\n      case ML_NONE:\n        rv.push('none');\n        break;\n      case ML_XOR:\n        rv.push('xor');\n        break;\n      case ML_XNOR:\n        rv.push('xnor');\n        break;\n      case ML_IMP:\n        rv.push('imp');\n        break;\n      case ML_NIMP:\n        rv.push('nimp');\n        break;\n\n      case ML_ISLT:\n        rv.push('islt');\n        break;\n      case ML_ISLTE:\n        rv.push('islte');\n        break;\n\n      case ML_SUM:\n        rv.push('sum');\n        break;\n      case ML_PRODUCT:\n        rv.push('product');\n        break;\n\n      case ML_ISALL:\n        rv.push('isall');\n        break;\n      case ML_ISDIFF:\n        rv.push('isdiff');\n        break;\n      case ML_ISNALL:\n        rv.push('isnall');\n        break;\n      case ML_ISNONE:\n        rv.push('isnone');\n        break;\n      case ML_ISSAME:\n        rv.push('issame');\n        break;\n      case ML_ISSOME:\n        rv.push('issome');\n        break;\n\n      case ML_NALL:\n        rv.push('nall');\n        break;\n      case ML_SOME:\n        rv.push('some');\n        break;\n      case ML_DIFF:\n        rv.push('diff');\n        break;\n\n      case ML_MINUS:\n        rv.push('minus');\n        break;\n      case ML_DIV:\n        rv.push('div');\n        break;\n\n      case ML_NOBOOL:\n      case ML_NOLEAF:\n      case ML_JMP:\n      case ML_JMP32:\n      case ML_NOOP:\n      case ML_NOOP2:\n      case ML_NOOP3:\n      case ML_NOOP4:\n      case ML_STOP:\n        break;\n\n      default:\n        rv.push('??!??');\n    }\n\n    pc += ml_sizeof(ml, pc, op);\n  }\n\n  return rv.sort((a, b) => (a < b ? -1 : 1)).join(',');\n}\n\nfunction ml_heapSort16bitInline(ml, offset, argCount) {\n  _ml_heapSort16bitInline(ml, offset, argCount);\n  // TRACE('     - op now:', ml__debug(ml, offset-SIZEOF_C, 1))\n  TRACE(\n    '     ### </ml_heapSort16bitInline> values after:',\n    new Array(argCount)\n      .fill(0)\n      .map((_, i) => _dec16(ml, offset + i * 2))\n      .join(' '),\n    'buf:',\n    ml.slice(offset, offset + argCount * 2).join(' ')\n  );\n  ASSERT(ml_validateSkeleton(ml, 'ml_heapSort16bitInline'));\n}\n\nfunction _ml_heapSort16bitInline(ml, offset, argCount) {\n  ASSERT(ml instanceof Uint8Array, 'ml is Uint8Array');\n  ASSERT(\n    typeof offset === 'number' &&\n      (offset === 0 || (offset > 0 && offset < ml.length)),\n    'valid offset',\n    ml.length,\n    offset,\n    argCount\n  );\n  ASSERT(\n    typeof argCount === 'number' &&\n      (argCount === 0 || (argCount > 0 && offset + argCount * 2 <= ml.length)),\n    'valid count',\n    ml.length,\n    offset,\n    argCount\n  );\n\n  TRACE(\n    '     ### <ml_heapSort16bitInline>, argCount=',\n    argCount,\n    ', offset=',\n    offset,\n    ', buf=',\n    ml.slice(offset, offset + argCount * 2)\n  );\n  TRACE(\n    '     - values before:',\n    new Array(argCount)\n      .fill(0)\n      .map((_, i) => _dec16(ml, offset + i * 2))\n      .join(' ')\n  );\n\n  if (argCount <= 1) {\n    TRACE(' - (argCount <= 1 so finished)');\n    return;\n  }\n\n  ml_heapify(ml, offset, argCount);\n\n  let end = argCount - 1;\n  while (end > 0) {\n    TRACE(\n      '     - swapping first elemement (should be biggest of values left to do) [',\n      _dec16(ml, offset),\n      '] with last [',\n      _dec16(ml, offset + end * 2),\n      '] and reducing end [',\n      end,\n      '->',\n      end - 1,\n      ']'\n    );\n    ml_swap16(ml, offset, offset + end * 2);\n    TRACE(\n      '     - (total) buffer now: Uint8Array(',\n      [].map\n        .call(\n          ml.slice(offset, offset + argCount * 2),\n          b => (b < 16 ? '0' : '') + b.toString(16)\n        )\n        .join(' '),\n      ')'\n    );\n    --end;\n    ml_heapRepair(ml, offset, 0, end);\n  }\n}\n\nfunction ml_heapParent(index) {\n  return Math.floor((index - 1) / 2);\n}\n\nfunction ml_heapLeft(index) {\n  return index * 2 + 1;\n}\n\nfunction ml_heapRight(index) {\n  return index * 2 + 2;\n}\n\nfunction ml_heapify(ml, offset, len) {\n  TRACE('     - ml_heapify', ml.slice(offset, offset + len * 2), offset, len);\n\n  let start = ml_heapParent(len - 1);\n  while (start >= 0) {\n    ml_heapRepair(ml, offset, start, len - 1);\n    --start; // Wont this cause it to do it redundantly twice?\n  }\n\n  TRACE('     - ml_heapify end');\n}\n\nfunction ml_heapRepair(ml, offset, startIndex, endIndex) {\n  TRACE(\n    '     - ml_heapRepair',\n    offset,\n    startIndex,\n    endIndex,\n    'Uint8Array(',\n    [].map\n      .call(\n        ml.slice(\n          offset + startIndex * 2,\n          offset + startIndex * 2 + (endIndex - startIndex + 1) * 2\n        ),\n        b => (b < 16 ? '0' : '') + b.toString(16)\n      )\n      .join(' '),\n    ')'\n  );\n  let parentIndex = startIndex;\n  const parentValue = ml_dec16(ml, offset + parentIndex * 2);\n  let leftIndex = ml_heapLeft(parentIndex);\n  TRACE('     -- first leftIndex=', leftIndex, 'end=', endIndex);\n\n  while (leftIndex <= endIndex) {\n    TRACE(\n      '       - sift loop. indexes; parent=',\n      parentIndex,\n      'left=',\n      leftIndex,\n      'right=',\n      ml_heapRight(parentIndex),\n      'values; parent=',\n      _dec16(ml, offset + parentIndex * 2) + '/' + parentValue,\n      ' left=',\n      _dec16(ml, offset + leftIndex * 2),\n      ' right=',\n      ml_heapRight(parentIndex) <= endIndex\n        ? _dec16(ml, offset + ml_heapRight(parentIndex) * 2)\n        : 'void'\n    );\n    const leftValue = ml_dec16(ml, offset + leftIndex * 2);\n    let swapIndex = parentIndex;\n    let swapValue = parentValue;\n\n    TRACE(\n      '         - swap<left?',\n      swapValue,\n      leftValue,\n      swapValue < leftValue ? 'yes' : 'no'\n    );\n    if (swapValue < leftValue) {\n      swapIndex = leftIndex;\n      swapValue = leftValue;\n    }\n\n    const rightIndex = ml_heapRight(parentIndex);\n    TRACE(\n      '         - right index',\n      rightIndex,\n      '<=',\n      endIndex,\n      rightIndex <= endIndex ? 'yes it has a right child' : 'no right child'\n    );\n    if (rightIndex <= endIndex) {\n      const rightValue = ml_dec16(ml, offset + rightIndex * 2);\n      TRACE('         - swap<right?', swapValue, rightValue);\n      if (swapValue < rightValue) {\n        swapIndex = rightIndex;\n        swapValue = rightValue;\n      }\n    }\n\n    TRACE(\n      '           - result; parent=',\n      parentIndex,\n      'swap=',\n      swapIndex,\n      ', values; parent=',\n      parentValue,\n      ', swap=',\n      swapValue,\n      '->',\n      swapIndex === parentIndex ? 'finished, parent=swap' : 'should swap'\n    );\n\n    if (swapIndex === parentIndex) {\n      TRACE(\n        '     - ml_heapRepair end early:',\n        'Uint8Array(',\n        [].map\n          .call(\n            ml.slice(\n              offset + startIndex * 2,\n              offset + startIndex * 2 + (endIndex - startIndex + 1) * 2\n            ),\n            b => (b < 16 ? '0' : '') + b.toString(16)\n          )\n          .join(' '),\n        ')'\n      );\n      return;\n    }\n\n    // \"swap\"\n    ml_enc16(ml, offset + parentIndex * 2, swapValue);\n    ml_enc16(ml, offset + swapIndex * 2, parentValue);\n    TRACE(\n      '             - setting parent to index=',\n      swapIndex,\n      ', value=',\n      swapValue\n    );\n    parentIndex = swapIndex;\n    // Note: parentValue remains the same because the swapped child becomes the new parent and it gets the old parent value\n\n    leftIndex = ml_heapLeft(parentIndex);\n    TRACE('           - next left:', leftIndex, 'end:', endIndex);\n  }\n\n  TRACE(\n    '     - ml_heapRepair end:',\n    ml\n      .slice(\n        offset + startIndex * 2,\n        offset + startIndex * 2 + (endIndex - startIndex + 1) * 2\n      )\n      .join(' ')\n  );\n}\n\nfunction ml_swap16(ml, indexA, indexB) {\n  const A = ml_dec16(ml, indexA);\n  const B = ml_dec16(ml, indexB);\n  ml_enc16(ml, indexA, B);\n  ml_enc16(ml, indexB, A);\n}\n\nexport {\n  ML_ALL,\n  ML_DIFF,\n  ML_DIV,\n  ML_IMP,\n  ML_ISALL,\n  ML_ISDIFF,\n  ML_ISLT,\n  ML_ISLTE,\n  ML_ISNALL,\n  ML_ISNONE,\n  ML_ISSAME,\n  ML_ISSOME,\n  ML_JMP,\n  ML_JMP32,\n  ML_LT,\n  ML_LTE,\n  ML_MINUS,\n  ML_NALL,\n  ML_NIMP,\n  ML_NOBOOL,\n  ML_NOLEAF,\n  ML_NONE,\n  ML_NOOP,\n  ML_NOOP2,\n  ML_NOOP3,\n  ML_NOOP4,\n  ML_PRODUCT,\n  ML_SAME,\n  ML_SOME,\n  ML_START,\n  ML_STOP,\n  ML_SUM,\n  ML_XNOR,\n  ML_XOR,\n  SIZEOF_C,\n  SIZEOF_CR_2,\n  SIZEOF_C_2,\n  SIZEOF_V,\n  SIZEOF_VV,\n  SIZEOF_VVV,\n  SIZEOF_W,\n  OFFSET_C_A,\n  OFFSET_C_B,\n  OFFSET_C_C,\n  OFFSET_C_R,\n  ML_NO_ARGS,\n  ML_C,\n  ML_C8R,\n  ML_CR,\n  ML_V,\n  ML_VV,\n  ML_VVV,\n  ML_W,\n  ml__debug,\n  ml__opName,\n  ml_compileJumpAndConsolidate,\n  ml_compileJumpSafe,\n  ml_countConstraints,\n  ml_dec16,\n  ml_dec32,\n  ml_dec8,\n  ml_eliminate,\n  ml_enc16,\n  ml_enc32,\n  ml_enc8,\n  ml_getOpList,\n  ml_getOpSizeSlow,\n  ml_getRecycleOffset,\n  ml_getRecycleOffsets,\n  ml_hasConstraint,\n  ml_heapSort16bitInline,\n  ml_pump,\n  ml_recycleC3,\n  ml_recycleVV,\n  ml_recycles,\n  ml_sizeof,\n  ml_stream,\n  ml_throw,\n  ml_validateSkeleton,\n  ml_walk,\n  _ml_heapSort16bitInline,\n  ml_any2c,\n  ml_any2cr,\n  ml_c2c2,\n  ml_c2vv,\n  ml_cr2c,\n  ml_cr2c2,\n  ml_cr2cr2,\n  ml_cr2vv,\n  ml_cr2vvv,\n  ml_cx2cx,\n  ml_vv2vv,\n  ml_vvv2c2,\n  ml_vvv2vv,\n  ml_vvv2vvv,\n};\n","import {\n  ASSERT,\n  ASSERT_NORDOM,\n  TRACE,\n  getTerm,\n  THROW,\n  domain__debug,\n  domain_getValue,\n} from 'fdlib';\n\nimport {\n  ML_ALL,\n  ML_NOBOOL,\n  ML_NOLEAF,\n  ML_DIFF,\n  ML_DIV,\n  ML_IMP,\n  ML_ISALL,\n  ML_ISDIFF,\n  ML_ISLT,\n  ML_ISLTE,\n  ML_ISNALL,\n  ML_ISNONE,\n  ML_ISSAME,\n  ML_ISSOME,\n  ML_JMP,\n  ML_JMP32,\n  ML_LT,\n  ML_LTE,\n  ML_MINUS,\n  ML_NALL,\n  ML_NIMP,\n  ML_NONE,\n  ML_NOOP,\n  ML_NOOP2,\n  ML_NOOP3,\n  ML_NOOP4,\n  ML_PRODUCT,\n  ML_SAME,\n  ML_SOME,\n  ML_START,\n  ML_STOP,\n  ML_SUM,\n  ML_XNOR,\n  ML_XOR,\n  OFFSET_C_A,\n  OFFSET_C_B,\n  SIZEOF_V,\n  SIZEOF_W,\n  SIZEOF_VVV,\n  SIZEOF_C,\n  SIZEOF_C_2,\n  ml__debug,\n  ml_dec16,\n  ml_dec32,\n  ml_throw,\n} from './ml';\n\nlet bounty_flagCounter = 0;\nconst BOUNTY_NO_FLAGS = bounty_flagCounter;\nconst BOUNTY_FLAG_NOT_BOOLY = ++bounty_flagCounter; // Booly = when only used in bool ops (like nall) or as the lhs of a reifier\nconst BOUNTY_FLAG_OTHER = ++bounty_flagCounter;\n\nconst BOUNTY_FLAG_DIFF = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_IMP_LHS = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_IMP_RHS = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_ISALL_ARG = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_ISALL_RESULT = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_ISLTE_ARG = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_ISSAME_ARG = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_ISSAME_RESULT = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_ISSOME_RESULT = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_LTE_LHS = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_LTE_RHS = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_NALL = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_SOME = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_SUM_RESULT = 1 << ++bounty_flagCounter;\nconst BOUNTY_FLAG_XOR = 1 << ++bounty_flagCounter;\nconst BOUNTY_JUST_IGNORE = 1 << ++bounty_flagCounter;\n\nASSERT(\n  bounty_flagCounter <= 32,\n  'can only run with 16 flags, or must increase flag size'\n);\n\nconst BOUNTY_LINK_COUNT = 1; // Should it simply trunc over 255?\nconst BOUNTY_META_FLAGS = 32; // Steps of 8 (bits per byte)\nconst BOUNTY_MAX_OFFSETS_TO_TRACK = 20; // Perf case bounty size when this is: 5->1mb, 20->3mb\nconst BOUNTY_BYTES_PER_OFFSET = 4;\n\nconst BOUNTY_SIZEOF_HEADER = BOUNTY_LINK_COUNT + BOUNTY_META_FLAGS / 2;\nconst BOUNTY_SIZEOF_OFFSETS =\n  BOUNTY_MAX_OFFSETS_TO_TRACK * BOUNTY_BYTES_PER_OFFSET; // Need to store 32bit per offset (more like 24 but whatever)\nconst BOUNTY_SIZEOF_VAR = BOUNTY_SIZEOF_HEADER + BOUNTY_SIZEOF_OFFSETS;\n\n/**\n * @param {Uint8Array} ml\n * @param {Object} problem\n * @param {Uint8Array} [bounty]\n */\nfunction bounty_collect(ml, problem, bounty) {\n  TRACE('\\n ## bounty_collect', ml.length < 50 ? ml.join(' ') : '');\n\n  const { varNames, getAlias, getDomain } = problem;\n  const varCount = varNames.length;\n\n  let pc = 0;\n\n  if (!bounty) {\n    bounty = new Uint8Array(varCount * BOUNTY_SIZEOF_VAR);\n    TRACE('Created bounty buffer. Size:', bounty.length);\n  }\n\n  bounty.fill(0); // Even for new buffer because they are not guaranteed to be zero filled (most like not)\n  ASSERT(bounty instanceof Uint8Array);\n\n  bountyLoop();\n\n  // Note: do not auto-mark booly-pairs as BOOLY here! (for example `x^y,x!=z` could break if x!=y)\n\n  TRACE(\n    ` - There are ${getDeadCount(bounty)} dead vars, ${getLeafCount(\n      bounty\n    )} leaf vars, full distribution: ${getOccurrenceCount(bounty)} other vars`\n  );\n\n  return bounty;\n\n  function getBountyOffset(varIndex) {\n    return varIndex * BOUNTY_SIZEOF_VAR;\n  }\n\n  function getOffsetsOffset(varIndex) {\n    return varIndex * BOUNTY_SIZEOF_VAR + BOUNTY_SIZEOF_HEADER;\n  }\n\n  function collect(delta, metaFlags) {\n    TRACE('   ! collect(', delta, ',', _bounty__debugMeta(metaFlags), ')');\n    ASSERT(\n      typeof delta === 'number' && delta > 0,\n      'delta should be >0 number',\n      delta\n    );\n    ASSERT(\n      pc + delta > 0 && pc + delta < ml.length,\n      'offset should be within bounds of ML'\n    );\n    ASSERT(\n      typeof metaFlags === 'number' && metaFlags > 0,\n      'at least one metaFlags should be passed on',\n      metaFlags,\n      metaFlags.toString(2)\n    );\n\n    let index = ml_dec16(ml, pc + delta);\n    ASSERT(typeof index === 'number', 'fetched index should be number');\n    ASSERT(\n      !isNaN(index) && index >= 0 && index <= 0xffff,\n      'should be a valid index',\n      index\n    );\n    index = getAlias(index);\n    ASSERT(typeof index === 'number', 'fetched alias should be number');\n    ASSERT(\n      !isNaN(index) && index >= 0 && index <= 0xffff,\n      'should be a valid index',\n      index\n    );\n\n    const domain = getDomain(index, true);\n    TRACE('     - index=', index, 'domain=', domain__debug(domain));\n    ASSERT_NORDOM(domain);\n    if (domain_getValue(domain) >= 0) {\n      TRACE(\n        '      - ignore all constants. solved vars and constants are not relevant to bounty'\n      );\n      return;\n    }\n\n    const varOffset = getBountyOffset(index);\n\n    // ASSERT(bounty[varOffset] < 0xff, 'constraint count should not overflow');\n\n    const countIndex = bounty[varOffset]++; // Count, but as zero-offset\n\n    const flagsOffset = varOffset + BOUNTY_LINK_COUNT;\n    if (countIndex >= 0xff) {\n      // Hardcoded limit. just ignore this var. we cant safely optimize this.\n      ASSERT(BOUNTY_META_FLAGS === 32, 'update code if this changes');\n      _enc32(bounty, flagsOffset, BOUNTY_JUST_IGNORE);\n    } else {\n      ASSERT(\n        BOUNTY_META_FLAGS === 32,\n        'update code if this changes because they currently only write 16bits'\n      );\n      const currentFlags = _dec32(bounty, flagsOffset);\n\n      TRACE(\n        '     >> collecting for index=',\n        index,\n        ' -> count now:',\n        bounty[varOffset],\n        'flags:',\n        _bounty__debugMeta(currentFlags),\n        '|=',\n        _bounty__debugMeta(metaFlags),\n        ' -> ',\n        _bounty__debugMeta(currentFlags | metaFlags),\n        'from',\n        flagsOffset,\n        'domain:',\n        domain__debug(domain)\n      );\n\n      if (countIndex < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n        const offsetsOffset = getOffsetsOffset(index);\n        const nextOffset = offsetsOffset + countIndex * BOUNTY_BYTES_PER_OFFSET;\n        TRACE(\n          '       - tracking offset; countIndex=',\n          countIndex,\n          ', putting offset at',\n          nextOffset\n        );\n        _enc32(bounty, nextOffset, pc);\n      } else {\n        TRACE(\n          '       - unable to track offset; countIndex beyond max;',\n          countIndex,\n          '>',\n          BOUNTY_MAX_OFFSETS_TO_TRACK\n        );\n      }\n\n      ASSERT(BOUNTY_META_FLAGS === 32, 'update code if this changes');\n      _enc32(bounty, flagsOffset, currentFlags | metaFlags);\n    }\n  }\n\n  function bountyLoop() {\n    pc = 0;\n    TRACE(' - bountyLoop');\n    while (pc < ml.length) {\n      const pcStart = pc;\n      const op = ml[pc];\n      TRACE(' -- CT pc=' + pc + ', op: ' + ml__debug(ml, pc, 1, problem));\n      switch (op) {\n        case ML_LT:\n          // Lt always has 2 args (any other wouldnt make sense) but is still a c-args op\n          collect(OFFSET_C_A, BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY);\n          collect(OFFSET_C_B, BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY);\n          pc += SIZEOF_C_2;\n          break;\n\n        case ML_LTE:\n          // Lte always has 2 args (any other wouldnt make sense) but is still a c-args op\n          collect(OFFSET_C_A, BOUNTY_FLAG_LTE_LHS | BOUNTY_FLAG_NOT_BOOLY);\n          collect(OFFSET_C_B, BOUNTY_FLAG_LTE_RHS | BOUNTY_FLAG_NOT_BOOLY);\n          pc += SIZEOF_C_2;\n          break;\n\n        case ML_XOR: {\n          // Xor always has 2 args (any other wouldnt make sense) but is still a c-args op\n          collect(OFFSET_C_A, BOUNTY_FLAG_XOR);\n          collect(OFFSET_C_B, BOUNTY_FLAG_XOR);\n          pc += SIZEOF_C_2;\n          break;\n        }\n\n        case ML_XNOR: {\n          const nlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < nlen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_OTHER);\n          }\n\n          pc += SIZEOF_C + nlen * 2;\n          break;\n        }\n\n        case ML_IMP:\n          collect(OFFSET_C_A, BOUNTY_FLAG_IMP_LHS);\n          collect(OFFSET_C_B, BOUNTY_FLAG_IMP_RHS);\n          pc += SIZEOF_C_2;\n          break;\n\n        case ML_NIMP:\n          collect(OFFSET_C_A, BOUNTY_FLAG_OTHER);\n          collect(OFFSET_C_B, BOUNTY_FLAG_OTHER);\n          pc += SIZEOF_C_2;\n          break;\n\n        case ML_ALL: {\n          const nlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < nlen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_OTHER);\n          }\n\n          pc += SIZEOF_C + nlen * 2;\n          break;\n        }\n\n        case ML_NALL: {\n          const nlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < nlen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_NALL);\n          }\n\n          pc += SIZEOF_C + nlen * 2;\n          break;\n        }\n\n        case ML_SAME: {\n          // Should be aliased but if the problem rejected there may be eqs like this left\n          // (bounty is also used for generating the dsl problem)\n          const nlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < nlen; ++i) {\n            collect(\n              SIZEOF_C + i * 2,\n              BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY\n            );\n          }\n\n          pc += SIZEOF_C + nlen * 2;\n          break;\n        }\n\n        case ML_SOME: {\n          const nlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < nlen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_SOME);\n          }\n\n          pc += SIZEOF_C + nlen * 2;\n          break;\n        }\n\n        case ML_NONE: {\n          const nlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < nlen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_OTHER);\n          }\n\n          pc += SIZEOF_C + nlen * 2;\n          break;\n        }\n\n        case ML_ISSAME: {\n          const nlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < nlen; ++i) {\n            collect(\n              SIZEOF_C + i * 2,\n              BOUNTY_FLAG_ISSAME_ARG | BOUNTY_FLAG_NOT_BOOLY\n            );\n          }\n\n          collect(SIZEOF_C + nlen * 2, BOUNTY_FLAG_ISSAME_RESULT); // R\n          pc += SIZEOF_C + nlen * 2 + 2;\n          break;\n        }\n\n        case ML_ISSOME: {\n          const ilen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < ilen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_OTHER);\n          }\n\n          collect(SIZEOF_C + ilen * 2, BOUNTY_FLAG_ISSOME_RESULT); // R\n          pc += SIZEOF_C + ilen * 2 + 2;\n          break;\n        }\n\n        case ML_DIFF: {\n          // Note: diff \"cant\" have multiple counts of same var because that would reject\n          const dlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < dlen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_DIFF | BOUNTY_FLAG_NOT_BOOLY);\n          }\n\n          pc += SIZEOF_C + dlen * 2;\n          break;\n        }\n\n        case ML_ISDIFF: {\n          const ilen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < ilen; ++i) {\n            collect(\n              SIZEOF_C + i * 2,\n              BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY\n            );\n          }\n\n          collect(SIZEOF_C + ilen * 2, BOUNTY_FLAG_OTHER); // R\n          pc += SIZEOF_C + ilen * 2 + 2;\n          break;\n        }\n\n        case ML_ISLT:\n          collect(1, BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY);\n          collect(3, BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY);\n          collect(5, BOUNTY_FLAG_OTHER);\n          pc += SIZEOF_VVV;\n          break;\n\n        case ML_ISLTE:\n          collect(1, BOUNTY_FLAG_ISLTE_ARG | BOUNTY_FLAG_NOT_BOOLY);\n          collect(3, BOUNTY_FLAG_ISLTE_ARG | BOUNTY_FLAG_NOT_BOOLY);\n          collect(5, BOUNTY_FLAG_OTHER);\n          pc += SIZEOF_VVV;\n          break;\n\n        case ML_MINUS:\n        case ML_DIV:\n          collect(1, BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY);\n          collect(3, BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY);\n          collect(5, BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY);\n          pc += SIZEOF_VVV;\n          break;\n\n        case ML_ISALL: {\n          const ilen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < ilen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_ISALL_ARG);\n          }\n\n          collect(SIZEOF_C + ilen * 2, BOUNTY_FLAG_ISALL_RESULT); // R\n          pc += SIZEOF_C + ilen * 2 + 2;\n          break;\n        }\n\n        case ML_ISNALL:\n        case ML_ISNONE: {\n          const mlen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < mlen; ++i) {\n            collect(SIZEOF_C + i * 2, BOUNTY_FLAG_OTHER);\n          }\n\n          collect(SIZEOF_C + mlen * 2, BOUNTY_FLAG_OTHER);\n          pc += SIZEOF_C + mlen * 2 + 2;\n          break;\n        }\n\n        case ML_SUM: {\n          // TODO: collect multiple occurrences of same var once\n          const splen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < splen; ++i) {\n            collect(\n              SIZEOF_C + i * 2,\n              BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY\n            );\n          }\n\n          collect(\n            SIZEOF_C + splen * 2,\n            BOUNTY_FLAG_SUM_RESULT | BOUNTY_FLAG_NOT_BOOLY\n          ); // R\n          pc += SIZEOF_C + splen * 2 + 2;\n          break;\n        }\n\n        case ML_PRODUCT: {\n          // TODO: collect multiple occurrences of same var once\n          const plen = ml_dec16(ml, pc + 1);\n          for (let i = 0; i < plen; ++i) {\n            collect(\n              SIZEOF_C + i * 2,\n              BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY\n            );\n          }\n\n          collect(\n            SIZEOF_C + plen * 2,\n            BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY\n          ); // R\n          pc += SIZEOF_C + plen * 2 + 2;\n          break;\n        }\n\n        case ML_START:\n          if (pc !== 0) return THROW(' ! compiler problem @', pcStart);\n          ++pc;\n          break;\n\n        case ML_STOP:\n          return;\n\n        case ML_NOBOOL:\n          // For testing, consider vars under nobool explicitly not-booly\n          collect(1, BOUNTY_FLAG_OTHER | BOUNTY_FLAG_NOT_BOOLY);\n          pc += SIZEOF_V;\n          break;\n        case ML_NOLEAF:\n          // Should prevent trivial eliminations because ML_NOLEAF is never part of a trick\n          // vars under ML_NOLEAF are explicitly never considered leaf vars because their counts is inflated\n          collect(1, BOUNTY_FLAG_OTHER);\n          pc += SIZEOF_V;\n          break;\n\n        case ML_JMP:\n          pc += SIZEOF_V + ml_dec16(ml, pc + 1);\n          break;\n        case ML_JMP32:\n          pc += SIZEOF_W + ml_dec32(ml, pc + 1);\n          break;\n\n        case ML_NOOP:\n          ++pc;\n          break;\n        case ML_NOOP2:\n          pc += 2;\n          break;\n        case ML_NOOP3:\n          pc += 3;\n          break;\n        case ML_NOOP4:\n          pc += 4;\n          break;\n\n        default:\n          // Put in a switch in the default so that the main switch is smaller. this second switch should never hit.\n          getTerm().error('(cnt) unknown op', pc, ' at', pc);\n          ml_throw(\n            ml,\n            pc,\n            '(bnt) expecting bounty to run after the minifier and these ops should be gone'\n          );\n      }\n    }\n\n    ml_throw(ml, pc, 'ML OOB');\n  }\n\n  function getDeadCount(varMeta) {\n    let count = 0;\n    for (let i = 0; i < varCount; i += BOUNTY_SIZEOF_VAR) {\n      if (!varMeta[i]) ++count;\n    }\n\n    return count;\n  }\n\n  function getLeafCount(varMeta) {\n    let count = 0;\n    for (let i = 0; i < varCount; i += BOUNTY_SIZEOF_VAR) {\n      if (varMeta[i] === 1) ++count;\n    }\n\n    return count;\n  }\n\n  function getOccurrenceCount(varMeta) {\n    // Should be eliminated when not used by ASSERTs\n    const count = {};\n    for (let i = 0; i < varCount; i += BOUNTY_SIZEOF_VAR) {\n      count[varMeta[i]] = ~-count[varMeta[i]];\n    }\n\n    return count;\n  }\n}\n\nfunction bounty_getCounts(bounty, varIndex) {\n  return bounty[varIndex * BOUNTY_SIZEOF_VAR];\n}\n\nfunction bounty_markVar(bounty, varIndex) {\n  ASSERT(typeof bounty === 'object', 'bounty should be object');\n  ASSERT(\n    typeof varIndex === 'number' && varIndex >= 0,\n    'should be valid varIndex'\n  );\n\n  // Until next loop, ignore this var (need to refresh bounty data)\n  TRACE(' - bounty_markVar', varIndex);\n  bounty[varIndex * BOUNTY_SIZEOF_VAR] = 0;\n}\n\nfunction bounty_getMeta(bounty, varIndex, _debug) {\n  ASSERT(\n    bounty_getCounts(bounty, varIndex) > 0 || _debug,\n    'check caller (2), this is probably a bug (var did not appear in any constraint, or its a constant, or this data was marked as stale)'\n  );\n  return _dec32(bounty, varIndex * BOUNTY_SIZEOF_VAR + BOUNTY_LINK_COUNT);\n}\n\nfunction bounty_updateMeta(bounty, varIndex, newFlags) {\n  bounty[varIndex * BOUNTY_SIZEOF_VAR + BOUNTY_LINK_COUNT] = newFlags;\n}\n\nfunction bounty_getOffset(bounty, varIndex, n, _debug) {\n  ASSERT(\n    bounty_getCounts(bounty, varIndex) > 0 || _debug,\n    'check caller (1), this is probably a bug (var did not appear in any constraint, or its a constant, or this data was marked as stale)',\n    varIndex,\n    n,\n    bounty_getCounts(bounty, varIndex),\n    _debug\n  );\n  ASSERT(\n    n < bounty_getCounts(bounty, varIndex),\n    'check caller, this is probably a bug (should not get an offset beyond the count)'\n  );\n  ASSERT(\n    n < BOUNTY_MAX_OFFSETS_TO_TRACK,\n    'OOB, shouldnt exceed the max offset count',\n    n,\n    '<',\n    BOUNTY_MAX_OFFSETS_TO_TRACK\n  );\n  return _dec32(\n    bounty,\n    varIndex * BOUNTY_SIZEOF_VAR +\n      BOUNTY_SIZEOF_HEADER +\n      n * BOUNTY_BYTES_PER_OFFSET\n  );\n}\n\nfunction bounty__debug(bounty, varIndex, full) {\n  const count = bounty_getCounts(bounty, varIndex);\n  let r = `{B: index=${varIndex}, counts=${count}, meta=${bounty__debugMeta(\n    bounty,\n    varIndex\n  )}`;\n  if (full) {\n    r += ', offsets:[';\n    for (let i = 0; i < BOUNTY_MAX_OFFSETS_TO_TRACK; ++i) {\n      if (i) r += ', ';\n      if (i >= count) r += '(';\n      r += _dec32(\n        bounty,\n        varIndex * BOUNTY_SIZEOF_VAR +\n          BOUNTY_SIZEOF_HEADER +\n          i * BOUNTY_BYTES_PER_OFFSET\n      );\n      if (i >= count) r += ')';\n    }\n\n    r += ']';\n  }\n\n  return r + '}';\n}\n\nfunction bounty__debugMeta(bounty, index) {\n  ASSERT(typeof bounty === 'object', 'bounty object');\n  ASSERT(typeof index === 'number', 'the index should be a number', index);\n  const counts = bounty_getCounts(bounty, index) | 0; // Constants would return undefined here\n  if (counts === 0) return '[ constant or marked var ]';\n  const meta = counts && bounty_getMeta(bounty, index, true);\n  return _bounty__debugMeta(meta);\n}\n\nfunction _bounty__debugMeta(meta) {\n  ASSERT(typeof meta === 'number', 'the meta should be a number', meta);\n  const s = '0'.repeat(32 - meta.toString(2).length) + meta.toString(2);\n  const what = [];\n\n  if (!meta) what.push('BOUNTY_NONE');\n  if ((meta & BOUNTY_FLAG_NOT_BOOLY) === BOUNTY_FLAG_NOT_BOOLY) {\n    what.push('NOT_BOOLY');\n  } else {\n    what.push('BOOLY');\n  }\n\n  if ((meta & BOUNTY_FLAG_OTHER) === BOUNTY_FLAG_OTHER) what.push('OTHER');\n  if ((meta & BOUNTY_FLAG_LTE_LHS) === BOUNTY_FLAG_LTE_LHS)\n    what.push('LTE_LHS');\n  if ((meta & BOUNTY_FLAG_LTE_RHS) === BOUNTY_FLAG_LTE_RHS)\n    what.push('LTE_RHS');\n  if ((meta & BOUNTY_FLAG_ISALL_ARG) === BOUNTY_FLAG_ISALL_ARG)\n    what.push('ISALL_ARG');\n  if ((meta & BOUNTY_FLAG_ISALL_RESULT) === BOUNTY_FLAG_ISALL_RESULT)\n    what.push('ISALL_RESULT');\n  if ((meta & BOUNTY_FLAG_IMP_LHS) === BOUNTY_FLAG_IMP_LHS)\n    what.push('IMP_LHS');\n  if ((meta & BOUNTY_FLAG_IMP_RHS) === BOUNTY_FLAG_IMP_RHS)\n    what.push('IMP_RHS');\n  if ((meta & BOUNTY_FLAG_ISLTE_ARG) === BOUNTY_FLAG_ISLTE_ARG)\n    what.push('ISLTE_ARG');\n  if ((meta & BOUNTY_FLAG_ISSAME_ARG) === BOUNTY_FLAG_ISSAME_ARG)\n    what.push('ISSAME_ARG');\n  if ((meta & BOUNTY_FLAG_ISSAME_RESULT) === BOUNTY_FLAG_ISSAME_RESULT)\n    what.push('ISSAME_RESULT');\n  if ((meta & BOUNTY_FLAG_ISSOME_RESULT) === BOUNTY_FLAG_ISSOME_RESULT)\n    what.push('ISSOME_RESULT');\n  if ((meta & BOUNTY_FLAG_NALL) === BOUNTY_FLAG_NALL) what.push('NALL');\n  if ((meta & BOUNTY_FLAG_DIFF) === BOUNTY_FLAG_DIFF) what.push('DIFF');\n  if ((meta & BOUNTY_FLAG_SOME) === BOUNTY_FLAG_SOME) what.push('SOME');\n  if ((meta & BOUNTY_FLAG_SUM_RESULT) === BOUNTY_FLAG_SUM_RESULT)\n    what.push('SUM_RESULT');\n  if ((meta & BOUNTY_FLAG_XOR) === BOUNTY_FLAG_XOR) what.push('XOR');\n  if ((meta & BOUNTY_JUST_IGNORE) === BOUNTY_JUST_IGNORE)\n    what.push('JUST_IGNORE');\n\n  return '[ ' + s + ': ' + what.join(', ') + ' ]';\n}\n\nfunction _dec32(bounty, offset) {\n  ASSERT(bounty instanceof Uint8Array, 'should be Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset >= 0 && offset < bounty.length,\n    'Invalid or OOB',\n    offset,\n    '>=',\n    bounty.length\n  );\n\n  return (\n    (bounty[offset++] << 24) |\n    (bounty[offset++] << 16) |\n    (bounty[offset++] << 8) |\n    bounty[offset]\n  );\n}\n\nfunction _enc32(bounty, offset, num) {\n  ASSERT(bounty instanceof Uint8Array, 'should be Uint8Array');\n  ASSERT(\n    typeof offset === 'number' && offset >= 0 && offset < bounty.length,\n    'Invalid or OOB',\n    offset,\n    '>=',\n    bounty.length\n  );\n  ASSERT(typeof num === 'number', 'Encoding numbers');\n  ASSERT(\n    num <= 0xffffffff,\n    'implement 64bit index support if this breaks',\n    num\n  );\n  ASSERT(num >= 0, 'only expecting non-negative nums', num);\n\n  bounty[offset++] = (num >> 24) & 0xff;\n  bounty[offset++] = (num >> 16) & 0xff;\n  bounty[offset++] = (num >> 8) & 0xff;\n  bounty[offset] = num & 0xff;\n}\n\nexport {\n  BOUNTY_NO_FLAGS,\n  BOUNTY_FLAG_NOT_BOOLY,\n  BOUNTY_FLAG_OTHER,\n  BOUNTY_FLAG_DIFF,\n  BOUNTY_FLAG_IMP_LHS,\n  BOUNTY_FLAG_IMP_RHS,\n  BOUNTY_FLAG_ISALL_ARG,\n  BOUNTY_FLAG_ISALL_RESULT,\n  BOUNTY_FLAG_ISSOME_RESULT,\n  BOUNTY_FLAG_ISSAME_ARG,\n  BOUNTY_FLAG_ISSAME_RESULT,\n  BOUNTY_FLAG_ISLTE_ARG,\n  BOUNTY_FLAG_LTE_LHS,\n  BOUNTY_FLAG_LTE_RHS,\n  BOUNTY_FLAG_NALL,\n  BOUNTY_FLAG_SOME,\n  BOUNTY_FLAG_SUM_RESULT,\n  BOUNTY_FLAG_XOR,\n  BOUNTY_MAX_OFFSETS_TO_TRACK,\n  bounty__debug,\n  bounty__debugMeta,\n  bounty_collect,\n  bounty_getCounts,\n  bounty_getMeta,\n  bounty_getOffset,\n  bounty_markVar,\n  bounty_updateMeta,\n};\n","// TODO: need to update this code to use getDomain and aliases and such\n//\n// this is an import function for config\n// it converts a DSL string to a $config\n// see /docs/dsl.txt for syntax\n// see exporter.js to convert a config to this DSL\nimport { ASSERT, TRACE, isTracing, setTracing } from 'fdlib';\n\nimport { domain__debug, domain_getValue, domain_toArr } from 'fdlib';\n\nimport { getTerm, THROW } from 'fdlib';\n\nimport {\n  ML_ALL,\n  ML_NOBOOL,\n  ML_NOLEAF,\n  ML_DIFF,\n  ML_DIV,\n  ML_IMP,\n  ML_ISALL,\n  ML_ISDIFF,\n  ML_ISSAME,\n  ML_ISLT,\n  ML_ISLTE,\n  ML_ISNALL,\n  ML_ISNONE,\n  ML_ISSOME,\n  ML_JMP,\n  ML_JMP32,\n  ML_LT,\n  ML_LTE,\n  ML_MINUS,\n  ML_NALL,\n  ML_NIMP,\n  ML_NONE,\n  ML_NOOP,\n  ML_NOOP2,\n  ML_NOOP3,\n  ML_NOOP4,\n  ML_PRODUCT,\n  ML_SAME,\n  ML_SOME,\n  ML_START,\n  ML_STOP,\n  ML_SUM,\n  ML_XNOR,\n  ML_XOR,\n  ml_throw,\n} from './ml';\n\nimport { bounty__debugMeta, bounty_collect, bounty_getCounts } from './bounty';\n\n/**\n * Generate a dsl for given ml\n * Includes a full debugging output stack to investigate a problem more thoroughly\n *\n * @param {Uint8Array} ml\n * @param {Object} problem\n * @param {number[]} [bounty]\n * @param {Object} options See preSolver options\n * @returns {string}\n */\nfunction ml2dsl(ml, problem, bounty, options) {\n  TRACE('\\n## ml2dsl');\n\n  const DEBUG = Boolean(options.debugDsl); // Add debugging help in comments (domains, related constraints, occurrences, etc)\n  const HASH_NAMES = Boolean(options.hashNames); // Replace all var varNames with $index$ with index in base36\n  const INDEX_NAMES = Boolean(options.indexNames); // Replace all var varNames with _index_ (ignored if HASH_NAMES is true)\n  const ADD_GROUPED_CONSTRAINTS = Boolean(options.groupedConstraints); // Only used when debugging\n\n  const {\n    varNames,\n    domains,\n    valdist,\n    getDomain,\n    getAlias,\n    solveStack,\n    targeted,\n  } = problem;\n\n  let pc = 0;\n  let dsl = '';\n  const LEN = ml.length;\n\n  function toName(index) {\n    if (HASH_NAMES) return '$' + index.toString(36) + '$';\n    if (INDEX_NAMES) return '_' + index + '_';\n    return varNames[index];\n  }\n\n  function valueOrName(a, vA) {\n    if (vA >= 0) return vA;\n    return toName(a);\n  }\n\n  function domainstr(A, vA) {\n    if (vA >= 0) return 'lit(' + vA + ')';\n    return domain__debug(A);\n  }\n\n  function counts(index) {\n    const c = bounty_getCounts(bounty, index);\n    if (c === undefined) return '-';\n    return c;\n  }\n\n  const allParts = [];\n  const partsPerVar = [];\n  const varOps = [];\n  let constraintCount = 0;\n  m2d_innerLoop();\n\n  if (DEBUG) {\n    const varDecls = [];\n    let varsLeft = 0;\n    let aliases = 0;\n    let solved = 0;\n    let unsolved = 0;\n    // First generate var decls for unsolved, unaliased vars\n    domains.forEach((domain, index) => {\n      let str = '';\n      if (domain === false || (bounty && !counts(index))) {\n        // Either solved, alias, or leaf. leafs still needs to be updated after the rest solves.\n        domain = getDomain(index);\n        if (domain_getValue(domain) >= 0) {\n          ++solved;\n        } else {\n          ++aliases;\n        }\n      } else {\n        ++varsLeft;\n        ASSERT(\n          domain === getDomain(index),\n          'if not aliased then it should return this',\n          index,\n          domain\n        );\n        ASSERT(\n          domain_getValue(domain) < 0,\n          'solved vars should be aliased to their constant'\n        );\n        ++unsolved;\n        str = ': ' + toName(index) + ' [' + domain_toArr(domain) + ']';\n\n        const vardist = valdist[index];\n        if (vardist) {\n          switch (vardist.valtype) {\n            case 'max':\n            case 'mid':\n            case 'min':\n            case 'naive':\n              str += ' @' + vardist.valtype;\n              break;\n            case 'list':\n              str += ' @' + vardist.valtype;\n              str += ' prio(' + vardist.list + ')';\n              break;\n            case 'markov':\n              str += ' # skipping markov dist (no longer supported)';\n              break;\n            case 'minMaxCycle':\n            case 'splitMax':\n            case 'splitMin':\n            default:\n              THROW(\n                'unknown var dist [' +\n                  vardist.valtype +\n                  '] ' +\n                  JSON.stringify(vardist)\n              );\n          }\n        }\n      }\n\n      varDecls[index] = str;\n    });\n\n    const varDeclsString = domains\n      .map((_, varIndex) => {\n        // ignore constants, aliases, and leafs\n        if (domains[varIndex] === false) return '';\n        const cnts = counts(varIndex);\n        if (!cnts) return '';\n\n        const decl = varDecls[varIndex];\n        ASSERT(\n          varOps[varIndex],\n          'anything that has counts should have varOps of those constraints',\n          'var index:',\n          varIndex,\n          'counts:',\n          cnts,\n          ', varops:',\n          varOps[varIndex],\n          ', decls:',\n          decl,\n          ', name:',\n          varNames[varIndex],\n          ', ppv:',\n          partsPerVar[varIndex],\n          '->',\n          partsPerVar[varIndex] &&\n            partsPerVar[varIndex].map(partIndex => allParts[partIndex])\n        );\n        ASSERT(\n          decl,\n          'anything that has counts should have that many constraints',\n          'var index:',\n          varIndex,\n          'counts:',\n          cnts,\n          ', varops:',\n          varOps[varIndex],\n          ', decls:',\n          decl,\n          ', name:',\n          varNames[varIndex],\n          ', ppv:',\n          partsPerVar[varIndex]\n        );\n\n        const ops = varOps[varIndex]\n          .split(/ /g)\n          .sort()\n          .join(' ');\n\n        return (\n          decl +\n          ' # T:' +\n          targeted[varIndex] +\n          ' ' +\n          ' # ocounts: ' +\n          cnts +\n          (HASH_NAMES || !INDEX_NAMES ? '  # index = ' + varIndex : '') +\n          '  # ops (' +\n          (ops.replace(/[^ ]/g, '').length + 1) +\n          '): ' +\n          ops +\n          ' $ meta: ' +\n          bounty__debugMeta(bounty, varIndex) +\n          (ADD_GROUPED_CONSTRAINTS && partsPerVar[varIndex]\n            ? '\\n ## ' +\n              partsPerVar[varIndex]\n                .map(partIndex => allParts[partIndex])\n                .join(' ## ')\n            : '')\n        );\n      })\n      .filter(s => Boolean(s))\n      .join('\\n');\n\n    dsl = `\n# Constraints: ${constraintCount} x\n# Vars: ${domains.length} x\n#   Aliases: ${aliases} x\n#   Domained: ${varsLeft} x\n#    - Solved: ${solved} x\n#    - Unsolved: ${unsolved} x\n#    - Solve stack: ${solveStack.length} x (or ${solveStack.length -\n      aliases} x without aliases)\n`;\n    getTerm().log(dsl);\n\n    dsl += `\n# Var decls:\n${varDeclsString}\n\n`;\n  } else {\n    dsl += '# vars (' + domains.length + 'x total):\\n';\n    dsl += domains\n      .map((d, i) => [d, i])\n      .filter(a => a[0] !== false)\n      .filter(a => !bounty || counts(a[1]) > 0)\n      .map(a => ': ' + toName(a[1]) + ' [' + domain_toArr(a[0]) + ']')\n      .join('\\n');\n    dsl += '\\n\\n';\n  }\n\n  dsl += '\\n# Constraints (' + allParts.length + 'x):\\n' + allParts.join('');\n\n  dsl += String('\\n# Meta:\\n' + m2d_getTargetsDirective());\n\n  return dsl;\n\n  // ###########################################\n\n  function m2d_dec16() {\n    ASSERT(pc < LEN - 1, 'OOB');\n    TRACE(\n      ' . dec16 decoding',\n      ml[pc] << 8,\n      'from',\n      pc,\n      'and',\n      ml[pc + 1],\n      'from',\n      pc + 1,\n      '=>',\n      (ml[pc] << 8) | ml[pc + 1]\n    );\n    const s = (ml[pc++] << 8) | ml[pc++];\n    return s;\n  }\n\n  function m2d_dec32() {\n    ASSERT(pc < LEN - 1, 'OOB');\n    TRACE(\n      ' . dec32 decoding',\n      ml[pc],\n      ml[pc + 1],\n      ml[pc + 2],\n      ml[pc + 3],\n      'from',\n      pc,\n      '=>',\n      (ml[pc] << 8) | ml[pc + 1]\n    );\n    return (ml[pc++] << 24) | (ml[pc++] << 16) | (ml[pc++] << 8) | ml[pc++];\n  }\n\n  function m2d_decA(op, skipIfConstant) {\n    ASSERT(typeof op === 'string' && op, 'op should be string');\n\n    const a = getAlias(m2d_dec16());\n    const A = getDomain(a);\n    const vA = domain_getValue(A);\n    if (vA >= 0 && skipIfConstant) return false;\n\n    if (DEBUG) {\n      if (vA < 0) {\n        if (!partsPerVar[a]) partsPerVar[a] = [];\n        partsPerVar[a].push(allParts.length);\n        varOps[a] = (varOps[a] === undefined ? '' : varOps[a] + ' ') + op;\n      }\n\n      let s = valueOrName(a, vA);\n      s += ' '.repeat(Math.max(45 - s.length, 3));\n      s += '# ' + domainstr(A, vA);\n      s += ' '.repeat(Math.max(110 - s.length, 3));\n      s += '# args: ' + a;\n      s += ' '.repeat(Math.max(150 - s.length, 3));\n      if (bounty) s += '# counts: ' + counts(a) + ' ';\n      s += ' \\n';\n\n      return s;\n    }\n\n    return valueOrName(a, vA);\n  }\n\n  function _m2d_decAb(op, a, b) {\n    const A = getDomain(a);\n    const vA = domain_getValue(A);\n\n    const B = getDomain(b);\n    const vB = domain_getValue(B);\n\n    return __m2d_decAb(op, a, A, vA, b, B, vB);\n  }\n\n  function __m2d_decAb(op, a, A, vA, b, B, vB) {\n    if (DEBUG) {\n      if (vA < 0) {\n        // Else is probably dead code; all binary void constraints with a constant get resolved immediately\n        if (!partsPerVar[a]) partsPerVar[a] = [];\n        partsPerVar[a].push(allParts.length);\n        varOps[a] = (varOps[a] === undefined ? '' : varOps[a] + ' ') + op;\n      }\n\n      if (vB < 0) {\n        // Else is probably dead code; all binary void constraints with a constant get resolved immediately\n        if (!partsPerVar[b]) partsPerVar[b] = [];\n        partsPerVar[b].push(allParts.length);\n        varOps[b] = (varOps[b] === undefined ? '' : varOps[b] + ' ') + op;\n      }\n\n      let s = valueOrName(a, vA) + ' ' + op + ' ' + valueOrName(b, vB);\n      s += ' '.repeat(Math.max(45 - s.length, 3));\n      s += '# ' + domainstr(A, vA) + ' ' + op + ' ' + domainstr(B, vB);\n      s += ' '.repeat(Math.max(110 - s.length, 3));\n      s += '# args: ' + a + ', ' + b;\n      s += ' '.repeat(Math.max(150 - s.length, 3));\n      if (bounty)\n        s += '# counts: ' + counts(a) + ' ' + op + ' ' + counts(b) + ' ';\n      s += ' \\n';\n\n      return s;\n    }\n\n    return valueOrName(a, vA) + ' ' + op + ' ' + valueOrName(b, vB) + '\\n';\n  }\n\n  function m2d_decAbc(op) {\n    ASSERT(typeof op === 'string' && op, 'op should be string');\n    const a = getAlias(m2d_dec16());\n    const b = getAlias(m2d_dec16());\n    const c = getAlias(m2d_dec16());\n    return _m2d_decAbc(op, a, b, c);\n  }\n\n  function _m2d_decAbc(op, a, b, c) {\n    const A = getDomain(a);\n    const vA = domain_getValue(A);\n\n    const B = getDomain(b);\n    const vB = domain_getValue(B);\n\n    const C = getDomain(c);\n    const vC = domain_getValue(C);\n\n    return __m2d_decAbc(op, a, A, vA, b, B, vB, c, C, vC);\n  }\n\n  function __m2d_decAbc(op, a, A, vA, b, B, vB, c, C, vC) {\n    if (DEBUG) {\n      if (vA < 0) {\n        // Else is probably dead; args are ordered and A can only be solved if B is also solved or unordered.\n        if (!partsPerVar[a]) partsPerVar[a] = [];\n        partsPerVar[a].push(allParts.length);\n        varOps[a] = (varOps[a] === undefined ? '' : varOps[a] + ' ') + op;\n      }\n\n      if (vB < 0) {\n        if (!partsPerVar[b]) partsPerVar[b] = [];\n        partsPerVar[b].push(allParts.length);\n        varOps[b] = (varOps[b] === undefined ? '' : varOps[b] + ' ') + op;\n      }\n\n      if (vC < 0) {\n        if (!partsPerVar[c]) partsPerVar[c] = [];\n        partsPerVar[c].push(allParts.length);\n        varOps[c] = (varOps[c] === undefined ? '' : varOps[c] + ' ') + op;\n      }\n\n      let s =\n        valueOrName(c, vC) +\n        ' = ' +\n        valueOrName(a, vA) +\n        ' ' +\n        op +\n        ' ' +\n        valueOrName(b, vB);\n      s += ' '.repeat(Math.max(45 - s.length, 3));\n      s +=\n        '# ' +\n        domainstr(C, vC) +\n        ' = ' +\n        domainstr(A, vA) +\n        ' ' +\n        op +\n        ' ' +\n        domainstr(B, vB);\n      s += ' '.repeat(Math.max(110 - s.length, 3));\n      s += '# indexes: ' + c + ' = ' + a + ' ' + op + ' ' + b;\n      s += ' '.repeat(Math.max(150 - s.length, 3));\n      if (bounty)\n        s +=\n          '# counts: ' +\n          counts(c) +\n          ' = ' +\n          counts(a) +\n          ' ' +\n          op +\n          ' ' +\n          counts(b) +\n          ' ';\n      s += '\\n';\n\n      return s;\n    }\n\n    return (\n      valueOrName(c, vC) +\n      ' = ' +\n      valueOrName(a, vA) +\n      ' ' +\n      op +\n      ' ' +\n      valueOrName(b, vB) +\n      '\\n'\n    );\n  }\n\n  function m2d_listVoid(callName) {\n    ASSERT(\n      typeof callName === 'string' && callName,\n      'callName should be string'\n    );\n\n    const argCount = m2d_dec16();\n\n    if (argCount === 2) {\n      if (callName === 'all')\n        return _m2d_decAb('&', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'diff')\n        return _m2d_decAb('!=', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'imp')\n        return _m2d_decAb('->', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'lt')\n        return _m2d_decAb('<', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'lte')\n        return _m2d_decAb('<=', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'nall')\n        return _m2d_decAb('!&', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'nimp')\n        return _m2d_decAb('!->', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      // If (callName === 'none') return _m2d_decAb('!|', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'same')\n        return _m2d_decAb('==', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'some')\n        return _m2d_decAb('|', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'xnor')\n        return _m2d_decAb('!^', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'xor')\n        return _m2d_decAb('^', getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n    }\n\n    let indexes = '';\n    let counters = '';\n    let argNames = '';\n    let debugs = '';\n    // Let prevIndex = -1;\n    for (let i = 0; i < argCount; ++i) {\n      const d = getAlias(m2d_dec16());\n      const D = getDomain(d);\n      const vD = domain_getValue(D);\n\n      argNames += valueOrName(d, vD) + ' ';\n      if (DEBUG) {\n        if (vD < 0) {\n          if (!partsPerVar[d]) partsPerVar[d] = [];\n          partsPerVar[d].push(allParts.length);\n          varOps[d] =\n            (varOps[d] === undefined ? '' : varOps[d] + ' ') + callName;\n        }\n\n        indexes += d + ' ';\n        if (bounty) counters += counts(d) + ' ';\n        debugs += domainstr(D, vD) + ' ';\n      }\n    }\n\n    if (DEBUG) {\n      let s = callName + '( ' + argNames + ')';\n      s += ' '.repeat(Math.max(45 - s.length, 3));\n      s += '# ' + callName + '( ' + debugs + ') ';\n      s += ' '.repeat(Math.max(110 - s.length, 3));\n      s += '# indexes: ' + indexes;\n      s += ' '.repeat(Math.max(150 - s.length, 3));\n      if (bounty) s += '# counts: ' + callName + '( ' + counters + ')';\n      s += '\\n';\n\n      return s;\n    }\n\n    return callName + '( ' + argNames + ')\\n';\n  }\n\n  function m2d_listResult(callName) {\n    ASSERT(\n      typeof callName === 'string' && callName,\n      'callName should be string'\n    );\n\n    const argCount = m2d_dec16();\n    return m2d_listResultBody(callName, argCount);\n  }\n\n  function m2d_listResultBody(callName, argCount) {\n    ASSERT(\n      typeof callName === 'string' && callName,\n      'callName should be string'\n    );\n\n    if (argCount === 2) {\n      // If (callName === 'all?') return _m2d_decAbc('&?', getAlias(m2d_dec16()), getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'diff?')\n        return _m2d_decAbc(\n          '!=?',\n          getAlias(m2d_dec16()),\n          getAlias(m2d_dec16()),\n          getAlias(m2d_dec16())\n        );\n      // If (callName === 'nall?') return _m2d_decAbc('!&?', getAlias(m2d_dec16()), getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      // if (callName === 'none?') return _m2d_decAbc('!|?', getAlias(m2d_dec16()), getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'same?')\n        return _m2d_decAbc(\n          '==?',\n          getAlias(m2d_dec16()),\n          getAlias(m2d_dec16()),\n          getAlias(m2d_dec16())\n        );\n      // If (callName === 'some?') return _m2d_decAbc('|?', getAlias(m2d_dec16()), getAlias(m2d_dec16()), getAlias(m2d_dec16()));\n      if (callName === 'sum')\n        return _m2d_decAbc(\n          '+',\n          getAlias(m2d_dec16()),\n          getAlias(m2d_dec16()),\n          getAlias(m2d_dec16())\n        );\n      if (callName === 'product')\n        return _m2d_decAbc(\n          '*',\n          getAlias(m2d_dec16()),\n          getAlias(m2d_dec16()),\n          getAlias(m2d_dec16())\n        );\n    }\n\n    let indexes = '';\n    let counters = '';\n    let argNames = '';\n    let debugs = '';\n    // Let prevIndex = -1;\n    for (let i = 0; i < argCount; ++i) {\n      const d = getAlias(m2d_dec16());\n      const D = getDomain(d);\n      const vD = domain_getValue(D);\n\n      argNames += valueOrName(d, vD) + ' ';\n      if (DEBUG) {\n        if (vD < 0) {\n          if (!partsPerVar[d]) partsPerVar[d] = [];\n          partsPerVar[d].push(allParts.length);\n          varOps[d] =\n            (varOps[d] === undefined ? '' : varOps[d] + ' ') + callName;\n        }\n\n        indexes += d + ' ';\n        if (bounty) counters += counts(d) + ' ';\n        debugs += domainstr(D, vD) + ' ';\n      }\n    }\n\n    const r = getAlias(m2d_dec16());\n    const R = getDomain(r);\n    const vR = domain_getValue(R);\n\n    if (DEBUG) {\n      if (vR < 0) {\n        if (!partsPerVar[r]) partsPerVar[r] = [];\n        partsPerVar[r].push(allParts.length);\n        varOps[r] = (varOps[r] === undefined ? '' : varOps[r] + ' ') + callName;\n      }\n\n      let s = valueOrName(r, vR) + ' = ' + callName + '( ' + argNames + ')';\n      s += ' '.repeat(Math.max(45 - s.length, 3));\n      s += '# ' + domainstr(R, vR) + ' = ' + callName + '( ' + debugs + ') ';\n      s += ' '.repeat(Math.max(110 - s.length, 3));\n      s += '# indexes: ' + r + ' = ' + indexes;\n      s += ' '.repeat(Math.max(150 - s.length, 3));\n      if (bounty)\n        s +=\n          '# counts: ' + counts(r) + ' = ' + callName + '( ' + counters + ')';\n      s += '\\n';\n\n      return s;\n    }\n\n    return valueOrName(r, vR) + ' = ' + callName + '( ' + argNames + ')\\n';\n  }\n\n  function m2d_innerLoop() {\n    while (pc < LEN) {\n      const pcStart = pc;\n\n      const op = ml[pc++];\n      let part = '';\n\n      switch (op) {\n        case ML_START:\n        case ML_STOP:\n        case ML_NOBOOL:\n        case ML_NOLEAF:\n        case ML_NOOP:\n        case ML_NOOP2:\n        case ML_NOOP3:\n        case ML_NOOP4:\n        case ML_JMP:\n        case ML_JMP32:\n          break;\n        default:\n          ++constraintCount;\n      }\n\n      switch (op) {\n        case ML_START:\n          if (pc !== 1) {\n            // Pc is already incremented...\n            return THROW(' ! ml2dsl compiler problem @', pcStart);\n          }\n\n          break;\n\n        case ML_STOP:\n          TRACE(' ! good end @', pcStart);\n          return;\n\n        case ML_JMP:\n          const delta = m2d_dec16();\n          TRACE(' ! jmp', delta);\n          if (delta <= 0) THROW('Must jump some bytes');\n          pc += delta;\n          break;\n        case ML_JMP32:\n          const delta32 = m2d_dec32();\n          TRACE(' ! jmp32', delta32);\n          if (delta32 <= 0) THROW('Must jump some bytes');\n          pc += delta32;\n          break;\n\n        case ML_LT:\n          TRACE(' ! lt');\n          part = m2d_listVoid('lt');\n          break;\n        case ML_LTE:\n          TRACE(' ! lte');\n          part = m2d_listVoid('lte');\n          break;\n        case ML_XOR:\n          TRACE(' ! xor');\n          part = m2d_listVoid('xor');\n          break;\n        case ML_IMP:\n          TRACE(' ! imp vv');\n          part = m2d_listVoid('imp');\n          break;\n        case ML_NIMP:\n          TRACE(' ! nimp vv');\n          part = m2d_listVoid('nimp');\n          break;\n\n        case ML_ALL:\n          TRACE(' ! all');\n          part = m2d_listVoid('all');\n          break;\n        case ML_DIFF:\n          TRACE(' ! diff');\n          part = m2d_listVoid('diff');\n          break;\n        case ML_NALL:\n          TRACE(' ! nall');\n          part = m2d_listVoid('nall');\n          break;\n        case ML_NONE:\n          TRACE(' ! none');\n          part = m2d_listVoid('none');\n          break;\n        case ML_SAME:\n          TRACE(' ! same');\n          part = m2d_listVoid('same');\n          break;\n        case ML_SOME:\n          TRACE(' ! some');\n          part = m2d_listVoid('some');\n          break;\n        case ML_XNOR:\n          TRACE(' ! xnor');\n          part = m2d_listVoid('xnor');\n          break;\n\n        case ML_ISLT:\n          TRACE(' ! islt vvv');\n          part = m2d_decAbc('<?');\n          break;\n        case ML_ISLTE:\n          TRACE(' ! islte vvv');\n          part = m2d_decAbc('<=?');\n          break;\n\n        case ML_ISALL:\n          TRACE(' ! isall');\n          part = m2d_listResult('all?');\n          break;\n        case ML_ISDIFF:\n          TRACE(' ! isdiff');\n          part = m2d_listResult('diff?');\n          break;\n        case ML_ISNALL:\n          TRACE(' ! isnall');\n          part = m2d_listResult('nall?');\n          break;\n        case ML_ISNONE:\n          TRACE(' ! isnone');\n          part = m2d_listResult('none?');\n          break;\n        case ML_ISSAME:\n          TRACE(' ! issame');\n          part = m2d_listResult('same?');\n          break;\n        case ML_ISSOME:\n          TRACE(' ! issome');\n          part = m2d_listResult('some?');\n          break;\n\n        case ML_MINUS:\n          TRACE(' ! minus');\n          part = m2d_decAbc('-');\n          break;\n        case ML_DIV:\n          TRACE(' ! div');\n          part = m2d_decAbc('/');\n          break;\n\n        case ML_SUM:\n          TRACE(' ! sum');\n          part = m2d_listResult('sum');\n          break;\n        case ML_PRODUCT:\n          TRACE(' ! product');\n          part = m2d_listResult('product');\n          break;\n\n        case ML_NOBOOL:\n          TRACE(' ! nobool');\n          // Fdq will understand but ignore this. skip for constants.\n          const Bpart = m2d_decA('<debug>', true);\n          if (Bpart !== false) part = '@custom nobool ' + Bpart + '\\n';\n          break;\n        case ML_NOLEAF:\n          TRACE(' ! noleaf');\n          // Fdq will understand but ignore this. skip for constants.\n          const Apart = m2d_decA('<debug>', true);\n          if (Apart !== false) {\n            part = '@custom noleaf ' + Apart + '\\n';\n          }\n\n          break;\n        case ML_NOOP:\n          TRACE(' ! noop');\n          pc = pcStart + 1;\n          break;\n        case ML_NOOP2:\n          TRACE(' ! noop 2');\n          pc = pcStart + 2;\n          break;\n        case ML_NOOP3:\n          TRACE(' ! noop 3');\n          pc = pcStart + 3;\n          break;\n        case ML_NOOP4:\n          TRACE(' ! noop 4');\n          pc = pcStart + 4;\n          break;\n\n        default:\n          ml_throw('(m2d) unknown op', pc, ' at', pc);\n      }\n\n      allParts.push(part);\n    }\n  }\n\n  function m2d_getTargetsDirective() {\n    const targets = [];\n    const { targeted } = problem;\n    const len = domains.length;\n    let total = 0;\n    let nontargets = 0;\n    for (let i = 0; i < len; ++i) {\n      if (domains[i] === false) continue;\n      if (!counts(i)) continue;\n\n      ++total;\n      if (!targeted[i]) {\n        ++nontargets; // We only care about this state for vars that will appear in the dsl.\n        continue;\n      }\n\n      targets.push(toName(i));\n    }\n\n    // TODO\n    // what if there are no targets left? we could set internal\n    // vars to anything but that could still affect targeted\n    // vars through the solve stack... or perhaps they are irrelevant?\n    // does this mean any valuation will work to resolve the vars?\n\n    return (\n      '@custom targets' +\n      (nontargets && nontargets.length\n        ? '( ' + targets.join(' ') + ' )'\n        : ' all') +\n      ' # ' +\n      (total - nontargets) +\n      ' / ' +\n      total +\n      '\\n'\n    );\n  }\n}\n\nfunction m2d__debug(problem, notTrace) {\n  TRACE('\\nm2d__debug, temporarily disabling TRACE while generating dsl');\n  const was = isTracing();\n  if (!was && !notTrace) return ''; // TRACE is disabled; dont generate anything as it wont be seen (reduce test runtime)\n  if (process.env.NODE_ENV !== 'production') setTracing(false);\n  const dsl = ml2dsl(problem.ml, problem, bounty_collect(problem.ml, problem), {\n    debugDsl: false,\n    hashNames: false,\n  });\n  if (process.env.NODE_ENV !== 'production') setTracing(was);\n\n  return (\n    '\\n## current remaining problem as dsl:\\n' +\n    dsl +\n    '## end of current remaining problem\\n'\n  );\n}\n\nexport { ml2dsl, m2d__debug };\n","// Note: you can use the tool at https://pvdz.github.io/logic-table-filter/ to test some of these tricks\n// enter the names of the vars, the formulae (in proper JS), and the var considered a leaf and you can\n// quickly see whether the rewrite is valid or not.\n\nimport {\n  ASSERT,\n  TRACE,\n  TRACE_MORPH,\n  EMPTY,\n\n  domain__debug,\n  domain_arrToSmallest,\n  domain_containsValue,\n  domain_createEmpty,\n  domain_createRange,\n  domain_createValue,\n  domain_getValue,\n  domain_hasNoZero,\n  domain_hasZero,\n  domain_intersection,\n  domain_intersectionValue,\n  domain_isBool,\n  domain_isBooly,\n  domain_isBoolyPair,\n  domain_isSolved,\n  domain_isZero,\n  domain_max,\n  domain_min,\n  domain_plus,\n  domain_removeGte,\n  domain_removeGtUnsafe,\n  domain_removeLte,\n  domain_removeLtUnsafe,\n  domain_removeValue,\n  domain_resolveAsBooly,\n  domain_size,\n  getTerm,\n  THROW,\n} from 'fdlib';\n\nimport {\n  ML_ALL,\n  ML_NOBOOL,\n  ML_NOLEAF,\n  ML_DIFF,\n  ML_DIV,\n  ML_IMP,\n  ML_ISALL,\n  ML_ISDIFF,\n  ML_ISLT,\n  ML_ISLTE,\n  ML_ISNALL,\n  ML_ISNONE,\n  ML_ISSAME,\n  ML_ISSOME,\n  ML_JMP,\n  ML_JMP32,\n  ML_LT,\n  ML_LTE,\n  ML_MINUS,\n  ML_NALL,\n  ML_NIMP,\n  ML_NONE,\n  ML_NOOP,\n  ML_NOOP2,\n  ML_NOOP3,\n  ML_NOOP4,\n  ML_PRODUCT,\n  ML_SAME,\n  ML_SOME,\n  ML_START,\n  ML_STOP,\n  ML_SUM,\n  ML_XNOR,\n  ML_XOR,\n  SIZEOF_V,\n  SIZEOF_W,\n  SIZEOF_VVV,\n  SIZEOF_C,\n  SIZEOF_C_2,\n  SIZEOF_CR_2,\n  OFFSET_C_A,\n  OFFSET_C_B,\n  OFFSET_C_C,\n  OFFSET_C_R,\n  ml__debug,\n  ml__opName,\n  ml_compileJumpAndConsolidate,\n  ml_compileJumpSafe,\n  ml_dec8,\n  ml_dec16,\n  ml_dec32,\n  ml_enc8,\n  ml_enc16,\n  ml_eliminate,\n  ml_getOpSizeSlow,\n  ml_getRecycleOffsets,\n  ml_heapSort16bitInline,\n  ml_recycles,\n  ml_throw,\n  ml_validateSkeleton,\n  ml_any2c,\n  ml_cx2cx,\n  ml_c2c2,\n  ml_cr2c,\n  ml_cr2c2,\n  ml_cr2cr2,\n} from './ml';\nimport {\n  BOUNTY_FLAG_NOT_BOOLY,\n  // BOUNTY_FLAG_OTHER,\n  BOUNTY_MAX_OFFSETS_TO_TRACK,\n  // BOUNTY_NO_FLAGS,\n  BOUNTY_FLAG_IMP_LHS,\n  BOUNTY_FLAG_IMP_RHS,\n  BOUNTY_FLAG_ISALL_ARG,\n  BOUNTY_FLAG_ISALL_RESULT,\n  BOUNTY_FLAG_ISSOME_RESULT,\n  BOUNTY_FLAG_ISSAME_ARG,\n  BOUNTY_FLAG_ISSAME_RESULT,\n  BOUNTY_FLAG_ISLTE_ARG,\n  BOUNTY_FLAG_LTE_LHS,\n  BOUNTY_FLAG_LTE_RHS,\n  BOUNTY_FLAG_NALL,\n  BOUNTY_FLAG_DIFF,\n  BOUNTY_FLAG_SOME,\n  BOUNTY_FLAG_SUM_RESULT,\n  BOUNTY_FLAG_XOR,\n  bounty__debug,\n  bounty__debugMeta,\n  bounty_collect,\n  bounty_getCounts,\n  bounty_getMeta,\n  bounty_getOffset,\n  bounty_markVar,\n} from './bounty';\n\nimport { m2d__debug } from './ml2dsl';\n\nconst ML_BOOLY_NO = 0;\nconst ML_BOOLY_YES = 1;\nconst ML_BOOLY_MAYBE = 2;\n\nfunction cutter(ml, problem, once) {\n  TRACE('\\n ## cutter', ml.length < 50 ? ml.join(' ') : '');\n\n  const term = getTerm();\n\n  const { getDomain, setDomain, addAlias, getAlias, solveStack, leafs, isConstant } = problem;\n\n  let pc = 0;\n\n  let bounty;\n\n  let stacksBefore;\n  let emptyDomain = false;\n  let changes = 0;\n  let loops = 0;\n  let requestAnotherCycle = false; // When true this will force another cycle so the minimizer runs again\n  do {\n    term.time('-> cut_loop ' + loops);\n    TRACE(' # start cutter outer loop', loops);\n    bounty = bounty_collect(ml, problem, bounty);\n\n    TRACE('\\n#### Problem state between bounty and cutter: ###');\n    TRACE(ml__debug(ml, 0, 20, problem));\n    TRACE(m2d__debug(problem));\n\n    stacksBefore = solveStack.length;\n    changes = 0;\n    cutLoop();\n    term.timeEnd('-> cut_loop ' + loops);\n    term.log(\n      '   - end cutter outer loop',\n      loops,\n      ', removed:',\n      solveStack.length - stacksBefore,\n      ' vars, total changes:',\n      changes,\n      ', emptyDomain =',\n      emptyDomain,\n      'once=',\n      once\n    );\n\n    ++loops;\n  } while (!emptyDomain && changes && !once && !requestAnotherCycle);\n\n  TRACE(\n    '## exit cutter',\n    emptyDomain\n      ? '[there was an empty domain]'\n      : requestAnotherCycle\n      ? '[explicitly requesting another cycle]'\n      : loops > 1\n      ? '[it might not be done]'\n      : '[it is done]'\n  );\n  if (emptyDomain) return -1;\n  return loops + (requestAnotherCycle ? 1 : 0);\n\n  function somethingChanged() {\n    ++changes;\n  }\n\n  function readIndex(ml, offset) {\n    ASSERT(ml instanceof Uint8Array, 'ml should be a buffer');\n    ASSERT(\n      typeof offset === 'number' && offset >= 0 && offset <= ml.length,\n      'expecting valid offset'\n    );\n    ASSERT(arguments.length === 2, 'only two args');\n    return getAlias(ml_dec16(ml, offset));\n  }\n\n  function getMeta(bounty, index, keepBoolyFlags, _debug) {\n    ASSERT(\n      typeof index === 'number' && index >= 0 && index <= 0xffff,\n      'expecting valid index'\n    );\n    ASSERT(\n      arguments.length === 2 || arguments.length === 3,\n      'only two or three args'\n    );\n    if (!isConstant(index)) {\n      const meta = bounty_getMeta(bounty, index, _debug);\n      if (!keepBoolyFlags) return scrubBoolyFlag(meta);\n      return meta;\n    }\n\n    return 0;\n  }\n\n  function scrubBoolyFlag(meta) {\n    return (meta | BOUNTY_FLAG_NOT_BOOLY) ^ BOUNTY_FLAG_NOT_BOOLY;\n  }\n\n  function hasFlags(meta, flags) {\n    return (meta & flags) === flags;\n  }\n\n  function getCounts(bounty, index) {\n    ASSERT(\n      typeof index === 'number' && index >= 0 && index <= 0xffff,\n      'expecting valid index'\n    );\n    ASSERT(arguments.length === 2, 'no more than two args');\n    if (!isConstant(index)) return bounty_getCounts(bounty, index);\n    return 0;\n  }\n\n  // ##############\n\n  function cutLoop() {\n    TRACE('\\n#### - inner cutLoop');\n    pc = 0;\n    while (pc < ml.length && !emptyDomain && !requestAnotherCycle) {\n      const pcStart = pc;\n      const op = ml[pc];\n      TRACE(' -- CU pc=' + pc, ', op=', op, ml__opName(op));\n      TRACE(' -> op: ' + ml__debug(ml, pc, 1, problem, true));\n      ASSERT(ml_validateSkeleton(ml, 'cutLoop'));\n      switch (op) {\n        case ML_ALL:\n          return ml_throw(ml, pc, 'all() should be solved and eliminated');\n        case ML_DIFF:\n          cut_diff(ml, pc);\n          break;\n        case ML_DIV:\n          pc += SIZEOF_VVV;\n          break;\n        case ML_IMP:\n          cut_imp(ml, pc);\n          break;\n        case ML_ISALL:\n          cut_isall(ml, pc);\n          break;\n        case ML_ISDIFF:\n          cut_isdiff(ml, pc);\n          break;\n        case ML_ISLT:\n          cut_islt(ml, pc);\n          break;\n        case ML_ISLTE:\n          cut_islte(ml, pc);\n          break;\n        case ML_ISNALL:\n          cut_isnall(ml, pc);\n          break;\n        case ML_ISSAME:\n          cut_issame(ml, pc);\n          break;\n        case ML_ISSOME:\n          cut_issome(ml, pc);\n          break;\n        case ML_ISNONE:\n          TRACE('(skipped) issome/isnone', pc);\n          const nlen = ml_dec16(ml, pc + 1);\n          pc += SIZEOF_C + nlen * 2 + 2;\n          break;\n        case ML_LT:\n          cut_lt(ml, pc);\n          break;\n        case ML_LTE:\n          cut_lte(ml, pc);\n          break;\n        case ML_MINUS:\n          pc += SIZEOF_VVV;\n          break;\n        case ML_NALL:\n          cut_nall(ml, pc);\n          break;\n        case ML_NIMP:\n          TRACE('(skipped) nimp', pc);\n          pc += SIZEOF_C_2;\n          break;\n        case ML_NONE:\n          return ml_throw(ml, pc, 'nors should be solved and eliminated');\n        case ML_PRODUCT:\n          TRACE('(skipped) product', pc);\n          const plen = ml_dec16(ml, pc + 1);\n          pc += SIZEOF_C + plen * 2 + 2;\n          break;\n        case ML_SAME:\n          return ml_throw(ml, pc, 'eqs should be aliased and eliminated');\n        case ML_SOME:\n          cut_some(ml, pc);\n          break;\n        case ML_SUM:\n          cut_sum(ml, pc);\n          break;\n        case ML_XOR:\n          cut_xor(ml, pc);\n          break;\n        case ML_XNOR:\n          cut_xnor(ml, pc);\n          break;\n\n        case ML_START:\n          if (pc !== 0)\n            return ml_throw(ml, pc, ' ! compiler problem @', pcStart);\n          ++pc;\n          break;\n        case ML_STOP:\n          return;\n\n        case ML_NOBOOL:\n        case ML_NOLEAF:\n          pc += SIZEOF_V;\n          break;\n\n        case ML_JMP:\n          cut_moveTo(ml, pc, SIZEOF_V + ml_dec16(ml, pc + 1));\n          break;\n        case ML_JMP32:\n          cut_moveTo(ml, pc, SIZEOF_W + ml_dec32(ml, pc + 1));\n          break;\n\n        case ML_NOOP:\n          cut_moveTo(ml, pc, 1);\n          break;\n        case ML_NOOP2:\n          cut_moveTo(ml, pc, 2);\n          break;\n        case ML_NOOP3:\n          cut_moveTo(ml, pc, 3);\n          break;\n        case ML_NOOP4:\n          cut_moveTo(ml, pc, 4);\n          break;\n\n        default:\n          getTerm().error('(cut) unknown op', pc, ' at', pc);\n          ml_throw(ml, pc, '(cut) unknown op', pc);\n      }\n    }\n\n    if (emptyDomain) {\n      TRACE('Ended up with an empty domain');\n      return;\n    }\n\n    if (requestAnotherCycle) {\n      TRACE(\n        'Stopped cutloop prematurely because another minimizer cycle was requested'\n      );\n      return;\n    }\n\n    TRACE('the implicit end; ml desynced');\n    THROW('ML OOB');\n  }\n\n  function cut_diff(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(' ! cut_diff;', argCount, 'args');\n\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const countsA = getCounts(bounty, indexA);\n    if (countsA > 1 && countsA < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      // Search all counts for a second SOME\n      if (desubset_diff(ml, offset, argCount, indexA, countsA)) return;\n    }\n\n    if (argCount !== 2) {\n      TRACE(' - did not have 2 args, bailing for now');\n      pc += SIZEOF_C + argCount * 2;\n      return;\n    }\n\n    // For the remainder, these are NEQ cuts (diff[2])\n\n    const indexB = readIndex(ml, offset + OFFSET_C_B);\n    const countsB = getCounts(bounty, indexB);\n\n    TRACE(\n      ' - diff:',\n      indexA,\n      '!=',\n      indexB,\n      '::',\n      domain__debug(getDomain(indexA, true)),\n      '!=',\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsA || !domain_isSolved(getDomain(indexA, true)),\n      'if it has counts it shouldnt be solved',\n      countsA,\n      indexA,\n      domain__debug(getDomain(indexA, true))\n    );\n    ASSERT(\n      !countsB || !domain_isSolved(getDomain(indexB, true)),\n      'if it has counts it shouldnt be solved',\n      countsB,\n      indexB,\n      domain__debug(getDomain(indexB, true))\n    );\n    TRACE(\n      '  - counts:',\n      countsA,\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexA),\n      bounty__debugMeta(bounty, indexB)\n    );\n\n    if (indexA === indexB) {\n      TRACE(' - index A == B, redirecting to minimizer');\n      requestAnotherCycle = true;\n      return;\n    }\n\n    if (countsA === 1) {\n      return leaf_diff_pair(ml, offset, indexA, indexB, indexA, indexB);\n    }\n\n    if (countsB === 1) {\n      return leaf_diff_pair(ml, offset, indexB, indexA, indexA, indexB);\n    }\n\n    const TRICK_INV_DIFF_FLAGS =\n      BOUNTY_FLAG_LTE_LHS |\n      BOUNTY_FLAG_LTE_RHS |\n      BOUNTY_FLAG_SOME |\n      BOUNTY_FLAG_NALL |\n      BOUNTY_FLAG_IMP_LHS |\n      BOUNTY_FLAG_IMP_RHS;\n\n    if (countsA > 1 && countsA <= BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      const metaA = getMeta(bounty, indexA);\n\n      // Check if it has any targeted ops, then check if it has no other stuff\n      const hasGoodOps = (metaA & TRICK_INV_DIFF_FLAGS) > 0;\n      const hasBadOps =\n        (metaA | TRICK_INV_DIFF_FLAGS | BOUNTY_FLAG_DIFF) ^\n        (TRICK_INV_DIFF_FLAGS | BOUNTY_FLAG_DIFF);\n      TRACE('  - has good:', hasGoodOps, ', hasBad:', hasBadOps);\n      // TODO: why are we checking diff here? shouldnt that have been done above? and why not checking that below?\n      if (hasFlags(metaA, BOUNTY_FLAG_DIFF) && hasGoodOps && !hasBadOps) {\n        if (trick_diff_elimination(offset, indexA, countsA, indexB)) return;\n      }\n\n      if (hasFlags(metaA, BOUNTY_FLAG_DIFF | BOUNTY_FLAG_XOR)) {\n        if (trick_diff_xor(ml, offset, indexA, countsA, indexB)) return;\n      }\n\n      if (trick_diff_alias(indexA, indexB, countsA)) return;\n    }\n\n    if (countsB > 1 && countsB <= BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      const metaB = getMeta(bounty, indexB);\n\n      // First remove the booly flag, then check if it has any targeted ops, then check if it has no other stuff\n      const hasGoodOps = (metaB & TRICK_INV_DIFF_FLAGS) > 0;\n      const hasBadOps =\n        (metaB | TRICK_INV_DIFF_FLAGS | BOUNTY_FLAG_DIFF) ^\n        (TRICK_INV_DIFF_FLAGS | BOUNTY_FLAG_DIFF);\n      TRACE('  - has good:', hasGoodOps, ', hasBad:', hasBadOps);\n      if (hasGoodOps && !hasBadOps) {\n        if (trick_diff_elimination(offset, indexB, countsB, indexA)) return;\n      }\n\n      if (hasFlags(metaB, BOUNTY_FLAG_DIFF | BOUNTY_FLAG_XOR)) {\n        if (trick_diff_xor(ml, offset, indexB, countsB, indexA)) return;\n      }\n\n      if (trick_diff_alias(indexB, indexA, countsB)) return;\n\n      const A = getDomain(indexA, true);\n      const B = getDomain(indexB, true);\n      if (domain_isBoolyPair(A) && A === B) {\n        TRACE(\n          ' - A and B are booly pair and equal so turn this DIFF into a XOR'\n        );\n        TRACE_MORPH('A:[00xx] != B:[00xx]', 'A ^ B');\n        ml_enc8(ml, offset, ML_XOR);\n        bounty_markVar(bounty, indexA);\n        bounty_markVar(bounty, indexB);\n        somethingChanged();\n        return;\n      }\n    }\n\n    TRACE(' - cut_diff changed nothing');\n    pc += SIZEOF_C_2;\n  }\n\n  function cut_imp(ml, offset) {\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const indexB = readIndex(ml, offset + OFFSET_C_B);\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n\n    const countsA = getCounts(bounty, indexA);\n    const countsB = getCounts(bounty, indexB);\n\n    TRACE(\n      ' ! cut_imp;',\n      indexA,\n      '->',\n      indexB,\n      ', ',\n      domain__debug(A),\n      '->',\n      domain__debug(B)\n    );\n    TRACE(\n      '  - counts:',\n      countsA,\n      '->',\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexA),\n      '->',\n      bounty__debugMeta(bounty, indexB)\n    );\n\n    if (indexA === indexB) {\n      TRACE(' - index A == B, redirecting to minimizer');\n      requestAnotherCycle = true;\n      return;\n    }\n\n    if (!domain_isBooly(A) || domain_hasNoZero(B)) {\n      TRACE(' - this imp is already solved, bouncing back to minimizer');\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    if (countsA === 1) {\n      return leaf_imp(ml, offset, indexA, indexB, true);\n    }\n\n    if (countsB === 1) {\n      return leaf_imp(ml, offset, indexA, indexB, false);\n    }\n\n    if (countsA > 0) {\n      const metaA = getMeta(bounty, indexA);\n      ASSERT(metaA & BOUNTY_FLAG_IMP_LHS, 'should be');\n\n      if (metaA === BOUNTY_FLAG_IMP_LHS) {\n        if (trick_only_implhs_leaf(ml, indexA, countsA)) return;\n      }\n\n      if (\n        metaA === BOUNTY_FLAG_NALL ||\n        metaA === (BOUNTY_FLAG_NALL | BOUNTY_FLAG_IMP_LHS)\n      ) {\n        if (trick_implhs_nall_leaf(ml, indexA, countsA)) return;\n      }\n\n      if (countsA === 2) {\n        if (metaA === (BOUNTY_FLAG_IMP_LHS | BOUNTY_FLAG_SOME)) {\n          if (trick_implhs_some_leaf(ml, offset, indexA, countsA)) return;\n        }\n      }\n\n      if (hasFlags(metaA, BOUNTY_FLAG_ISALL_RESULT)) {\n        // This trick has isall subsume the lte, so no need for R to be leaf\n        if (trick_implhs_isall_2shared(ml, offset, indexA, countsA)) return;\n\n        // This trick requires R to be leaf\n        if (countsA === 2) {\n          if (trick_isall_implhs_1shared(ml, offset, indexA, countsA)) return;\n        }\n      }\n\n      if (countsA >= 3) {\n        if (\n          metaA ===\n          (BOUNTY_FLAG_SOME | BOUNTY_FLAG_NALL | BOUNTY_FLAG_IMP_LHS)\n        ) {\n          if (trick_implhs_nalls_some(indexA, countsA)) return;\n        }\n\n        if (\n          metaA ===\n          (BOUNTY_FLAG_SOME |\n            BOUNTY_FLAG_NALL |\n            BOUNTY_FLAG_IMP_LHS |\n            BOUNTY_FLAG_IMP_RHS)\n        ) {\n          if (trick_impboth_nall_some(indexA, countsA)) return;\n        }\n      }\n    }\n\n    if (domain_isBool(A) && domain_isBool(B)) {\n      if (countsB === 2) {\n        const metaB = getMeta(bounty, indexB, true); // Keep booly flags\n\n        if (metaB === (BOUNTY_FLAG_IMP_RHS | BOUNTY_FLAG_ISALL_RESULT)) {\n          if (trick_imprhs_isall_entry(indexB, offset, countsB, indexA)) return;\n        }\n      }\n    }\n\n    TRACE(' - cut_imp did nothing');\n    pc += SIZEOF_C_2;\n  }\n\n  function cut_isall(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n    const argsOffset = offset + SIZEOF_C;\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n\n    const indexR = readIndex(ml, argsOffset + argCount * 2);\n    const countsR = getCounts(bounty, indexR);\n    TRACE(\n      ' ! cut_isall; R=',\n      indexR,\n      ', counts:',\n      countsR,\n      ', metaR:',\n      bounty__debugMeta(bounty, indexR)\n    );\n    ASSERT(\n      !countsR || !domain_isSolved(getDomain(indexR, true)),\n      'if it has counts it shouldnt be solved',\n      countsR,\n      indexR,\n      domain__debug(getDomain(indexR, true))\n    );\n\n    if (countsR > 0 && countsR < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      if (countsR === 1) {\n        // When R is a leaf, the isall args are not bound by it nor the reifier so they are free\n        return leaf_isall(ml, offset, argCount, indexR);\n      }\n\n      const metaR = getMeta(bounty, indexR);\n\n      if (metaR === (BOUNTY_FLAG_ISALL_RESULT | BOUNTY_FLAG_ISALL_ARG)) {\n        if (leaf_isall_arg_result(ml, indexR, countsR)) return;\n      }\n\n      if (countsR === 2) {\n        if (metaR === (BOUNTY_FLAG_NALL | BOUNTY_FLAG_ISALL_RESULT)) {\n          if (trick_isall_nall_2shared(ml, indexR, offset, countsR)) return;\n        }\n      }\n\n      if (metaR === (BOUNTY_FLAG_NALL | BOUNTY_FLAG_ISALL_RESULT)) {\n        if (trick_isall_nall_1shared(ml, indexR, offset, countsR)) return;\n      }\n    }\n\n    TRACE('   cut_isall changed nothing');\n    pc += opSize;\n  }\n\n  function cut_isdiff(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n    const indexR = readIndex(ml, offset + SIZEOF_C + argCount * 2);\n\n    TRACE(\n      ' ! cut_isdiff; ',\n      indexR,\n      '::',\n      domain__debug(getDomain(indexR, true)),\n      ', args:',\n      argCount\n    );\n\n    if (argCount !== 2) {\n      TRACE(' - argCount=', argCount, ', bailing because it is not 2');\n      pc = offset + SIZEOF_C + argCount * 2 + 2;\n      return;\n    }\n\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const indexB = readIndex(ml, offset + OFFSET_C_B);\n\n    const countsA = getCounts(bounty, indexA);\n    const countsB = getCounts(bounty, indexB);\n    const countsR = getCounts(bounty, indexR);\n\n    TRACE(\n      ' -',\n      indexR,\n      '=',\n      indexA,\n      '!=?',\n      indexB,\n      '::',\n      domain__debug(getDomain(indexR, true)),\n      '=',\n      domain__debug(getDomain(indexA, true)),\n      '!=?',\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsA || !domain_isSolved(getDomain(indexA, true)),\n      'if it has counts it shouldnt be solved',\n      countsA,\n      indexA,\n      domain__debug(getDomain(indexA, true))\n    );\n    ASSERT(\n      !countsB || !domain_isSolved(getDomain(indexB, true)),\n      'if it has counts it shouldnt be solved',\n      countsB,\n      indexB,\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsR || !domain_isSolved(getDomain(indexR, true)),\n      'if it has counts it shouldnt be solved',\n      countsR,\n      indexR,\n      domain__debug(getDomain(indexR, true))\n    );\n    TRACE(\n      '  - counts:',\n      countsR,\n      countsA,\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexR),\n      '=',\n      bounty__debugMeta(bounty, indexA),\n      '!=?',\n      bounty__debugMeta(bounty, indexB)\n    );\n\n    if (countsR === 1) {\n      return leaf_isdiff(ml, offset, indexA, indexB, indexR, indexR);\n    }\n\n    if (countsA === 1) {\n      ASSERT(\n        !domain_isSolved(getDomain(indexA, true)),\n        'A cannot be solved (bounty ignores constants so count would be 0)'\n      );\n      if (canCutIsdiffForArg(indexA, indexB, indexR)) {\n        return leaf_isdiff(ml, offset, indexA, indexB, indexR, indexA);\n      }\n    }\n\n    if (countsB === 1) {\n      // Not covered, kept here just in case the above assertion doesnt hold in prod\n      ASSERT(\n        !domain_isSolved(getDomain(indexB, true)),\n        'B cannot be solved (bounty ignores constants so count would be 0)'\n      );\n      if (canCutIsdiffForArg(indexB, indexA, indexR)) {\n        return leaf_isdiff(ml, offset, indexA, indexB, indexR, indexB);\n      }\n    }\n\n    const R = getDomain(indexR, true);\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n\n    if (domain_isBoolyPair(R)) {\n      if (domain_isBoolyPair(A) && domain_isSolved(B)) {\n        // R:[00yy] = A:[00xx] !=? 0/x\n        if (domain_isZero(B)) {\n          TRACE_MORPH('R = A !=? 0', '!(R ^ A)');\n          ml_cr2c2(ml, offset, 2, ML_XNOR, indexA, indexR);\n          bounty_markVar(bounty, indexA);\n          bounty_markVar(bounty, indexB);\n          bounty_markVar(bounty, indexR);\n          somethingChanged();\n          return;\n        }\n\n        if (domain_max(A) === domain_getValue(B)) {\n          // Must confirm A contains B because it may in some edge cases not\n          TRACE_MORPH('R = A:[00xx] !=? x', 'R ^ A');\n          ml_cr2c2(ml, offset, 2, ML_XOR, indexA, indexR);\n          bounty_markVar(bounty, indexA);\n          bounty_markVar(bounty, indexB);\n          bounty_markVar(bounty, indexR);\n          somethingChanged();\n          return;\n        }\n      }\n\n      if (domain_isSolved(A) && domain_isBoolyPair(B)) {\n        // R:[00yy] = 0/x !=? A:[00xx]\n        if (domain_isZero(A)) {\n          TRACE_MORPH('R = 0 !=? B', '!(R ^ B)');\n          ml_cr2c2(ml, offset, 2, ML_XNOR, indexB, indexR);\n          bounty_markVar(bounty, indexA);\n          bounty_markVar(bounty, indexB);\n          bounty_markVar(bounty, indexR);\n          somethingChanged();\n          return;\n        }\n\n        if (domain_max(B) === domain_getValue(A)) {\n          // Must confirm B contains A because it may in some edge cases not\n          TRACE_MORPH('R = x !=? B:[00xx]', 'R ^ B');\n          ml_cr2c2(ml, offset, 2, ML_XOR, indexB, indexR);\n          bounty_markVar(bounty, indexA);\n          bounty_markVar(bounty, indexB);\n          bounty_markVar(bounty, indexR);\n          somethingChanged();\n          return;\n        }\n      }\n    }\n\n    TRACE(' - cut_isdiff changed nothing');\n    pc = offset + SIZEOF_CR_2;\n  }\n\n  function canCutIsdiffForArg(indexL, indexO, indexR) {\n    TRACE(\n      '   - canCutIsdiffForArg;',\n      indexL,\n      indexO,\n      indexR,\n      '->',\n      domain__debug(getDomain(indexR, true)),\n      '=',\n      domain__debug(getDomain(indexL, true)),\n      '!=?',\n      domain__debug(getDomain(indexO, true))\n    );\n    // An isdiff with 2 args can only be leaf-cut on an arg if the leaf can represent all outcomes\n    // so if C is solved, solve as SAME or DIFF.\n    // otherwise make sure the leaf contains all vars of the other var and at least one var that's not in there\n    // as long as that's impossible we can't cut it without implicitly forcing vars\n\n    // first check whether R is booly-solved, this would mean fewer values to check\n\n    const R = getDomain(indexR, true);\n    if (domain_hasNoZero(R)) {\n      TRACE('    - R=0 and size(L)>2 so cuttable');\n      // L contains at least two values so regardless of the state of O, L can fulfill !=\n      ASSERT(domain_size(L) >= 2, 'see?');\n      return true;\n    }\n\n    // R=1 or R=booly is more involved because we at least\n    // need to know whether L contains all values in O\n\n    const L = getDomain(indexL, true);\n    const O = getDomain(indexO, true);\n    const LO = domain_intersection(L, O); // <-- this tells us that\n    TRACE('    - LO:', domain__debug(LO));\n    if (domain_isZero(R)) {\n      // Only cut if we are certain L can represent eq in any way O solves\n\n      if (!LO) {\n        TRACE('    - R>=1 and A contains no value in B so reject');\n        // No values in L and O match so reject\n        setDomain(indexL, domain_createEmpty(), false, true);\n        return false;\n      }\n\n      if (LO === O) {\n        TRACE('    - R>=1 and A contains all values in B so cuttable');\n        // This means L contains all values in O (and maybe more, dont care)\n        // which means L can uphold the eq for any value of O\n        return true;\n      }\n\n      TRACE(\n        '    - R>=1 and A contains some but not all B so not cuttable, yet'\n      );\n      // There's no guarantee O solves to a value in L so we cant cut safely\n      return true;\n    }\n\n    TRACE(\n      '    - R unresolved, cuttable if L contains all values in O and then some;',\n      LO === O,\n      LO !== L,\n      'so:',\n      LO === O && LO !== L\n    );\n    // We dont know R so L should contain all values in O (LO==O) and at least\n    // one value not in O (LO != O), to consider this a safe cut. otherwise dont.\n    return LO === O && LO !== L;\n  }\n\n  function cut_islt(ml, offset) {\n    const indexA = readIndex(ml, offset + 1);\n    const indexB = readIndex(ml, offset + 3);\n    const indexR = readIndex(ml, offset + 5);\n\n    const countsA = getCounts(bounty, indexA);\n    const countsB = getCounts(bounty, indexB);\n    const countsR = getCounts(bounty, indexR);\n\n    TRACE(\n      ' ! cut_islt; ',\n      indexR,\n      '=',\n      indexA,\n      '<?',\n      indexB,\n      '::',\n      domain__debug(getDomain(indexR, true)),\n      '=',\n      domain__debug(getDomain(indexA, true)),\n      '<?',\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsA || !domain_isSolved(getDomain(indexA, true)),\n      'if it has counts it shouldnt be solved',\n      countsA,\n      indexA,\n      domain__debug(getDomain(indexA, true))\n    );\n    ASSERT(\n      !countsB || !domain_isSolved(getDomain(indexB, true)),\n      'if it has counts it shouldnt be solved',\n      countsB,\n      indexB,\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsR || !domain_isSolved(getDomain(indexR, true)),\n      'if it has counts it shouldnt be solved',\n      countsR,\n      indexR,\n      domain__debug(getDomain(indexR, true))\n    );\n    TRACE(\n      '  - counts:',\n      countsR,\n      countsA,\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexR),\n      '=',\n      bounty__debugMeta(bounty, indexA),\n      '<?',\n      bounty__debugMeta(bounty, indexB)\n    );\n\n    if (countsR === 1) {\n      return leaf_islt(ml, offset, indexA, indexB, indexR, indexR);\n    }\n\n    if (countsA === 1) {\n      if (canCutIsltForArg(indexA, indexB, indexR, indexA, indexB)) {\n        return leaf_islt(ml, offset, indexA, indexB, indexR, indexA);\n      }\n    }\n\n    if (countsB === 1) {\n      if (canCutIsltForArg(indexB, indexA, indexR, indexA, indexB)) {\n        return leaf_islt(ml, offset, indexA, indexB, indexR, indexB);\n      }\n    }\n\n    TRACE(' - cut_islt changed nothing');\n    pc = offset + SIZEOF_VVV;\n  }\n\n  function canCutIsltForArg(indexL, indexO, indexR, indexA, indexB) {\n    TRACE(\n      '   - canCutIsltForArg;',\n      indexL,\n      indexO,\n      indexR,\n      '->',\n      domain__debug(getDomain(indexR, true)),\n      '=',\n      domain__debug(getDomain(indexA, true)),\n      '<?',\n      domain__debug(getDomain(indexB, true))\n    );\n    // An islt can only be leaf-cut on an arg if the leaf can represent all outcomes\n    // so if C is solved, solve as SAME or DIFF.\n    // otherwise make sure the leaf contains all vars of the other var and at least one var that's not in there\n    // as long as that's impossible we can't cut it without implicitly forcing vars\n\n    // keep in mind A and B are ordered and cant be swapped\n\n    // first check whether R is booly-solved, this would mean fewer values to check\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n    const R = getDomain(indexR, true);\n\n    if (domain_hasNoZero(R)) {\n      TRACE('   - R>0');\n      // If L is A, O must have at least one value below min(B). otherwise it must have at least one value > max(A).\n      if (indexL === indexA) return domain_min(A) < domain_min(B);\n      return domain_max(B) > domain_max(A);\n    }\n\n    if (domain_isZero(R)) {\n      TRACE('   - R=0');\n      // If L is A, O must have at least one value >= min(B). otherwise it must have at least one value <= max(A).\n      if (indexL === indexA) return domain_min(A) >= domain_min(B);\n      return domain_max(B) <= domain_max(A);\n    }\n\n    // R unresolved. O must have at least both values to represent R=0 and R>=1\n\n    if (indexL === indexA) {\n      TRACE(\n        '   - R unresolved, L=A',\n        domain_min(A) < domain_min(B),\n        domain_max(A) >= domain_max(B)\n      );\n      // L must contain a value < min(B) and a value >= max(B)\n      return domain_min(A) < domain_min(B) && domain_max(A) >= domain_max(B);\n    }\n\n    TRACE(\n      '   - R unresolved, L=B',\n      domain_max(B),\n      '>',\n      domain_max(A),\n      '->',\n      domain_max(B) > domain_max(A),\n      domain_min(B),\n      '<=',\n      domain_min(A),\n      '->',\n      domain_min(B) <= domain_min(A)\n    );\n    // L is B, L must contain one value above max(A) and one value <= min(A)\n    return domain_max(B) > domain_max(A) && domain_min(B) <= domain_min(A);\n  }\n\n  function cut_islte(ml, offset) {\n    const indexA = readIndex(ml, offset + 1);\n    const indexB = readIndex(ml, offset + 3);\n    const indexR = readIndex(ml, offset + 5);\n\n    const countsA = getCounts(bounty, indexA);\n    const countsB = getCounts(bounty, indexB);\n    const countsR = getCounts(bounty, indexR);\n\n    TRACE(\n      ' ! cut_islte; ',\n      indexR,\n      '=',\n      indexA,\n      '<=?',\n      indexB,\n      '::',\n      domain__debug(getDomain(indexR, true)),\n      '=',\n      domain__debug(getDomain(indexA, true)),\n      '<=?',\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsA || !domain_isSolved(getDomain(indexA, true)),\n      'if it has counts it shouldnt be solved',\n      countsA,\n      indexA,\n      domain__debug(getDomain(indexA, true))\n    );\n    ASSERT(\n      !countsB || !domain_isSolved(getDomain(indexB, true)),\n      'if it has counts it shouldnt be solved',\n      countsB,\n      indexB,\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsR || !domain_isSolved(getDomain(indexR, true)),\n      'if it has counts it shouldnt be solved',\n      countsR,\n      indexR,\n      domain__debug(getDomain(indexR, true))\n    );\n    TRACE(\n      '  - counts:',\n      countsR,\n      countsA,\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexR),\n      '=',\n      bounty__debugMeta(bounty, indexA),\n      '<=?',\n      bounty__debugMeta(bounty, indexB)\n    );\n\n    const R = getDomain(indexR, true);\n    if (!domain_isBooly(R)) {\n      TRACE(\n        ' - R is already booly solved, requesting another minifier sweep, bailing'\n      );\n      requestAnotherCycle = true;\n      return;\n    }\n\n    if (countsR === 1) {\n      return leaf_islte(ml, offset, indexA, indexB, indexR, indexR);\n    }\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n\n    if (countsA === 1) {\n      if (canCutIslteForArg(indexA, indexB, indexA, indexB, A, B)) {\n        return leaf_islte(ml, offset, indexA, indexB, indexR, indexA);\n      }\n    }\n\n    if (countsB === 1) {\n      if (canCutIslteForArg(indexB, indexA, indexA, indexB, A, B)) {\n        return leaf_islte(ml, offset, indexA, indexB, indexR, indexB);\n      }\n    }\n\n    if (countsR > 0 && countsR < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      if (domain_isSolved(A)) {\n        // R = x <=? B\n        const metaR = getMeta(bounty, indexR);\n        if (hasFlags(metaR, BOUNTY_FLAG_IMP_RHS)) {\n          const metaB = getMeta(bounty, indexB);\n          if (hasFlags(metaB, BOUNTY_FLAG_IMP_LHS)) {\n            if (trick_imp_islte_c_v(offset, indexR, indexA, indexB, countsR))\n              return;\n          }\n        }\n      }\n\n      if (domain_isSolved(B)) {\n        // R = A <=? x\n        const metaR = getMeta(bounty, indexR);\n        if (hasFlags(metaR, BOUNTY_FLAG_IMP_RHS)) {\n          const metaA = getMeta(bounty, indexA);\n          if (hasFlags(metaA, BOUNTY_FLAG_IMP_LHS)) {\n            if (trick_imp_islte_v_c(offset, indexR, indexA, indexB, countsR))\n              return;\n          }\n        }\n      }\n    }\n\n    TRACE(' - cut_islte changed nothing');\n    pc = offset + SIZEOF_VVV;\n  }\n\n  function canCutIslteForArg(indexL, indexO, indexA, indexB, A, B) {\n    TRACE(\n      '   - canCutIslteForArg;',\n      indexL,\n      indexO,\n      domain__debug(getDomain(indexA, true)),\n      '<=?',\n      domain__debug(getDomain(indexB, true))\n    );\n    // An islte can only be leaf-cut on an arg if the leaf can represent all outcomes\n    // so if C is solved, solve as SAME or DIFF.\n    // otherwise make sure the leaf contains all vars of the other var and at least one var that's not in there\n    // as long as that's impossible we can't cut it without implicitly forcing vars\n\n    // keep in mind A and B are ordered and cant be swapped\n\n    // R unresolved. O must have at least both values to represent R=0 and R>=1\n\n    if (indexL === indexA) {\n      TRACE(\n        '   - L=A',\n        domain_min(A) <= domain_min(B),\n        domain_max(A) > domain_max(B)\n      );\n      // L must contain a value <= min(B) and a value > max(B)\n      return domain_min(A) <= domain_min(B) && domain_max(A) > domain_max(B);\n    }\n\n    TRACE(\n      '   - L=B',\n      domain_max(B),\n      '>=',\n      domain_max(A),\n      '->',\n      domain_max(B) >= domain_max(A),\n      domain_min(B),\n      '<',\n      domain_min(A),\n      '->',\n      domain_min(B) < domain_min(A)\n    );\n    // L is B, L must contain one value gte max(A) and one value below min(A)\n    return domain_max(B) >= domain_max(A) && domain_min(B) < domain_min(A);\n  }\n\n  function cut_isnall(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n    const argsOffset = offset + SIZEOF_C;\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n\n    const indexR = readIndex(ml, argsOffset + argCount * 2);\n    const countsR = getCounts(bounty, indexR);\n\n    TRACE(' ! cut_isnall; R=', indexR);\n    ASSERT(\n      !countsR || !domain_isSolved(getDomain(indexR, true)),\n      'if it has counts it shouldnt be solved',\n      countsR,\n      indexR,\n      domain__debug(getDomain(indexR, true))\n    );\n\n    if (countsR === 1) {\n      return leaf_isnall(ml, offset, argCount, indexR, countsR);\n    }\n\n    pc += opSize;\n  }\n\n  function cut_issame(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(' ! cut_issame');\n\n    if (argCount !== 2) {\n      TRACE(' - argCount != 2 so bailing, for now');\n      pc = offset + SIZEOF_C + argCount * 2 + 2;\n      return;\n    }\n\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const indexB = readIndex(ml, offset + OFFSET_C_B);\n    const indexR = readIndex(ml, offset + OFFSET_C_C);\n\n    const countsA = getCounts(bounty, indexA);\n    const countsB = getCounts(bounty, indexB);\n    const countsR = getCounts(bounty, indexR);\n\n    TRACE(\n      ' - cut_issame; ',\n      indexR,\n      '=',\n      indexA,\n      '==?',\n      indexB,\n      '::',\n      domain__debug(getDomain(indexR, true)),\n      '=',\n      domain__debug(getDomain(indexA, true)),\n      '==?',\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsA || !domain_isSolved(getDomain(indexA, true)),\n      'if it has counts it shouldnt be solved',\n      countsA,\n      indexA,\n      domain__debug(getDomain(indexA, true))\n    );\n    ASSERT(\n      !countsB || !domain_isSolved(getDomain(indexB, true)),\n      'if it has counts it shouldnt be solved',\n      countsB,\n      indexB,\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsR || !domain_isSolved(getDomain(indexR, true)),\n      'if it has counts it shouldnt be solved',\n      countsR,\n      indexR,\n      domain__debug(getDomain(indexR, true))\n    );\n    TRACE(\n      '  - counts:',\n      countsR,\n      countsA,\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexR),\n      '=',\n      bounty__debugMeta(bounty, indexA),\n      '==?',\n      bounty__debugMeta(bounty, indexB)\n    );\n\n    if (countsR === 1) {\n      return leaf_issame(ml, offset, indexA, indexB, indexR, indexR);\n    }\n\n    if (countsA === 1) {\n      ASSERT(\n        !domain_isSolved(getDomain(indexA, true)),\n        'A cannot be solved (bounty ignores constants so count would be 0)'\n      );\n      if (canCutIssameForArg(indexA, indexB, indexR)) {\n        return leaf_issame(ml, offset, indexA, indexB, indexR, indexA);\n      }\n    }\n\n    if (countsB === 1) {\n      // Not covered, kept here just in case the above assertion doesnt hold in prod\n      ASSERT(\n        !domain_isSolved(getDomain(indexB, true)),\n        'B cannot be solved (bounty ignores constants so count would be 0)'\n      );\n      if (canCutIssameForArg(indexB, indexA, indexR)) {\n        return leaf_issame(ml, offset, indexA, indexB, indexR, indexB);\n      }\n    }\n\n    TRACE(' - no change from cut_issame');\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'should have 2 args');\n    pc = offset + SIZEOF_CR_2;\n  }\n\n  function canCutIssameForArg(indexL, indexO, indexR) {\n    TRACE(\n      '   - canCutIssameForArg;',\n      indexL,\n      indexO,\n      indexR,\n      '->',\n      domain__debug(getDomain(indexR, true)),\n      '=',\n      domain__debug(getDomain(indexL, true)),\n      '==?',\n      domain__debug(getDomain(indexO, true))\n    );\n    // An issame can only be leaf-cut on an arg if the leaf can represent all outcomes\n    // so if C is solved, solve as SAME or DIFF.\n    // otherwise make sure the leaf contains all vars of the other var and at least one var that's not in there\n    // as long as that's impossible we can't cut it without implicitly forcing vars\n\n    // first check whether R is booly-solved, this would mean fewer values to check\n\n    const R = getDomain(indexR, true);\n    if (domain_isZero(R)) {\n      TRACE('    - R=0 and size(L)>2 so cuttable');\n      // L contains at least two values so regardless of the state of O, L can fulfill !=\n      ASSERT(domain_size(L) >= 2, 'see?');\n      return true;\n    }\n\n    // R=1 or R=booly is more involved because we at least\n    // need to know whether L contains all values in O\n\n    const L = getDomain(indexL, true);\n    const O = getDomain(indexO, true);\n    const LO = domain_intersection(L, O); // <-- this tells us that\n    TRACE('    - LO:', domain__debug(LO));\n\n    if (domain_hasNoZero(R)) {\n      // Only cut if we are certain L can represent eq in any way O solves\n\n      if (!LO) {\n        TRACE('    - R>=1 and A contains no value in B so reject');\n        // No values in L and O match so reject\n        setDomain(indexL, domain_createEmpty(), false, true);\n        return false;\n      }\n\n      if (LO === O) {\n        TRACE('    - R>=1 and A contains all values in B so cuttable');\n        // This means L contains all values in O (and maybe more, dont care)\n        // which means L can uphold the eq for any value of O\n        return true;\n      }\n\n      TRACE(\n        '    - R>=1 and A contains some but not all B so not cuttable, yet'\n      );\n      // There's no guarantee O solves to a value in L so we cant cut safely\n      return true;\n    }\n\n    TRACE(\n      '    - R unresolved, cuttable if L contains all values in O and then some;',\n      LO === O,\n      LO !== L,\n      'so:',\n      LO === O && LO !== L\n    );\n    // We dont know R so L should contain all values in O (LO==O) and at least\n    // one value not in O (LO != O), to consider this a safe cut. otherwise dont.\n    return LO === O && LO !== L;\n  }\n\n  function cut_issome(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n    const argsOffset = offset + SIZEOF_C;\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n\n    const indexR = readIndex(ml, argsOffset + argCount * 2);\n    const countsR = getCounts(bounty, indexR);\n\n    TRACE(' ! cut_issome; R=', indexR);\n\n    if (countsR === 1) {\n      return leaf_issome(ml, offset, indexR, argCount);\n    }\n\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offset + SIZEOF_C + i * 2);\n\n      const A = getDomain(index, true);\n      if (domain_isZero(A)) {\n        TRACE(' - some has zeroes, requesting minimizer to remove them');\n        requestAnotherCycle = true; // Minimizer should eliminate these\n        break;\n      }\n    }\n\n    TRACE(' - cut_issome did not change anything');\n    pc += opSize;\n  }\n\n  function cut_lt(ml, offset) {\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const indexB = readIndex(ml, offset + OFFSET_C_B);\n\n    const countsA = getCounts(bounty, indexA);\n    const countsB = getCounts(bounty, indexB);\n\n    TRACE(\n      ' ! cut_lt; ',\n      indexA,\n      '<',\n      indexB,\n      '::',\n      domain__debug(getDomain(indexA, true)),\n      '<',\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsA || !domain_isSolved(getDomain(indexA, true)),\n      'if it has counts it shouldnt be solved',\n      countsA,\n      indexA,\n      domain__debug(getDomain(indexA, true))\n    );\n    ASSERT(\n      !countsB || !domain_isSolved(getDomain(indexB, true)),\n      'if it has counts it shouldnt be solved',\n      countsB,\n      indexB,\n      domain__debug(getDomain(indexB, true))\n    );\n    TRACE(\n      '  - counts:',\n      countsA,\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexA),\n      '<',\n      bounty__debugMeta(bounty, indexB)\n    );\n\n    if (indexA === indexB) {\n      TRACE(' - index A == B, redirecting to minimizer');\n      requestAnotherCycle = true;\n      return;\n    }\n\n    if (countsA === 1) {\n      return leaf_lt(ml, offset, indexA, indexB, 'lhs');\n    }\n\n    if (countsB === 1) {\n      return leaf_lt(ml, offset, indexA, indexB, 'rhs');\n    }\n\n    TRACE(' - cut_lt did not change anything');\n    pc += SIZEOF_C_2;\n  }\n\n  function cut_lte(ml, offset) {\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const indexB = readIndex(ml, offset + OFFSET_C_B);\n\n    const countsA = getCounts(bounty, indexA);\n    const countsB = getCounts(bounty, indexB);\n\n    TRACE(\n      ' ! cut_lte; ',\n      indexA,\n      '<=',\n      indexB,\n      '::',\n      domain__debug(getDomain(indexA, true)),\n      '<=',\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(\n      !countsA || !domain_isSolved(getDomain(indexA, true)),\n      'if it has counts it shouldnt be solved',\n      countsA,\n      indexA,\n      domain__debug(getDomain(indexA, true))\n    );\n    ASSERT(\n      !countsB || !domain_isSolved(getDomain(indexB, true)),\n      'if it has counts it shouldnt be solved',\n      countsB,\n      indexB,\n      domain__debug(getDomain(indexB, true))\n    );\n    TRACE(\n      '  - counts:',\n      countsA,\n      '<=',\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexA),\n      '<=',\n      bounty__debugMeta(bounty, indexB)\n    );\n\n    if (indexA === indexB) {\n      TRACE(' - index A == B, redirecting to minimizer');\n      requestAnotherCycle = true;\n      return;\n    }\n\n    if (countsA === 1) {\n      if (leaf_lte(ml, offset, indexA, indexB, true)) return;\n    }\n\n    if (countsB === 1) {\n      if (leaf_lte(ml, offset, indexA, indexB, false)) return;\n    }\n\n    if (countsA > 0) {\n      const metaA = getMeta(bounty, indexA);\n\n      if (\n        metaA === BOUNTY_FLAG_NALL ||\n        metaA === (BOUNTY_FLAG_NALL | BOUNTY_FLAG_LTE_LHS)\n      ) {\n        if (trick_ltelhs_nall_leaf(ml, indexA, countsA)) return;\n      }\n\n      if (metaA === BOUNTY_FLAG_LTE_LHS) {\n        if (trick_only_ltelhs_leaf(ml, indexA, countsA)) return;\n      }\n\n      if (countsA === 2) {\n        if (metaA === (BOUNTY_FLAG_LTE_LHS | BOUNTY_FLAG_SOME)) {\n          if (trick_ltelhs_some_leaf(ml, offset, indexA, countsA)) return;\n        }\n      }\n\n      if (countsA >= 3) {\n        if (\n          metaA ===\n          (BOUNTY_FLAG_SOME | BOUNTY_FLAG_NALL | BOUNTY_FLAG_LTE_LHS)\n        ) {\n          if (trick_ltelhs_nalls_some(indexA, countsA)) return;\n        }\n\n        if (\n          metaA ===\n          (BOUNTY_FLAG_SOME |\n            BOUNTY_FLAG_NALL |\n            BOUNTY_FLAG_LTE_LHS |\n            BOUNTY_FLAG_LTE_RHS)\n        ) {\n          if (trick_lteboth_nall_some(indexA, countsA)) return;\n        }\n      }\n\n      if (hasFlags(metaA, BOUNTY_FLAG_ISALL_RESULT)) {\n        // In this trick one constraint subsumes the other so no need for A being a leaf\n        if (trick_isall_ltelhs_2shared(ml, offset, indexA, countsA)) return;\n\n        // In this trick A needs to be a leaf\n        if (countsA === 2) {\n          if (trick_isall_ltelhs_1shared(ml, offset, indexA, countsA)) return;\n        }\n      }\n    }\n\n    if (countsB === 2) {\n      const metaB = getMeta(bounty, indexB);\n\n      if (metaB === (BOUNTY_FLAG_LTE_RHS | BOUNTY_FLAG_ISALL_RESULT)) {\n        if (trick_isall_lterhs_entry(indexB, offset, countsB)) return;\n      }\n\n      if (metaB === (BOUNTY_FLAG_LTE_RHS | BOUNTY_FLAG_ISSAME_RESULT)) {\n        if (trick_issame_lterhs(indexB, offset, countsB, indexA)) return;\n      }\n    }\n\n    TRACE(' - cut_lte changed nothing');\n    pc += SIZEOF_C_2;\n  }\n\n  function cut_nall(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(' ! cut_nall;', argCount, 'args');\n\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const countsA = getCounts(bounty, indexA);\n    if (countsA > 1 && countsA < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      // Search all counts for a second SOME\n      if (desubset_nall(ml, offset, argCount, indexA, countsA)) return;\n    }\n\n    if (argCount === 2) {\n      if (\n        readIndex(ml, offset + OFFSET_C_A) ===\n        readIndex(ml, offset + OFFSET_C_B)\n      ) {\n        TRACE(' - argcount=2 and A==B, requesting minimzer cycle');\n        requestAnotherCycle = true;\n        return;\n      }\n    }\n\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offset + SIZEOF_C + i * 2);\n      const counts = getCounts(bounty, index);\n\n      if (counts > 0) {\n        const meta = getMeta(bounty, index);\n        if (meta === BOUNTY_FLAG_NALL) {\n          // Var is only used in nalls. eliminate them all and defer the var\n          if (trickNallOnly(index, counts)) return true;\n        }\n      }\n    }\n\n    TRACE(' - cut_nall did not change anything');\n    pc += SIZEOF_C + argCount * 2;\n  }\n\n  function cut_some(ml, offset) {\n    const argCount = ml_dec16(ml, pc + 1);\n\n    TRACE(' ! cut_some;', argCount, 'args');\n\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const countsA = getCounts(bounty, indexA);\n    if (countsA > 1 && countsA < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      // Search all counts for a second SOME\n      if (desubset_some(ml, offset, argCount, indexA, countsA)) return;\n    }\n\n    if (argCount === 2) {\n      const indexB = readIndex(ml, offset + OFFSET_C_B);\n\n      if (indexA === indexB) {\n        TRACE(' - argcount=2 and A==B, requesting minimzer cycle');\n        requestAnotherCycle = true;\n        return;\n      }\n\n      if (countsA === 1) {\n        leaf_some_2(ml, offset, indexA, indexB, indexA, indexB);\n        return;\n      }\n\n      const countsB = getCounts(bounty, indexB);\n\n      if (countsB === 1) {\n        leaf_some_2(ml, offset, indexB, indexA, indexA, indexB);\n        return;\n      }\n    }\n\n    let hasZero = false;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offset + SIZEOF_C + i * 2);\n      const counts = getCounts(bounty, index);\n\n      if (counts > 0) {\n        const meta = getMeta(bounty, index);\n        if (meta === BOUNTY_FLAG_SOME) {\n          // Var is only used in SOMEs. eliminate them all and defer the var\n          if (trickSomeOnly(index, counts)) return true;\n        }\n      }\n\n      const A = getDomain(index, true);\n      if (domain_isZero(A)) {\n        hasZero = true;\n      }\n    }\n\n    if (hasZero) {\n      TRACE(' - some has zeroes, requesting minimizer to remove them');\n      requestAnotherCycle = true; // Minimizer should eliminate these\n    }\n\n    TRACE(' - cut_some changed nothing');\n    pc += SIZEOF_C + argCount * 2;\n  }\n\n  function cut_sum(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n    const argsOffset = offset + SIZEOF_C;\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n\n    const indexR = readIndex(ml, argsOffset + argCount * 2);\n    const R = getDomain(indexR, true);\n    const countsR = getCounts(bounty, indexR);\n\n    TRACE(' ! cut_sum;');\n    TRACE(\n      '  - index R:',\n      indexR,\n      ', domain:',\n      domain__debug(R),\n      ', argCount:',\n      argCount,\n      ',counts R:',\n      countsR,\n      ', meta R:',\n      bounty__debugMeta(bounty, indexR)\n    );\n    ASSERT(\n      !countsR || !domain_isSolved(getDomain(indexR, true)),\n      'if it has counts it shouldnt be solved',\n      countsR,\n      indexR,\n      domain__debug(getDomain(indexR, true))\n    );\n\n    const RisBoolyPair = domain_isBoolyPair(R);\n\n    // Collect meta data on the args of this sum\n    // TODO: should we have a bounty for both constraints and vars?\n    let allSumArgsBool = true; // All args [01]? used later\n    let allSumArgsBoolyPairs = true; // All args have a zero and one nonzero value?\n    let sum = domain_createValue(0);\n    let argsMinSum = 0;\n    let argsMaxSum = 0;\n    let constantValue = 0; // Allow up to one constant larger than 0\n    let constantArgIndex = -1;\n    let multiConstants = false;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, argsOffset + i * 2);\n      const domain = getDomain(index, true);\n      const minValue = domain_min(domain);\n      const maxValue = domain_max(domain);\n\n      sum = domain_plus(sum, domain);\n      argsMinSum += minValue;\n      argsMaxSum += maxValue;\n      // Let nonBoolNonSolvedDomain = maxValue > 1;\n      if (minValue === maxValue) {\n        multiConstants = constantArgIndex >= 0;\n        constantValue = minValue;\n        constantArgIndex = i;\n      } else {\n        if (!domain_isBoolyPair(domain)) allSumArgsBoolyPairs = false;\n        if (!domain_isBool(domain)) allSumArgsBool = false;\n      }\n    }\n\n    TRACE(\n      ' - sum args; min:',\n      argsMinSum,\n      ', max:',\n      argsMaxSum,\n      ', constantValue:',\n      constantValue,\n      ', constant pos:',\n      constantArgIndex,\n      ', sum:',\n      domain__debug(sum)\n    );\n\n    if (multiConstants) {\n      TRACE(\n        ' - multiple constants detected, bailing so minimizer can correct this'\n      );\n      return;\n    }\n\n    // [0 0 23 23] = [0 1] + [0 0 2 2] + [0 0 20 20]   ->    R = all?(A B C)\n    if (RisBoolyPair && allSumArgsBoolyPairs) {\n      // This trick is irrelevant of leaf status (this could be part of minimizer)\n      TRACE(\n        ' - R is a booly and all the args are booly too, checking whether',\n        domain_max(R),\n        '===',\n        argsMaxSum\n      );\n      ASSERT(argsMinSum === 0, 'if all are booly argsMinSum should be zero');\n      if (domain_max(R) === argsMaxSum) {\n        TRACE(\n          ' - R is',\n          domain__debug(R),\n          'and all the args are booly and their argsMaxSum is equal to max(R) so this is actually an isall. morphing sum to isall'\n        );\n        ml_enc8(ml, offset, ML_ISALL);\n        return;\n      }\n    }\n\n    // Note: we cant simply eliminate leaf vars because they still constrain\n    // the allowed distance between the other variables and if you\n    // eliminate this constraint, that limitation is not enforced anymore.\n    // so thread carefully.\n    if (countsR === 1) {\n      // R can only be eliminated if all possible additions between A and B occur in it\n      // because in that case it no longer serves as a constraint to force certain distance(s)\n\n      if (sum === domain_intersection(R, sum)) {\n        // All possible outcomes of summing any element in the sum args are part of R so\n        // R is a leaf and the args aren't bound by it so we can safely remove the sum\n        return leaf_sum_result(ml, offset, argCount, indexR);\n      }\n\n      // If R is [0, n-1] and all n args are [0, 1] then rewrite to a NALL\n      if (allSumArgsBool && R === domain_createRange(0, argCount - 1)) {\n        return trick_sum_to_nall(ml, offset, argCount, indexR);\n      }\n\n      // If R is [1, n] and all n args are [0, 1] then rewrite to a SOME\n      if (allSumArgsBool && R === domain_createRange(1, argCount)) {\n        return trick_some_sum(ml, offset, argCount, indexR);\n      }\n    }\n\n    if (countsR >= 2) {\n      const metaR = getMeta(bounty, indexR);\n      ASSERT(\n        hasFlags(metaR, BOUNTY_FLAG_SUM_RESULT),\n        'per definition because this is the R in a sum'\n      );\n\n      // TODO: cant we also do this with counts>2 when R is a bool when ignoring the sum?\n      // TOFIX: confirm whether we need allSumArgsBool here, or whether we can lax it a little\n      if (allSumArgsBoolyPairs && countsR === 2) {\n        // We already confirmed that R is for a sum, so we can strictly compare the meta flags\n\n        // (R = sum(A B C) & (S = R==?3)        ->    S = all?(A B C)\n        // (R = sum(A B C) & (S = R==?0)        ->    S = none?(A B C)\n        // (R = sum(A B C) & (S = R==?[0 1])    ->    S = nall?(A B C)\n        // (R = sum(A B C) & (S = R==?[1 2])    ->    S = some?(A B C)\n        if (metaR === (BOUNTY_FLAG_ISSAME_ARG | BOUNTY_FLAG_SUM_RESULT)) {\n          if (\n            trick_issame_sum(\n              ml,\n              offset,\n              indexR,\n              countsR,\n              argCount,\n              sum,\n              argsMinSum,\n              argsMaxSum,\n              constantValue,\n              constantArgIndex,\n              allSumArgsBoolyPairs\n            )\n          )\n            return;\n        }\n\n        // (R = sum(A B C) & (S = R!=?3)        ->    S = nall?(A B C)\n        // (R = sum(A B C) & (S = R!=?0)        ->    S = some?(A B C)\n        // (R = sum(A B C) & (S = R!=?[0 1])    ->    S = all?(A B C)\n        // (R = sum(A B C) & (S = R!=?[1 2])    ->    S = none?(A B C)\n        // if (metaR === (BOUNTY_FLAG_ISDIFF_ARG | BOUNTY_FLAG_SUM_RESULT)) {\n        //  if (trickSumIsdiff(ml, offset, indexR, countsR)) return;\n        // }\n\n        // (R = sum(A B C) & (S = R<=?0)        ->    S = none?(A B C)\n        // (R = sum(A B C) & (S = R<=?2)        ->    S = nall?(A B C)\n        // (R = sum(A B C) & (S = 1<=?R)        ->    S = some?(A B C)\n        // (R = sum(A B C) & (S = 3<=?R)        ->    S = all?(A B C)\n        if (metaR === (BOUNTY_FLAG_ISLTE_ARG | BOUNTY_FLAG_SUM_RESULT)) {\n          if (\n            trick_islte_sum(\n              ml,\n              offset,\n              indexR,\n              countsR,\n              argCount,\n              argsMinSum,\n              argsMaxSum,\n              constantValue,\n              constantArgIndex\n            )\n          )\n            return;\n        }\n\n        // (R = sum(A B C) & (S = R<?1)        ->    S = none?(A B C)\n        // (R = sum(A B C) & (S = R<?3)        ->    S = nall?(A B C)\n        // (R = sum(A B C) & (S = 0<?R)        ->    S = some?(A B C)\n        // (R = sum(A B C) & (S = 2<?R)        ->    S = all?(A B C)\n        // if (metaR === (BOUNTY_FLAG_ISLT_ARG | BOUNTY_FLAG_SUM_RESULT)) {\n        //  if (trickSumIslt(ml, offset, indexR, countsR)) return;\n        // }\n      }\n\n      if (\n        countsR === 3 &&\n        argCount === 2 &&\n        metaR === (BOUNTY_FLAG_ISSAME_ARG | BOUNTY_FLAG_SUM_RESULT)\n      ) {\n        // TODO: make generic :)\n        // R = sum(A B), S = R ==? 1, T = R ==? 2    ->    S = A !=? B, T = all?(A B)\n        if (trick_issame_issame_sum(ml, offset, indexR, countsR, sum, argCount))\n          return;\n      }\n\n      if (countsR < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n        // If R is only used as a booly and (this) sum result, the actual result is irrelevant: only zero or not zero\n        // in that case we only want to know whether any of its arguments are non-zero => `isSome`\n        // For example: (R = sum(A B C), R ^ X) -> (R = isNone?(A B C), R ^ X)\n        if (trick_sum_booly(ml, offset, indexR, countsR, sum, argCount)) return;\n      }\n    }\n\n    TRACE(' - cut_sum changed nothing');\n    pc += opSize;\n  }\n\n  function cut_xnor(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(' ! cut_xnor;', argCount, 'args');\n\n    if (argCount === 2) {\n      const indexA = readIndex(ml, offset + OFFSET_C_A);\n      const indexB = readIndex(ml, offset + OFFSET_C_B);\n\n      const countsA = getCounts(bounty, indexA);\n      const countsB = getCounts(bounty, indexB);\n\n      TRACE(\n        ' - 2 args!',\n        indexA,\n        '!^',\n        indexB,\n        '::',\n        domain__debug(getDomain(indexA, true)),\n        '!^',\n        domain__debug(getDomain(indexB, true))\n      );\n      ASSERT(\n        !countsA || !domain_isSolved(getDomain(indexA, true)),\n        'if it has counts it shouldnt be solved',\n        countsA,\n        indexA,\n        domain__debug(getDomain(indexA, true))\n      );\n      ASSERT(\n        !countsB || !domain_isSolved(getDomain(indexB, true)),\n        'if it has counts it shouldnt be solved',\n        countsB,\n        indexB,\n        domain__debug(getDomain(indexB, true))\n      );\n      TRACE(\n        '  - counts:',\n        countsA,\n        countsB,\n        ', meta:',\n        bounty__debugMeta(bounty, indexA),\n        '!^',\n        bounty__debugMeta(bounty, indexB)\n      );\n\n      if (indexA === indexB) {\n        TRACE(' - argcount=2 and A==B, requesting minimzer cycle');\n        requestAnotherCycle = true;\n        return;\n      }\n\n      if (countsA === 1) {\n        return leaf_xnor(ml, offset, indexA, indexB, indexA, indexB);\n      }\n\n      if (countsB === 1) {\n        return leaf_xnor(ml, offset, indexB, indexA, indexA, indexB);\n      }\n\n      // (do we care about constants here? technically the minimizer should eliminate xnors with constants... so, no?)\n      if (countsA > 0 && countsB > 0) {\n        const metaA = getMeta(bounty, indexA, true); // Keep booly flags\n        const metaB = getMeta(bounty, indexB, true);\n        TRACE(\n          ' - considering whether A and B are xnor pseudo aliases;',\n          bounty__debugMeta(bounty, indexA),\n          '!^',\n          bounty__debugMeta(bounty, indexB)\n        );\n        const boolyA = !hasFlags(metaA, BOUNTY_FLAG_NOT_BOOLY);\n        const boolyB = !hasFlags(metaB, BOUNTY_FLAG_NOT_BOOLY);\n        TRACE(\n          ' - ',\n          boolyA || boolyB ? 'yes' : 'no',\n          ' ->',\n          boolyA,\n          '||',\n          boolyB\n        );\n        if (boolyA || boolyB) {\n          // We declare A and alias of B. they are both used as booly only and the xnor states that if and\n          // only if A is truthy then B must be truthy too. since we confirmed both are only used as booly\n          // their actual non-zero values are irrelevant and the rewrite is safe. the last thing to make\n          // sure is that the domains are updated afterwards and not synced and clobbered by the alias code.\n          return trick_xnor_pseudoSame(\n            ml,\n            offset,\n            indexA,\n            boolyA,\n            indexB,\n            boolyB\n          );\n        }\n      }\n    }\n\n    TRACE(' - cut_xnor did nothing');\n    pc += SIZEOF_C + argCount * 2;\n  }\n\n  function cut_xor(ml, offset) {\n    const indexA = readIndex(ml, offset + OFFSET_C_A);\n    const indexB = readIndex(ml, offset + OFFSET_C_B);\n\n    const countsA = getCounts(bounty, indexA);\n    const countsB = getCounts(bounty, indexB);\n\n    TRACE(\n      ' ! cut_xor; ',\n      indexA,\n      '^',\n      indexB,\n      '::',\n      domain__debug(getDomain(indexA, true)),\n      '^',\n      domain__debug(getDomain(indexB, true))\n    );\n    TRACE(\n      '  - counts:',\n      countsA,\n      countsB,\n      ', meta:',\n      bounty__debugMeta(bounty, indexA),\n      '^',\n      bounty__debugMeta(bounty, indexB)\n    );\n    ASSERT(\n      !countsA || !domain_isSolved(getDomain(indexA, true)),\n      'if it has counts it shouldnt be solved',\n      countsA,\n      indexA,\n      domain__debug(getDomain(indexA, true))\n    );\n    ASSERT(\n      !countsB || !domain_isSolved(getDomain(indexB, true)),\n      'if it has counts it shouldnt be solved',\n      countsB,\n      indexB,\n      domain__debug(getDomain(indexB, true))\n    );\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'xor always has 2 args');\n\n    if (indexA === indexB) {\n      TRACE(' - argcount=2 and A==B, requesting minimzer cycle');\n      requestAnotherCycle = true;\n      return;\n    }\n\n    if (countsA === 1) {\n      return leaf_xor(ml, offset, indexA, indexB, indexA, indexB);\n    }\n\n    if (countsB === 1) {\n      return leaf_xor(ml, offset, indexB, indexA, indexA, indexB);\n    }\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n    if (!domain_isBooly(A) || !domain_isBooly(B)) {\n      TRACE(\n        ' / at least A or B is already booly solved. bailing so minimizer can take over.'\n      );\n      requestAnotherCycle = true;\n      return;\n    }\n\n    if (countsA > 0 && countsB > 0) {\n      const metaA = getMeta(bounty, indexA, true); // Keep booly flags\n      const metaB = getMeta(bounty, indexB, true);\n\n      const AonlyUsedBooly = !hasFlags(metaA, BOUNTY_FLAG_NOT_BOOLY);\n      const BonlyUsedBooly = !hasFlags(metaB, BOUNTY_FLAG_NOT_BOOLY);\n\n      // Meta should only be these flags\n      const TRICK_INV_XOR_FLAGS =\n        BOUNTY_FLAG_SOME |\n        BOUNTY_FLAG_NALL |\n        BOUNTY_FLAG_IMP_LHS |\n        BOUNTY_FLAG_IMP_RHS |\n        BOUNTY_FLAG_XOR;\n\n      if (countsA < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n        // Check for some/nall/imp/xor. if A only concerns these then we can invert those\n        // ops and remove the xor. Note: LTE only works when it could be an implication,\n        // so we can omit a check for that as those LTE's should morph into IMP eventually\n        TRACE(\n          '  - A; only contains good flags?',\n          (metaA & TRICK_INV_XOR_FLAGS) === metaA\n        );\n        if ((metaA & TRICK_INV_XOR_FLAGS) === metaA) {\n          if (trick_xor_elimination(offset, indexA, countsA, indexB)) return;\n        }\n\n        if (countsA === 2) {\n          if (hasFlags(metaA, BOUNTY_FLAG_ISALL_RESULT)) {\n            // R^A, R=all?(X Y Z)  ->   A=nall(X Y Z)\n            if (trick_isall_xor(indexA, indexB, offset, countsA, countsB))\n              return;\n          }\n\n          if (AonlyUsedBooly && hasFlags(metaA, BOUNTY_FLAG_ISSOME_RESULT)) {\n            // R^X, R=some?(A B C)   ->    X=none?(A B C)\n            if (trick_issome_xor(indexA, indexB, offset, countsA, countsB))\n              return;\n          }\n\n          if (metaA === (BOUNTY_FLAG_XOR | BOUNTY_FLAG_SOME)) {\n            if (trick_some_xor(indexA, indexB, offset, countsA)) return;\n          }\n        }\n\n        const sB = domain_size(B);\n        if (trick_xor_alias(indexA, indexB, countsA, B, sB, BonlyUsedBooly))\n          return;\n      }\n\n      if (countsB < BOUNTY_MAX_OFFSETS_TO_TRACK) {\n        // Check for some/nall/imp/xor. if B only concerns these then we can invert those\n        // ops and remove the xor. Note: LTE only works when it could be an implication,\n        // so we can omit a check for that as those LTE's should morph into IMP eventually\n        TRACE(\n          '  - B; only contains good flags?',\n          (metaB & TRICK_INV_XOR_FLAGS) === metaB\n        );\n        if (domain_isBoolyPair(B) && (metaB & TRICK_INV_XOR_FLAGS) === metaB) {\n          if (trick_xor_elimination(offset, indexB, countsB, indexA)) return;\n        }\n\n        if (countsB === 2) {\n          if (hasFlags(metaB, BOUNTY_FLAG_ISALL_RESULT)) {\n            // R^B, R=all?(X Y Z)  ->   B=nall(X Y Z)\n            if (trick_isall_xor(indexB, indexA, offset, countsB, countsA))\n              return;\n          }\n\n          if (BonlyUsedBooly && hasFlags(metaB, BOUNTY_FLAG_ISSOME_RESULT)) {\n            // R^X, R=some?(A B C)   ->    X=none?(A B C)\n            if (trick_issome_xor(indexB, indexA, offset, countsB, countsA))\n              return;\n          }\n\n          if (metaB === (BOUNTY_FLAG_XOR | BOUNTY_FLAG_SOME)) {\n            if (trick_some_xor(indexB, indexA, offset, countsB)) return;\n          }\n        }\n\n        const sA = domain_size(A);\n        if (trick_xor_alias(indexB, indexA, countsB, A, sA, AonlyUsedBooly))\n          return;\n      }\n    }\n\n    TRACE(' / cut_xor changed nothing');\n    pc += SIZEOF_C_2;\n  }\n\n  // ##############\n\n  function leaf_diff_pair(ml, offset, leafIndex, otherIndex, indexA, indexB) {\n    TRACE(\n      '   - leaf_diff_pair;',\n      leafIndex,\n      'is a leaf var, A != B,',\n      indexA,\n      '!=',\n      indexB\n    );\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - leaf_diff_pair; solving',\n        indexA,\n        '!=',\n        indexB,\n        '  ->  ',\n        domain__debug(getDomain(indexA)),\n        '!=',\n        domain__debug(getDomain(indexB))\n      );\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n      if (domain_size(A) < domain_size(B)) {\n        const v = force(indexA);\n        setDomain(indexB, domain_removeValue(B, v));\n      } else {\n        const v = force(indexB);\n        setDomain(indexA, domain_removeValue(A, v));\n      }\n\n      ASSERT(\n        getDomain(indexA) !== getDomain(indexB),\n        'D ought to have at least a value other dan v'\n      );\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n    bounty_markVar(bounty, leafIndex);\n    bounty_markVar(bounty, otherIndex);\n    somethingChanged();\n  }\n\n  function leaf_imp(ml, offset, indexA, indexB, leafIsA) {\n    TRACE(\n      '   - leaf_imp;',\n      leafIsA ? 'A' : 'B',\n      'is a leaf var, A -> B;',\n      indexA,\n      '->',\n      indexB\n    );\n    ASSERT(typeof indexA === 'number', 'index A should be number', indexA);\n    ASSERT(typeof indexB === 'number', 'index B should be number', indexB);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - leaf_imp; solving',\n        indexA,\n        '->',\n        indexB,\n        '  =>  ',\n        domain__debug(getDomain(indexA)),\n        '->',\n        domain__debug(getDomain(indexB)),\n        '  =>  ',\n        domain_max(getDomain(indexA)),\n        '->',\n        domain_min(getDomain(indexB))\n      );\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n\n      // TODO: weigh in value dists here\n\n      if (leafIsA) {\n        TRACE(' - A was leaf; A=', domain__debug(A), '->', domain__debug(B));\n        // (we could simply and safely set A to 0 here and skip the solvestack part completely)\n        if (domain_hasNoZero(B)) {\n          const nA = domain_removeValue(A, 0);\n          ASSERT(nA, 'A should not be empty');\n          if (A !== nA) setDomain(indexA, nA);\n        } else {\n          const nA = domain_intersectionValue(A, 0);\n          ASSERT(nA, 'A should not be empty');\n          if (A !== nA) setDomain(indexA, nA);\n        }\n      } else {\n        TRACE(' - B was leaf; A=', domain__debug(A), '->', domain__debug(B));\n        // (we could simply and safely set B to nonzero here and skip the solvestack part completely)\n        if (domain_hasNoZero(A)) {\n          const nB = domain_removeValue(B, 0);\n          ASSERT(nB, 'B should not be empty');\n          if (A !== nB) setDomain(indexB, nB);\n        } else {\n          const nB = domain_intersectionValue(B, 0);\n          ASSERT(nB, 'B should not be empty');\n          if (B !== nB) setDomain(indexB, nB);\n        }\n      }\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    somethingChanged();\n  }\n\n  function leaf_isdiff(ml, offset, indexA, indexB, indexR, indexL) {\n    TRACE(\n      '   - leaf_isdiff; index',\n      indexL,\n      'is a leaf var, R = A !=? B,',\n      indexR,\n      '=',\n      indexA,\n      '!=?',\n      indexB,\n      '  ->  ',\n      domain__debug(getDomain(indexR)),\n      '=',\n      domain__debug(getDomain(indexA)),\n      '!=?',\n      domain__debug(getDomain(indexB))\n    );\n\n    ASSERT(ml_dec16(ml, offset + 1) === 2);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - leaf_isdiff');\n\n      let A = getDomain(indexA);\n      let B = getDomain(indexB);\n      let R = getDomain(indexR);\n      TRACE(\n        ' - leaf=',\n        indexL,\n        ';',\n        indexR,\n        '=',\n        indexA,\n        '!=?',\n        indexB,\n        '  =>  ',\n        domain__debug(R),\n        '=',\n        domain__debug(A),\n        '!=?',\n        domain__debug(B),\n        ', AB=',\n        domain__debug(domain_intersection(A, B))\n      );\n\n      if (domain_isSolved(A)) {\n        if (domain_isSolved(B)) {\n          TRACE(\n            ' - A and B are solved, set R to reflect',\n            domain_getValue(A),\n            '!=',\n            domain_getValue(B)\n          );\n          if (A !== B) R = domain_removeValue(R, 0);\n          else R = domain_removeGtUnsafe(R, 0);\n          setDomain(indexR, R);\n        } else if (domain_isBooly(R)) {\n          TRACE(\n            ' - A is solved but B and R arent, remove A from B and set R>0'\n          );\n          B = domain_removeValue(B, domain_getValue(A));\n          setDomain(indexB, B);\n          R = domain_removeValue(R, 0);\n          setDomain(indexR, R);\n        } else {\n          TRACE(' - A and R are solved, set B to reflect it');\n          if (domain_isZero(R)) {\n            TRACE(' - R=0 so A==B');\n            setDomain(indexB, A);\n          } else {\n            TRACE(' - R>0 so A!=B');\n            B = domain_removeValue(B, domain_getValue(A));\n            setDomain(indexB, B);\n          }\n        }\n      } else if (domain_isSolved(B)) {\n        if (domain_isBooly(R)) {\n          TRACE(\n            ' - B is solved but A and R are not. Remove B from A and set R>0'\n          );\n          A = domain_removeValue(A, domain_getValue(B));\n          setDomain(indexA, A);\n          R = domain_removeValue(R, 0);\n          setDomain(indexR, R);\n        } else {\n          TRACE(' - B and R are solved but A is not. Update A to reflect R');\n          if (domain_isZero(R)) {\n            TRACE(' - R=0 so A==B');\n            setDomain(indexA, B);\n          } else {\n            TRACE(' - R>0 so A!=B');\n            A = domain_removeValue(A, domain_getValue(B));\n            setDomain(indexA, A);\n          }\n        }\n      } else if (domain_isBooly(R)) {\n        TRACE(\n          ' - A, B, and R arent solved. force A and remove it from B (if A and B intersect) and set R>0'\n        );\n        if (domain_intersection(A, B) !== EMPTY) {\n          B = domain_removeValue(B, force(indexA));\n          setDomain(indexB, B);\n        }\n\n        R = domain_removeValue(R, 0);\n        setDomain(indexR, R);\n      } else {\n        TRACE(' - A and B arent solved but R is. update A and B to reflect R');\n        if (domain_isZero(R)) {\n          TRACE(' - R=0 so A==B');\n          const vA = force(indexA, domain_intersection(A, B));\n          ASSERT(domain_intersection(B, domain_createValue(vA)) !== EMPTY);\n          B = domain_createValue(vA);\n          setDomain(indexB, B);\n        } else {\n          const vA = force(indexA);\n          B = domain_removeValue(B, vA);\n          setDomain(indexB, B);\n        }\n      }\n\n      TRACE(\n        ' - afterwards: R:' + indexR + ':' + domain__debug(getDomain(indexR)),\n        ' = A:' + indexA + ':' + domain__debug(getDomain(indexA)),\n        ' !=? B:' + indexB + ':' + domain__debug(getDomain(indexB)),\n        ', AB=',\n        domain__debug(domain_intersection(getDomain(indexA), getDomain(indexB)))\n      );\n\n      // 3 things must hold;\n      // - A or B must be solved or not intersect (otherwise future reductions may violate R)\n      // - R must not be booly (obviously)\n      // - R's state must reflect whether or not A shares a value with B (which by the above should at most be one value, but that's not helpful)\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexB));\n      ASSERT(getDomain(indexR));\n      ASSERT(\n        domain_intersection(getDomain(indexA), getDomain(indexB)) === EMPTY ||\n          domain_isSolved(getDomain(indexA)) ||\n          domain_isSolved(getDomain(indexB)),\n        'at least A or B must be solved in order to ensure R always holds'\n      );\n      ASSERT(\n        !domain_isBooly(getDomain(indexR)),\n        'R must not be a booly to ensure the constraint always holds'\n      );\n      ASSERT(\n        (domain_intersection(getDomain(indexA), getDomain(indexB)) ===\n          EMPTY) ===\n          domain_hasNoZero(getDomain(indexR)),\n        'R must be nonzero if A and B share no elements'\n      );\n    });\n\n    ASSERT(\n      ml_dec16(ml, offset + 1) === 2,\n      'argcount should be 2 at the moment'\n    );\n    ml_eliminate(ml, offset, SIZEOF_CR_2);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n  }\n\n  function leaf_isall(ml, offset, argCount, indexR) {\n    TRACE(\n      '   - leaf_isall;',\n      indexR,\n      'is a leaf var, R = all?(',\n      argCount,\n      'x ),',\n      indexR,\n      '= all?(...)'\n    );\n\n    const args = markAndCollectArgs(ml, offset, argCount);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - leaf_isall; ',\n        indexR,\n        '= isAll(',\n        args.join(' '),\n        ')  ->  ',\n        domain__debug(getDomain(indexR)),\n        ' = isAll(',\n        args.map(index => domain__debug(getDomain(index))).join(' '),\n        ')'\n      );\n      let vR = 1;\n      for (let i = 0; i < argCount; ++i) {\n        if (force(args[i]) === 0) {\n          vR = 0;\n          break;\n        }\n      }\n\n      const oR = getDomain(indexR);\n      const R = domain_resolveAsBooly(oR, vR);\n      ASSERT(R, 'R should be able to at least represent the solution');\n      setDomain(indexR, R);\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n  }\n\n  function leaf_isall_arg_result(ml, indexR, countsR) {\n    // R is only result or arg of isall ops.\n    // for trick R must be result _and_ arg in _all_ the isalls\n\n    // if R is only part of `R = all?(R ...)` ops then leaf(R) and eliminate the constraint\n    // if R is part of `R = all?(R ...)` and `S = all?(R ...)` then leaf R and morph to imps S->A, S->B all other args\n\n    const R = getDomain(indexR, true);\n    if (!domain_isBool(R)) {\n      TRACE(' - R is not bool, bailing');\n      return false;\n    }\n\n    // First verify, scan, and collect\n    const argOnlyOffsets = [];\n    const resultOnlyOffsets = [];\n    const argAndResultOffsets = [];\n    const allArgs = [];\n    const offsets = [];\n    for (let i = 0; i < countsR; ++i) {\n      const offset = bounty_getOffset(bounty, indexR, i);\n      TRACE('    - i=', i, ', offset=', offset);\n      ASSERT(ml_dec8(ml, offset) === ML_ISALL);\n      // Each offset could be visited twice if this trick is applied\n      if (offsets.indexOf(offset) < 0) {\n        const argCount = ml_dec16(ml, offset + 1);\n\n        const resultIndex = readIndex(ml, offset + SIZEOF_C + argCount * 2);\n\n        const args = [];\n        let foundAsArg = false;\n        for (let j = 0; j < argCount; ++j) {\n          const index = readIndex(ml, offset + SIZEOF_C + j * 2);\n          args.push(index);\n          if (index === indexR) foundAsArg = true;\n        }\n\n        TRACE(\n          '    - is result?',\n          resultIndex === indexR,\n          ', is arg?',\n          foundAsArg\n        );\n\n        ASSERT(\n          foundAsArg || resultIndex === indexR,\n          'R should be part of the isall as per bounty'\n        );\n        if (resultIndex !== indexR) argOnlyOffsets.push(offset);\n        else if (!foundAsArg) resultOnlyOffsets.push(offset);\n        else argAndResultOffsets.push(offset);\n\n        allArgs.push(args);\n        offsets.push(offset);\n      }\n    }\n\n    TRACE(\n      ' - collected: result only:',\n      resultOnlyOffsets,\n      ', arg only:',\n      argOnlyOffsets,\n      ', both result and arg:',\n      argAndResultOffsets\n    );\n\n    // Three cases: either R was a result-only or arg-only in at least one isall, or not. yes, three cases.\n\n    if (resultOnlyOffsets.length) {\n      TRACE(\n        ' - there was at least one isall where R was the result only. cant apply this trick. bailing'\n      );\n      return false;\n    }\n\n    ASSERT(\n      argAndResultOffsets.length,\n      'bounty found R to be result and arg of isall and there were no isalls where R was result only so there must be at least one isall with R being result and arg'\n    );\n\n    // Two cases left: either R was result AND arg in all isalls or there was at least one isall where it was arg only\n\n    if (argOnlyOffsets.length) {\n      return _leafIsallArgResultMaybe(\n        ml,\n        indexR,\n        allArgs,\n        offsets,\n        R,\n        countsR,\n        argOnlyOffsets,\n        argAndResultOffsets\n      );\n    }\n\n    return _leafIsallArgResultOnly(ml, indexR, allArgs, offsets, R);\n  }\n\n  function _leafIsallArgResultMaybe(\n    ml,\n    indexR,\n    allArgs,\n    offsets,\n    R,\n    countsR,\n    argOnlyOffsets,\n    argAndResultOffsets\n  ) {\n    TRACE(\n      ' - confirmed, R is only part of isall where R is result and arg or just arg and at least one of each'\n    );\n    TRACE(\n      ' - R = all?(R ...), S = all?(R ...)    =>    S -> A, S -> B, ... for all args of the isalls'\n    );\n\n    // Note: one isall contributes 2 counts, the other only 1\n    if (countsR !== 3) {\n      TRACE(\n        ' - countsR != 3, for now we bail on this. maybe in the future we can do this.'\n      );\n      return false;\n    }\n\n    ASSERT(\n      argOnlyOffsets.length === 1 && argAndResultOffsets.length === 1,\n      'for now'\n    );\n\n    const argOnlyIsallOffset = argOnlyOffsets[0];\n    const argOnlyIsallArgCount = ml_dec16(ml, argOnlyIsallOffset + 1);\n\n    const argAndResultIsallOffset = argAndResultOffsets[0];\n    const argAndResultIsallArgCount = ml_dec16(ml, argAndResultIsallOffset + 1);\n\n    const indexS = readIndex(\n      ml,\n      argOnlyIsallOffset + SIZEOF_C + argOnlyIsallArgCount * 2\n    );\n    if (argOnlyIsallArgCount !== 2 || argAndResultIsallArgCount !== 2) {\n      const ok = _leafIsallArgResultExcess(ml, indexR, indexS, allArgs);\n      if (!ok) return false;\n    }\n\n    let indexA = readIndex(ml, argOnlyIsallOffset + OFFSET_C_A);\n    if (indexA === indexR)\n      indexA = readIndex(ml, argOnlyIsallOffset + OFFSET_C_B);\n\n    let indexB = readIndex(ml, argAndResultIsallOffset + OFFSET_C_A);\n    if (indexB === indexR)\n      indexB = readIndex(ml, argAndResultIsallOffset + OFFSET_C_B);\n\n    TRACE_MORPH(\n      'R = all?(R A), S = all?(R B)',\n      'S -> A, S -> B',\n      'when R is leaf'\n    );\n    TRACE(\n      ' - indexes;',\n      indexR,\n      '= all?(',\n      indexR,\n      indexA,\n      '),',\n      indexS,\n      '= all?(',\n      indexR,\n      indexB,\n      ')'\n    );\n    TRACE(\n      ' - domains;',\n      domain__debug(getDomain(indexR)),\n      '= all?(',\n      domain__debug(getDomain(indexR)),\n      domain__debug(getDomain(indexA)),\n      '),',\n      domain__debug(getDomain(indexS)),\n      '= all?(',\n      domain__debug(getDomain(indexR)),\n      indexB,\n      ')'\n    );\n\n    ml_cr2c2(\n      ml,\n      argOnlyIsallOffset,\n      argOnlyIsallOffset,\n      ML_IMP,\n      indexS,\n      indexA\n    );\n    ml_cr2c2(\n      ml,\n      argAndResultIsallOffset,\n      argAndResultIsallOffset,\n      ML_IMP,\n      indexS,\n      indexB\n    );\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE('_leafIsallArgResultMaybe');\n\n      const R = getDomain(indexR);\n      let nR = R;\n\n      // R = R &? A\n      if (force(indexA) === 0) {\n        TRACE(' - A is 0 so R cant be 1');\n        nR = domain_removeGtUnsafe(nR, 0);\n      } else {\n        // S = R &? B\n        const vS = force(indexS);\n        if (vS) {\n          TRACE(' - S>0 so R must be nonzero');\n          nR = domain_removeValue(nR, 0);\n        } else {\n          ASSERT(vS === 0);\n          if (force(indexB) > 0) {\n            TRACE(' - S=0 and B>0 so R must be zero');\n            nR = domain_removeGtUnsafe(nR, 0);\n          }\n        }\n      }\n\n      TRACE(' - final R:', domain__debug(nR));\n      ASSERT(nR);\n      if (R !== nR) setDomain(indexR, nR);\n    });\n\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexR);\n    bounty_markVar(bounty, indexS);\n    somethingChanged();\n\n    return true;\n  }\n\n  function _leafIsallArgResultExcess(ml, indexR, indexS, argsPerIsall) {\n    TRACE(' - _leafIsallArgResultExcess');\n\n    TRACE(\n      ' - collecting excess args now; indexR:',\n      indexR,\n      ', all args:',\n      argsPerIsall\n    );\n    // Collect all args except indexR and the first arg of the first two isalls, or second if first is indexR\n    // we need to recycle spaces for that\n    const toCompile = [];\n    for (let i = 0; i < argsPerIsall.length; ++i) {\n      const args = argsPerIsall[i];\n      TRACE('   -', i, '; isall args:', args);\n      let gotOne = i >= 2;\n      for (let j = 0; j < args.length; ++j) {\n        const index = args[j];\n        TRACE('     -', j, '; index:', index, index === indexR);\n        if (index !== indexR) {\n          if (!gotOne && j < 2) {\n            TRACE('       - skipped (compiled by caller)');\n            // Skip the first non-R for the first two isalls\n            gotOne = true;\n          } else {\n            TRACE('       - collected');\n            toCompile.push(index);\n          }\n        }\n      }\n    }\n\n    TRACE(' - excess args to compile in recycled spaces:', toCompile);\n\n    // There could potentially be no args to compile here. and that's okay.\n    const count = toCompile.length;\n    if (count) {\n      TRACE(' - found', count, 'extra args to compile:', toCompile);\n      // Start by collecting count recycled spaces\n      const bins = ml_getRecycleOffsets(ml, 0, count, SIZEOF_C_2);\n      if (!bins) {\n        TRACE(\n          ' - Was unable to find enough free space to fit',\n          count,\n          'IMPs, bailing'\n        );\n        return false;\n      }\n\n      let i = 0;\n      while (i < count) {\n        let currentOffset = bins.pop();\n        ASSERT(\n          ml_dec8(ml, currentOffset) === ML_JMP,\n          'should only get jumps here'\n        ); // Might trap a case where we clobber\n        let size = ml_getOpSizeSlow(ml, currentOffset);\n        ASSERT(size >= SIZEOF_C_2, 'this is what we asked for');\n        do {\n          const index = toCompile[i];\n          TRACE(\n            '  - compiling lte:',\n            indexS,\n            '->',\n            index,\n            '   =>    ',\n            domain__debug(getDomain(indexS, true)),\n            '->',\n            domain__debug(getDomain(index, true))\n          );\n\n          ml_any2c(\n            ml,\n            currentOffset,\n            ml_getOpSizeSlow(ml, currentOffset),\n            ML_IMP,\n            [indexS, index]\n          );\n\n          ++i;\n          size -= SIZEOF_C_2;\n          currentOffset += SIZEOF_C_2;\n        } while (size >= SIZEOF_C_2 && i < count);\n\n        if (process.env.NODE_ENV !== 'production') {\n          ml_validateSkeleton(ml); // Cant check earlier\n        }\n      }\n\n      TRACE(' - finished compiling extra args');\n    }\n\n    return true;\n  }\n\n  function _leafIsallArgResultOnly(ml, indexR, allArgs, offsets, R) {\n    TRACE(\n      ' - confirmed, all isalls have R as result _and_ arg; args:',\n      allArgs,\n      ', offsets:',\n      offsets\n    );\n    TRACE(' - R is a leaf and we eliminate all isalls associated to R');\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - leaf_isall_arg_result');\n\n      ASSERT(\n        domain_isBool(R),\n        'R was a bool (asserted above, and as leaf, that should not have changed)'\n      );\n      ASSERT(domain_isBool(getDomain(indexR)));\n\n      // If all args besides R are set, then R can be anything. otherwise R is 0.\n      // need to check this for all isalls. if any one causes R to be 0 then that's that.\n\n      let allSet = true;\n      for (let i = 0, len = allArgs.length; i < len; ++i) {\n        const args = allArgs[i];\n        for (let j = 0, len2 = args.length; j < len2; ++j) {\n          const index = args[j];\n          if (index !== indexR) {\n            const D = getDomain(index);\n            if (!domain_hasNoZero(D)) {\n              allSet = false; // Either it's zero or booly, either way set R to 0 and be done.\n            }\n          }\n        }\n\n        if (!allSet) {\n          TRACE(\n            ' - foundAsArg an isall where not all other args were set so forcing R to 0'\n          );\n          // Remember: R is a bool, asserted above. twice now. so this cant possibly fail. (watch it fail. sorry, future me!)\n          setDomain(indexR, domain_createValue(0));\n          break;\n        }\n      }\n\n      // Otherwise R kind of determines itself so no choice is made :)\n      TRACE(' - was R forced to 0?', !allSet);\n    });\n\n    TRACE(' - now marking vars and eliminating isall constraints');\n\n    for (let i = 0, len = offsets.length; i < len; ++i) {\n      const offset = offsets[i];\n      const args = allArgs[i];\n      TRACE('    - i=', i, ', offset=', offset, ', args=', args);\n      TRACE_MORPH(\n        'R = all?(R ...)',\n        '',\n        'if R only touches isalls on result _and_ arg then R is still a leaf'\n      );\n      ASSERT(\n        args.length === ml_dec16(ml, offset + 1),\n        'should be able to use this shortcut (not sure whether its actually faster tho)'\n      );\n      ml_eliminate(ml, offset, SIZEOF_C + args.length * 2 + 2);\n      for (let j = 0, len2 = args.length; j < len2; ++j) {\n        TRACE('      - marking', args[j]);\n        bounty_markVar(bounty, args[j]);\n      }\n    }\n\n    somethingChanged();\n\n    return true;\n  }\n\n  function leaf_islt(ml, offset, indexA, indexB, indexR, indexL) {\n    TRACE(\n      '   - leaf_islt;',\n      indexL,\n      'is a leaf var, R = A <? B,',\n      indexR,\n      '=',\n      indexA,\n      '<?',\n      indexB,\n      '  ->  ',\n      domain__debug(getDomain(indexR)),\n      '=',\n      domain__debug(getDomain(indexA)),\n      '<?',\n      domain__debug(getDomain(indexB))\n    );\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - leaf_islt');\n      TRACE(\n        ' - leaf index=',\n        indexL,\n        ';',\n        indexR,\n        '=',\n        indexA,\n        '<?',\n        indexB,\n        '  ->  ',\n        domain__debug(getDomain(indexR)),\n        '=',\n        domain__debug(getDomain(indexA)),\n        '<?',\n        domain__debug(getDomain(indexB))\n      );\n\n      let A = getDomain(indexA);\n      let B = getDomain(indexB);\n      let R = getDomain(indexR);\n\n      // R doesnt need to be booly...\n      if (domain_isBooly(R)) {\n        TRACE(' - R is booly, just force A and B and reflect the result in R');\n        const vA = force(indexA);\n        const vB = force(indexB);\n        if (vA < vB) R = domain_removeValue(R, 0);\n        else R = domain_removeGtUnsafe(R, 0);\n        setDomain(indexR, R);\n      } else if (domain_isZero(R)) {\n        TRACE(' - R=0 so force A>=B by setting A=maxA() and B=min(B)');\n\n        // There are complexities with edge cases so for now just take the easy road;\n        // assuming the problem was always solveable before; max(A) >= min(B)\n\n        A = domain_createValue(domain_max(A));\n        B = domain_createValue(domain_min(B));\n        TRACE('   - now ==>', domain__debug(A), '>=', domain__debug(B));\n\n        setDomain(indexA, A);\n        setDomain(indexB, B);\n      } else {\n        ASSERT(domain_hasNoZero(R));\n        TRACE(\n          ' - R>0 so force A<B ==>',\n          domain__debug(A),\n          '<',\n          domain__debug(B)\n        );\n\n        // There are complexities with edge cases so for now just take the easy road;\n        // assuming the problem was always solveable before; min(A) < max(B)\n\n        A = domain_createValue(domain_min(A));\n        B = domain_createValue(domain_max(B));\n        TRACE('   - now ==>', domain__debug(A), '>=', domain__debug(B));\n\n        setDomain(indexA, A);\n        setDomain(indexB, B);\n      }\n\n      TRACE(\n        ' - R:',\n        domain__debug(getDomain(indexR)),\n        '= A:',\n        domain__debug(getDomain(indexA)),\n        '< B:',\n        domain__debug(getDomain(indexB))\n      );\n\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexB));\n      ASSERT(getDomain(indexR));\n      ASSERT(!domain_isBooly(getDomain(indexR)));\n      ASSERT(\n        !domain_isZero(getDomain(indexR)) ===\n          domain_max(getDomain(indexA)) < domain_min(getDomain(indexB)),\n        'should hold constraint'\n      );\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_VVV);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n  }\n\n  function leaf_islte(ml, offset, indexA, indexB, indexR, indexL) {\n    TRACE(\n      '   - leaf_islte;',\n      indexL,\n      'is a leaf var, R = A <=? B,',\n      indexR,\n      '=',\n      indexA,\n      '<=?',\n      indexB,\n      '  ->  ',\n      domain__debug(getDomain(indexR)),\n      '=',\n      domain__debug(getDomain(indexA)),\n      '<=?',\n      domain__debug(getDomain(indexB))\n    );\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - leaf_islte');\n      TRACE(\n        ' - leaf index=',\n        indexL,\n        ';',\n        indexR,\n        '=',\n        indexA,\n        '<=?',\n        indexB,\n        '  ->  ',\n        domain__debug(getDomain(indexR)),\n        '=',\n        domain__debug(getDomain(indexA)),\n        '<=?',\n        domain__debug(getDomain(indexB))\n      );\n\n      let A = getDomain(indexA);\n      let B = getDomain(indexB);\n      let R = getDomain(indexR);\n\n      // R doesnt need to be booly...\n      if (domain_isBooly(R)) {\n        TRACE(' - R is booly, just force A and B and reflect the result in R');\n        const vA = force(indexA);\n        const vB = force(indexB);\n        if (vA <= vB) R = domain_removeValue(R, 0);\n        else R = domain_removeGtUnsafe(R, 0);\n        setDomain(indexR, R);\n      } else if (domain_isZero(R)) {\n        TRACE(' - R=0 so force A>=B by setting A=maxA() and B=min(B)');\n\n        // There are complexities with edge cases so for now just take the easy road;\n        // assuming the problem was always solveable before; max(A) > min(B)\n\n        A = domain_createValue(domain_max(A));\n        B = domain_createValue(domain_min(B));\n        TRACE('   - now ==>', domain__debug(A), '>', domain__debug(B));\n\n        setDomain(indexA, A);\n        setDomain(indexB, B);\n      } else {\n        ASSERT(domain_hasNoZero(R));\n        TRACE(\n          ' - R>0 so force A<=B ==>',\n          domain__debug(A),\n          '<=',\n          domain__debug(B)\n        );\n\n        // There are complexities with edge cases so for now just take the easy road;\n        // assuming the problem was always solveable before; min(A) <= max(B)\n\n        A = domain_createValue(domain_min(A));\n        B = domain_createValue(domain_max(B));\n        TRACE('   - now ==>', domain__debug(A), '<=', domain__debug(B));\n\n        setDomain(indexA, A);\n        setDomain(indexB, B);\n      }\n\n      TRACE(\n        ' - R:',\n        domain__debug(getDomain(indexR)),\n        '= A:',\n        domain__debug(getDomain(indexA)),\n        '<= B:',\n        domain__debug(getDomain(indexB))\n      );\n\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexB));\n      ASSERT(getDomain(indexR));\n      ASSERT(!domain_isBooly(getDomain(indexR)));\n      ASSERT(\n        !domain_isZero(getDomain(indexR)) ===\n          domain_max(getDomain(indexA)) <= domain_min(getDomain(indexB)),\n        'should hold constraint'\n      );\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_VVV);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n  }\n\n  function leaf_isnall(ml, offset, argCount, indexR, counts) {\n    TRACE(\n      '   - leaf_isnall;',\n      indexR,\n      'is a leaf var with counts:',\n      counts,\n      ', R = nall?(',\n      argCount,\n      'x ),',\n      indexR,\n      '= all?(...)'\n    );\n\n    const args = markAndCollectArgs(ml, offset, argCount);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - leaf_isnall');\n      TRACE(\n        '-',\n        indexR,\n        '= nall?(',\n        args,\n        ')  ->  ',\n        domain__debug(getDomain(indexR)),\n        ' = nall?(',\n        args.map(index => domain__debug(getDomain(index))),\n        ')'\n      );\n      let vR = 0;\n      for (let i = 0; i < argCount; ++i) {\n        if (force(args[i]) === 0) {\n          TRACE(' - found at least one arg that is zero so R>0');\n          vR = 1;\n          break;\n        }\n      }\n\n      const oR = getDomain(indexR);\n      const R = domain_resolveAsBooly(oR, vR);\n      setDomain(indexR, R);\n\n      ASSERT(getDomain(indexR));\n      ASSERT(\n        domain_hasNoZero(getDomain(indexR)) ===\n          args.some(index => domain_isZero(getDomain(index)))\n      );\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n  }\n\n  function leaf_issame(ml, offset, indexA, indexB, indexR, indexL) {\n    TRACE(\n      '   - leaf_issame; index',\n      indexL,\n      'is a leaf var, R = A ==? B,',\n      indexR,\n      '=',\n      indexA,\n      '==?',\n      indexB,\n      '  ->  ',\n      domain__debug(getDomain(indexR)),\n      '=',\n      domain__debug(getDomain(indexA)),\n      '==?',\n      domain__debug(getDomain(indexB))\n    );\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'for now argcount should be 2');\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - leaf_issame; leaf=',\n        indexL,\n        ';',\n        indexR,\n        '=',\n        indexA,\n        '==?',\n        indexB,\n        '  ->  ',\n        domain__debug(getDomain(indexR)),\n        '=',\n        domain__debug(getDomain(indexA)),\n        '==?',\n        domain__debug(getDomain(indexB))\n      );\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n      const AB = domain_intersection(A, B);\n      let R = getDomain(indexR);\n      TRACE(\n        ' - A:',\n        domain__debug(A),\n        ', B:',\n        domain__debug(B),\n        ', AB:',\n        domain__debug(AB),\n        ', solved?',\n        domain_isSolved(A),\n        domain_isSolved(B)\n      );\n      if (!domain_isSolved(R)) {\n        if (!AB) {\n          TRACE('   - A&B is empty so R=0');\n          R = domain_resolveAsBooly(R, false);\n        } else if (domain_isSolved(A)) {\n          TRACE('   - A is solved so R=A==B', A === B);\n          R = domain_resolveAsBooly(R, A === B);\n        } else if (domain_isSolved(B)) {\n          TRACE(\n            '   - B is solved and A wasnt. A&B wasnt empty so we can set A=B'\n          );\n          setDomain(indexA, B);\n          R = domain_resolveAsBooly(R, true);\n        } else {\n          TRACE(\n            '   - some values overlap between A and B and neither is solved.. force all'\n          );\n          const v = domain_min(AB);\n          const V = domain_createValue(v);\n          setDomain(indexA, V);\n          setDomain(indexB, V);\n          R = domain_resolveAsBooly(R, true);\n        }\n\n        TRACE(' - R is now', domain__debug(R));\n        ASSERT(R, 'leaf should at least have the resulting value');\n        setDomain(indexR, R);\n      } else if (domain_isZero(R)) {\n        TRACE(' - R=0 so make sure AB is empty');\n        if (AB) {\n          TRACE(' - it wasnt, making it so now');\n          if (domain_isSolved(A))\n            setDomain(indexB, domain_removeValue(B, domain_getValue(A)));\n          else setDomain(indexA, domain_removeValue(A, force(indexB)));\n        }\n      } else {\n        force(indexA, AB);\n        force(indexB, getDomain(indexA));\n      }\n\n      ASSERT(getDomain(indexR));\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexB));\n      ASSERT(!domain_isBooly(getDomain(indexR)));\n      ASSERT(\n        domain_isSolved(getDomain(indexA)) ||\n          domain_isSolved(getDomain(indexB)) ||\n          !domain_intersection(getDomain(indexA), getDomain(indexB)),\n        'either A or B is solved OR they have no intersecting values'\n      );\n      ASSERT(\n        Boolean(domain_intersection(getDomain(indexA), getDomain(indexB))) ===\n          !domain_isZero(getDomain(indexR))\n      );\n      ASSERT(\n        !domain_isZero(getDomain(indexR))\n          ? domain_isSolved(getDomain(indexA)) &&\n              domain_isSolved(getDomain(indexB))\n          : true,\n        'if R>0 then A and B must be solved'\n      );\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_CR_2);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n  }\n\n  function leaf_issome(ml, offset, indexR, argCount) {\n    TRACE(\n      '   - leaf_issome; index',\n      indexR,\n      'is a leaf var, R = some?(A B ...), index=',\n      indexR,\n      ', R=',\n      domain__debug(getDomain(indexR))\n    );\n    TRACE_MORPH('R = some(...)', '');\n\n    const args = markAndCollectArgs(ml, offset, argCount);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - leaf_issome');\n\n      let has = false;\n      for (let i = 0; i < args.length; ++i) {\n        const index = args[i];\n        if (force(index) > 0) {\n          has = true;\n          break;\n        }\n      }\n\n      let R = getDomain(indexR);\n      if (has) R = domain_removeValue(R, 0);\n      else R = domain_removeGtUnsafe(R, 0);\n\n      ASSERT(R, 'leaf should at least have the resulting value');\n      setDomain(indexR, R);\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n  }\n\n  function leaf_lt(ml, offset, indexA, indexB, leafSide) {\n    TRACE(\n      '   - leaf_lt;',\n      leafSide,\n      'is a leaf var, A < B,',\n      indexA,\n      '<',\n      indexB\n    );\n    ASSERT(typeof indexA === 'number', 'index A should be number', indexA);\n    ASSERT(typeof indexB === 'number', 'index B should be number', indexB);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - leaf_lt; solving',\n        indexA,\n        '<',\n        indexB,\n        '  ->  ',\n        domain__debug(getDomain(indexA)),\n        '<',\n        domain__debug(getDomain(indexB))\n      );\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n\n      const maxA = domain_max(A);\n      const minB = domain_min(B);\n\n      // Numdom([28,29]) < numdom([15,30])\n      TRACE(' - maxA >=? minB;', maxA, '>=', minB);\n\n      if (maxA < minB) {\n        TRACE(' - lt already fulfilled, no change required');\n      } else if (domain_min(A) >= minB) {\n        const vA = domain_min(A);\n        TRACE(\n          ' - min(A) still larger than min(B) so setting A to min(A)=',\n          vA,\n          ' and removing all LTE from B'\n        );\n        TRACE(\n          ' - so;',\n          domain__debug(A),\n          '=>',\n          domain__debug(domain_removeGtUnsafe(A, vA)),\n          'and',\n          domain__debug(B),\n          '=>',\n          domain__debug(domain_removeLte(B, vA))\n        );\n        setDomain(indexA, domain_removeGtUnsafe(A, vA));\n        setDomain(indexB, domain_removeLte(B, vA));\n      } else {\n        TRACE(' - removing >=min(B) from A');\n        setDomain(indexA, domain_removeGte(A, minB));\n      }\n\n      TRACE(\n        ' - result:',\n        domain__debug(getDomain(indexA)),\n        '<=',\n        domain__debug(getDomain(indexB))\n      );\n\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexB));\n      ASSERT(domain_max(getDomain(indexA)) < domain_min(getDomain(indexB)));\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    somethingChanged();\n  }\n\n  function leaf_lte(ml, offset, indexA, indexB, leafIsA) {\n    TRACE(\n      '   - leaf_lte;',\n      leafIsA ? 'A' : 'B',\n      'is a leaf var, A <= B,',\n      indexA,\n      '<=',\n      indexB\n    );\n    ASSERT(typeof indexA === 'number', 'index A should be number', indexA);\n    ASSERT(typeof indexB === 'number', 'index B should be number', indexB);\n\n    // Prune values that cant be a solution\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n    const minA = domain_min(A);\n    const maxB = domain_max(B);\n    const nA = domain_removeGtUnsafe(A, maxB);\n    const nB = domain_removeLtUnsafe(B, minA);\n    if (!nA || domain_isSolved(nA) || !nB || domain_isSolved(nB)) {\n      TRACE(' - lte can be solved by minimizer');\n      TRACE(\n        ' - either solved after pruning?',\n        domain__debug(nA),\n        domain__debug(nB)\n      );\n      TRACE(\n        nA ? '' : ' - A without max(B) is empty; A=',\n        domain__debug(A),\n        ', B=',\n        domain__debug(B),\n        ', max(B)=',\n        domain_max(B),\n        ', result:',\n        domain_removeGtUnsafe(A, maxB)\n      );\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    if (A !== nA) setDomain(indexA, nA);\n    if (B !== nB) setDomain(indexB, nB);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - leaf_lte; solving',\n        indexA,\n        '<=',\n        indexB,\n        '  ->  ',\n        domain__debug(getDomain(indexA)),\n        '<=',\n        domain__debug(getDomain(indexB)),\n        '  ->  ',\n        domain_max(getDomain(indexA)),\n        '<=',\n        domain_min(getDomain(indexB))\n      );\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n      const maxA = domain_max(A);\n      const minB = domain_min(B);\n\n      TRACE(' - maxA >? minB;', maxA, '>', minB);\n      if (maxA > minB) {\n        if (leafIsA) {\n          const nA = domain_removeGtUnsafe(A, minB);\n          TRACE('   - trimmed A down to', domain__debug(nA));\n          setDomain(indexA, nA);\n        } else {\n          const nB = domain_removeLtUnsafe(B, maxA);\n          TRACE('   - trimmed B down to', domain__debug(nB));\n          setDomain(indexB, nB);\n        }\n      }\n\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexB));\n      ASSERT(domain_max(getDomain(indexA)) <= domain_min(getDomain(indexB)));\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    somethingChanged();\n    return true;\n  }\n\n  function leaf_some_2(ml, offset, leafIndex, otherIndex, indexA, indexB) {\n    TRACE(\n      '   - leaf_some_2;',\n      leafIndex,\n      'is a leaf var, A | B,',\n      indexA,\n      '|',\n      indexB\n    );\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - leaf_some_2');\n      const A = getDomain(otherIndex);\n      const B = getDomain(leafIndex);\n      TRACE(\n        ' - solving',\n        indexA,\n        '|',\n        indexB,\n        '  ->  ',\n        domain__debug(A),\n        '|',\n        domain__debug(B)\n      );\n\n      // Check if either is solved to zero, in that case force the other to non-zero.\n      // if neither is zero and both have zero, force the leaf to non-zero.\n      // otherwise no change because OR will be satisfied.\n\n      if (domain_isZero(A)) {\n        TRACE(\n          ' - forcing the leaf index,',\n          leafIndex,\n          ', to non-zero because the other var is zero'\n        );\n        setDomain(leafIndex, domain_removeValue(B, 0));\n      } else if (domain_isZero(B)) {\n        TRACE(\n          ' - forcing the other index,',\n          otherIndex,\n          ', to non-zero because the leaf var was already zero'\n        );\n        setDomain(otherIndex, domain_removeValue(A, 0));\n      } else if (!domain_hasNoZero(A) && !domain_hasNoZero(A)) {\n        TRACE(\n          ' - neither was booly solved so forcing the leaf index,',\n          leafIndex,\n          ', to non-zero to satisfy the OR'\n        );\n        setDomain(leafIndex, domain_removeValue(B, 0));\n      } else {\n        TRACE(' - no change.');\n      }\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n    bounty_markVar(bounty, leafIndex);\n    bounty_markVar(bounty, otherIndex);\n    somethingChanged();\n  }\n\n  function leaf_sum_result(ml, offset, argCount, indexR) {\n    TRACE(\n      '   - leaf_sum_result;',\n      indexR,\n      'is a leaf var, R = sum(',\n      argCount,\n      'x ),',\n      indexR,\n      '= sum(...)'\n    );\n\n    const args = markAndCollectArgs(ml, offset, argCount);\n\n    TRACE('   - collected sum arg indexes;', args);\n    TRACE(\n      '   - collected sum arg domains;',\n      args.map(index => domain__debug(getDomain(index))).join(', ')\n    );\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - leaf_sum_result');\n      TRACE(' -', indexR, '= sum(', args, ')');\n      TRACE(\n        ' -',\n        domain__debug(getDomain(indexR)),\n        '= sum(',\n        args.map(index => domain__debug(getDomain(index))).join(', '),\n        ')'\n      );\n\n      let sum = 0;\n      for (let i = 0; i < args.length; ++i) {\n        const index = args[i];\n        const v = force(index);\n        sum += v;\n        TRACE(' - i=', i, ', index=', index, ', v=', v, ', sum now:', sum);\n      }\n\n      TRACE(' - total sum is', sum);\n      const R = domain_intersectionValue(getDomain(indexR), sum);\n      ASSERT(R, 'R should contain solution value');\n      setDomain(indexR, R);\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n    bounty_markVar(bounty, indexR); // Args already done in above loop\n    somethingChanged();\n  }\n\n  function leaf_xnor(ml, offset, leafIndex, otherIndex, indexA, indexB) {\n    TRACE(\n      '   - leaf_xnor;',\n      leafIndex,\n      'is a leaf var, A !^ B,',\n      indexA,\n      '!^',\n      indexB\n    );\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'should have 2 args');\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - leaf_xnor; solving',\n        indexA,\n        '!^',\n        indexB,\n        '  ->  ',\n        domain__debug(getDomain(indexA)),\n        '!^',\n        domain__debug(getDomain(indexB))\n      );\n\n      // Check if a var is solved to zero, if so solve the other var to zero as well\n      // check if a var is solved to non-zero, if so solve the other var to non-zero as well\n      // otherwise force(A), let B follow that result\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n      if (domain_isZero(A)) {\n        TRACE(' - forcing B to zero because A is zero');\n        setDomain(indexB, domain_removeGtUnsafe(B, 0));\n      } else if (domain_isZero(B)) {\n        TRACE(' - forcing A to zero because B is zero');\n        setDomain(indexA, domain_removeGtUnsafe(A, 0));\n      } else if (domain_hasNoZero(A)) {\n        TRACE(' - forcing B to non-zero because A is non-zero');\n        setDomain(indexB, domain_removeValue(B, 0));\n      } else if (domain_hasNoZero(B)) {\n        TRACE(' - forcing A to non-zero because B is non-zero');\n        setDomain(indexA, domain_removeValue(A, 0));\n      } else {\n        // TODO: force() and repeat above steps\n        TRACE(\n          ' - neither was booly solved. forcing both to non-zero',\n          domain__debug(domain_removeValue(A, 0)),\n          domain__debug(domain_removeValue(B, 0))\n        ); // Non-zero gives more options? *shrug*\n        setDomain(indexA, domain_removeValue(A, 0));\n        setDomain(indexB, domain_removeValue(B, 0));\n      }\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n    bounty_markVar(bounty, leafIndex);\n    bounty_markVar(bounty, otherIndex);\n    somethingChanged();\n  }\n\n  function leaf_xor(ml, offset, leafIndex, otherIndex, indexA, indexB) {\n    TRACE(\n      '   - leaf_xor;',\n      leafIndex,\n      'is a leaf var, A ^ B,',\n      indexA,\n      '^',\n      indexB\n    );\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - leaf_xor; solving',\n        indexA,\n        '^',\n        indexB,\n        '  ->  ',\n        domain__debug(getDomain(indexA)),\n        '^',\n        domain__debug(getDomain(indexB))\n      );\n\n      // Check if either is solved to zero, in that case force the other to non-zero.\n      // check if either side is non-zero. in that case force the other to zero\n      // confirm that both sides are booly-solved, force them to if not.\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n      if (domain_isZero(A)) {\n        TRACE(' - forcing B to non-zero because A is zero');\n        setDomain(indexB, domain_removeValue(B, 0));\n      } else if (domain_isZero(B)) {\n        TRACE(' - forcing A to non-zero because B was already zero');\n        setDomain(indexA, domain_removeValue(A, 0));\n      } else if (domain_hasNoZero(A)) {\n        TRACE(' - A was non-zero so forcing B to zero');\n        setDomain(indexB, domain_removeGtUnsafe(B, 0));\n      } else if (domain_hasNoZero(B)) {\n        TRACE(' - B was non-zero so forcing A to zero');\n        setDomain(indexA, domain_removeGtUnsafe(A, 0));\n      } else {\n        TRACE(\n          ' - neither was booly solved. forcing A to zero and B to non-zero'\n        );\n        setDomain(indexA, domain_removeValue(A, 0));\n        setDomain(indexB, domain_removeGtUnsafe(B, 0));\n      }\n    });\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n    bounty_markVar(bounty, leafIndex);\n    bounty_markVar(bounty, otherIndex);\n    somethingChanged();\n  }\n\n  // ##############\n\n  function desubset_diff(\n    ml,\n    diffOffset,\n    diffArgCount,\n    diffFirstIndex,\n    diffFirstIndexCounts\n  ) {\n    TRACE(\n      ' - desubset_diff; checking whether given DIFF at',\n      diffOffset,\n      'is entirely a smaller subset than another DIFF'\n    );\n    TRACE(\n      '   - argCount=',\n      diffArgCount,\n      ', indexA=',\n      diffFirstIndex,\n      ', diffFirstIndexCounts=',\n      diffFirstIndexCounts\n    );\n\n    // A diff can superset another diff\n    // a diff can superset-or-equal an isdiff and R=1 the isdiff\n    // a diff can subset-or-equal an issame and R=0 the issame\n\n    // both DIFFs must be ordered for this to work. but try to postpone sorting as much as possible (=expensive)\n    const sortedGivenDiff = false;\n\n    for (let i = 0; i < diffFirstIndexCounts; ++i) {\n      const offset = bounty_getOffset(bounty, diffFirstIndex, i);\n      if (offset !== diffOffset) {\n        const opCode = ml_dec8(ml, offset);\n        if (opCode === ML_DIFF) {\n          // Diff(ABC) ⊂ diff(ABCD)  then the bigger set can be removed\n          const argCount = ml_dec16(ml, offset + 1);\n          if (diffArgCount > argCount) {\n            // Only check if given DIFF has more args than current DIFF. always.\n            // first ensure both DIFF op args are ordered\n            if (!sortedGivenDiff)\n              dealiasAndSortArgs(ml, diffOffset, diffArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, offset, argCount, diffOffset, diffArgCount)) {\n              // Note: inverted args!\n              TRACE(\n                ' - deduped a DIFF subset of another DIFF! marking all args and eliminating the larger DIFF'\n              );\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of DIFF1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2);\n              return true;\n            }\n\n            TRACE(' - this diff was not a subset of the other diff');\n          }\n        } else if (opCode === ML_ISDIFF) {\n          // Diff(ABC) ⊆ R=diff?(ABCD)  then R=1 and isdiff dropped because the DIFF() will ensure it\n          const argCount = ml_dec16(ml, offset + 1);\n          if (diffArgCount >= argCount) {\n            // Only check if DIFF has >= args than ISDIFF\n            // first ensure both DIFF op args are ordered\n            if (!sortedGivenDiff)\n              dealiasAndSortArgs(ml, diffOffset, diffArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, offset, argCount, diffOffset, diffArgCount)) {\n              // Note: inverted args!\n              TRACE(\n                ' - deduped a DIFF subset of an ISDIFF! Setting R=1, marking all args, and eliminating the ISDIFF'\n              );\n              const indexR = readIndex(ml, offset + SIZEOF_C + argCount * 2);\n              TRACE(' - indexR=', indexR);\n              const R = getDomain(indexR);\n              const nR = domain_removeValue(R, 0);\n              if (R !== nR) setDomain(indexR, nR);\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of DIFF1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n              return true;\n            }\n\n            TRACE(' - this DIFF was not a subset of the ISDIFF');\n          }\n        } else if (opCode === ML_ISSAME) {\n          // DIFF(ABC) ⊆ R=SAME?(ABCD)  then R=0 and ISSAME dropped because the DIFF() _will_ negate it\n          const argCount = ml_dec16(ml, offset + 1);\n          if (diffArgCount <= argCount) {\n            // Only check if DIFF has fewer or equal args than ISSAME\n            // first ensure both DIFF op args are ordered\n            if (!sortedGivenDiff)\n              dealiasAndSortArgs(ml, diffOffset, diffArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, diffOffset, diffArgCount, offset, argCount)) {\n              TRACE(\n                ' - deduped a DIFF subset of an ISSAME! Setting R=0, marking all args, and eliminating the ISSAME'\n              );\n              const indexR = readIndex(ml, offset + SIZEOF_C + argCount * 2);\n              TRACE(' - indexR=', indexR);\n              const R = getDomain(indexR);\n              const nR = domain_removeGtUnsafe(R, 0);\n              if (R !== nR) setDomain(indexR, nR);\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of DIFF1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n              return true;\n            }\n\n            TRACE(' - this DIFF was not a subset of the ISSAME');\n          }\n        }\n      }\n    }\n\n    TRACE(' / desubset_diff');\n  }\n\n  function desubset_nall(\n    ml,\n    nallOffset,\n    nallArgCount,\n    nallFirstIndex,\n    nallFirstIndexCounts\n  ) {\n    TRACE(\n      ' - desubset_nall; checking whether given NALL at',\n      nallOffset,\n      'is entirely a smaller subset than another NALL'\n    );\n    TRACE(\n      '   - argCount=',\n      nallArgCount,\n      ', indexA=',\n      nallFirstIndex,\n      ', nallFirstIndexCounts=',\n      nallFirstIndexCounts\n    );\n\n    // A nall can subset another nall\n    // a nall can subset-or-equal an isnall and R=1 the isnall\n    // a nall can subset-or-equal an isall and R=0 the isnall\n\n    // both NALLs must be ordered for this to work. but try to postpone sorting as much as possible (=expensive)\n    const sortedGivenNall = false;\n\n    for (let i = 0; i < nallFirstIndexCounts; ++i) {\n      const offset = bounty_getOffset(bounty, nallFirstIndex, i);\n      if (offset !== nallOffset) {\n        const opCode = ml_dec8(ml, offset);\n        if (opCode === ML_NALL) {\n          // Nall(ABC) ⊂ nall(ABCD)  then the bigger set can be removed\n          const argCount = ml_dec16(ml, offset + 1);\n          if (nallArgCount < argCount) {\n            // Only check if given NALL has fewer args than current NALL. always.\n            // first ensure both NALL op args are ordered\n            if (!sortedGivenNall)\n              dealiasAndSortArgs(ml, nallOffset, nallArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, nallOffset, nallArgCount, offset, argCount)) {\n              TRACE(\n                ' - deduped a NALL subset of another NALL! marking all args and eliminating the larger NALL'\n              );\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of NALL1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2);\n              return true;\n            }\n\n            TRACE(' - this nall was not a subset of the other nall');\n          }\n        } else if (opCode === ML_ISNALL) {\n          // Nall(ABC) ⊆ R=nall?(ABCD)  then R=1 and isnall dropped because the NALL() will ensure it\n          const argCount = ml_dec16(ml, offset + 1);\n          if (nallArgCount <= argCount) {\n            // Only check if NALL has fewer or equal args than ISNALL\n            // first ensure both NALL op args are ordered\n            if (!sortedGivenNall)\n              dealiasAndSortArgs(ml, nallOffset, nallArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, nallOffset, nallArgCount, offset, argCount)) {\n              TRACE(\n                ' - deduped a NALL subset of an ISNALL! Setting R=1, marking all args, and eliminating the ISNALL'\n              );\n              const indexR = readIndex(ml, offset + SIZEOF_C + argCount * 2);\n              TRACE(' - indexR=', indexR);\n              const R = getDomain(indexR);\n              const nR = domain_removeValue(R, 0);\n              if (R !== nR) setDomain(indexR, nR);\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of NALL1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n              return true;\n            }\n\n            TRACE(' - this NALL was not a subset of the ISNALL');\n          }\n        } else if (opCode === ML_ISALL) {\n          // NALL(ABC) ⊆ R=ALL?(ABCD)  then R=0 and ISALL dropped because the NALL() _will_ negate it\n          const argCount = ml_dec16(ml, offset + 1);\n          if (nallArgCount <= argCount) {\n            // Only check if NALL has fewer or equal args than ISALL\n            // first ensure both NALL op args are ordered\n            if (!sortedGivenNall)\n              dealiasAndSortArgs(ml, nallOffset, nallArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, nallOffset, nallArgCount, offset, argCount)) {\n              TRACE(\n                ' - deduped a NALL subset of an ISALL! Setting R=0, marking all args, and eliminating the ISALL'\n              );\n              const indexR = readIndex(ml, offset + SIZEOF_C + argCount * 2);\n              TRACE(' - indexR=', indexR);\n              const R = getDomain(indexR);\n              const nR = domain_removeGtUnsafe(R, 0);\n              if (R !== nR) setDomain(indexR, nR);\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of NALL1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n              return true;\n            }\n\n            TRACE(' - this NALL was not a subset of the ISALL');\n          }\n        }\n      }\n    }\n  }\n\n  function desubset_some(\n    ml,\n    someOffset,\n    someArgCount,\n    someFirstIndex,\n    someFirstIndexCounts\n  ) {\n    TRACE(\n      ' - desubset_some; checking whether given SOME at',\n      someOffset,\n      'is entirely a smaller subset than another SOME'\n    );\n    TRACE(\n      '   - argCount=',\n      someArgCount,\n      ', indexA=',\n      someFirstIndex,\n      ', someFirstIndexCounts=',\n      someFirstIndexCounts\n    );\n\n    // A some can subset another some\n    // a some can subset-or-equal an issome and R=1 the issome\n    // a some can subset-or-equal an isnone and R=0 the isnone\n\n    // both SAME's must be ordered for this to work. but try to postpone sorting as much as possible (=expensive)\n    const sortedGivenSome = false;\n\n    for (let i = 0; i < someFirstIndexCounts; ++i) {\n      const offset = bounty_getOffset(bounty, someFirstIndex, i);\n      if (offset !== someOffset) {\n        const opCode = ml_dec8(ml, offset);\n        if (opCode === ML_SOME) {\n          // Some(ABC) ⊂ some(ABCD)  then the bigger set can be removed\n          const argCount = ml_dec16(ml, offset + 1);\n          if (someArgCount < argCount) {\n            // Only check if given SOME has fewer args than current SOME. always.\n            // first ensure both SOME op args are ordered\n            if (!sortedGivenSome)\n              dealiasAndSortArgs(ml, someOffset, someArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, someOffset, someArgCount, offset, argCount)) {\n              TRACE(\n                ' - deduped a SOME subset of another SOME! marking all args and eliminating the larger SOME'\n              );\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of SOME1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2);\n              somethingChanged();\n              return true;\n            }\n\n            TRACE(' - this SOME was not a subset of the other SOME');\n          }\n        } else if (opCode === ML_ISSOME) {\n          // Some(ABC) ⊆ R=some?(ABCD)  then R=1 and issome dropped because the SOME() will ensure it\n          const argCount = ml_dec16(ml, offset + 1);\n          if (someArgCount <= argCount) {\n            // Only check if SOME has fewer or equal args than ISSOME\n            // first ensure both SOME op args are ordered\n            if (!sortedGivenSome)\n              dealiasAndSortArgs(ml, someOffset, someArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, someOffset, someArgCount, offset, argCount)) {\n              TRACE(\n                ' - deduped a SOME subset of an ISSOME! Setting R=1, marking all args, and eliminating the ISSOME'\n              );\n              const indexR = readIndex(ml, offset + SIZEOF_C + argCount * 2);\n              TRACE(' - indexR=', indexR);\n              const R = getDomain(indexR);\n              const nR = domain_removeValue(R, 0);\n              if (R !== nR) setDomain(indexR, nR);\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of SOME1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n              somethingChanged();\n              return true;\n            }\n\n            TRACE(' - this some was not a subset of the issome');\n          }\n        } else if (opCode === ML_ISNONE) {\n          // SOME(ABC) ⊆ R=NONE?(ABCD)  then R=0 and ISNONE dropped because the SOME() _will_ negate it\n          const argCount = ml_dec16(ml, offset + 1);\n          if (someArgCount <= argCount) {\n            // Only check if SOME has fewer or equal args than ISNONE\n            // first ensure both SOME op args are ordered\n            if (!sortedGivenSome)\n              dealiasAndSortArgs(ml, someOffset, someArgCount);\n            dealiasAndSortArgs(ml, offset, argCount);\n            if (isSubset(ml, someOffset, someArgCount, offset, argCount)) {\n              TRACE(\n                ' - deduped a SOME subset of an ISNONE! Setting R=0, marking all args, and eliminating the ISNONE'\n              );\n              const indexR = readIndex(ml, offset + SIZEOF_C + argCount * 2);\n              TRACE(' - indexR=', indexR);\n              const R = getDomain(indexR);\n              const nR = domain_removeGtUnsafe(R, 0);\n              if (R !== nR) setDomain(indexR, nR);\n              markAllArgs(ml, offset, argCount); // Note: this also marks all args of SOME1 ;)\n              ml_eliminate(ml, offset, SIZEOF_C + argCount * 2 + 2);\n              somethingChanged();\n              return true;\n            }\n\n            TRACE(' - this SOME was not a subset of the ISNONE');\n          }\n        }\n      }\n    }\n  }\n\n  function isSubset(ml, someOffset1, argCount1, someOffset2, argCount2) {\n    // Now \"zip\" and confirm that all args in SOME1 are present by SOME2.\n    let pos1 = 0;\n    let pos2 = 0;\n    let index1 = ml_dec16(ml, someOffset1 + SIZEOF_C + pos1 * 2);\n    let index2 = 0;\n    while (pos2 < argCount2) {\n      index2 = ml_dec16(ml, someOffset2 + SIZEOF_C + pos2 * 2);\n      while (index1 === index2) {\n        ++pos1;\n        if (pos1 >= argCount1) {\n          return true;\n        }\n\n        index1 = ml_dec16(ml, someOffset1 + SIZEOF_C + pos1 * 2);\n      }\n\n      ++pos2;\n    }\n\n    return false;\n  }\n\n  function dealiasAndSortArgs(ml, offset, argCount) {\n    TRACE(\n      ' - dealiasAndSortArgs; sorting and dealiasing',\n      argCount,\n      'args starting at',\n      offset\n    );\n\n    // First de-alias all args\n    for (let i = 0; i < argCount; ++i) {\n      const argOffset = offset + SIZEOF_C + i * 2;\n      const actual = ml_dec16(ml, argOffset);\n      const alias = getAlias(actual);\n      if (actual !== alias) ml_enc16(ml, argOffset, alias);\n    }\n\n    // Now sort them\n    ml_heapSort16bitInline(ml, offset + SIZEOF_C, argCount);\n  }\n\n  // ##############\n\n  function trick_sum_to_nall(ml, offset, argCount, indexR) {\n    // [0 0 n-1 n-1]=sum([01] [01] [01]   =>   nall(...)\n    TRACE('   - trick_sum_to_nall');\n    TRACE_MORPH(\n      '[0 0 n-1 n-1]=sum(A:[01] B:[01] C:[01] ...)',\n      'nall(A B C ...)'\n    );\n    TRACE('   - indexR:', indexR, ', R:', domain__debug(getDomain(indexR)));\n    TRACE('   -', ml__debug(ml, offset, 1, problem));\n    ASSERT(\n      getDomain(indexR) === domain_createRange(0, argCount - 1) &&\n        domain_min(getDomain(indexR)) === 0 &&\n        domain_max(getDomain(indexR)) === argCount - 1\n    );\n\n    const args = markAndCollectArgs(ml, offset, argCount);\n    TRACE(\n      '   - args:',\n      args,\n      ', doms:',\n      args\n        .map(getDomain)\n        .map(domain__debug)\n        .join(', ')\n    );\n    ASSERT(args.map(getDomain).every(domain_isBool), 'all args should be bool');\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_sum_to_nall');\n      TRACE(' -', indexR, '= sum(', args, ')');\n      TRACE(\n        ' -',\n        domain__debug(getDomain(indexR)),\n        '= sum(',\n        args.map(index => domain__debug(getDomain(index))),\n        ')'\n      );\n\n      const R = getDomain(indexR);\n\n      TRACE(' - scan first');\n      let current = 0;\n      for (let i = 0; i < args.length; ++i) {\n        const index = args[i];\n        const D = getDomain(index);\n        const vD = domain_getValue(D);\n        if (vD >= 0) current += vD;\n      }\n\n      const vR = domain_min(domain_removeLtUnsafe(R, current)); // \"R must be at least the current sum of constant args\"\n      let remaining = vR - current;\n      TRACE(\n        ' - args that are solved currently sum to',\n        current,\n        ', R=',\n        domain__debug(R),\n        ', so there is',\n        remaining,\n        'to be added'\n      );\n\n      for (let i = 0; i < args.length; ++i) {\n        const index = args[i];\n        let D = getDomain(index);\n        if (!domain_isSolved(D)) {\n          if (remaining > 0) {\n            D = domain_removeValue(D, 0);\n            --remaining;\n          } else {\n            D = domain_removeValue(D, 1);\n          }\n\n          // SUM requires all args to solve. let them pick any value from what remains.\n          force(index, D);\n        }\n      }\n\n      setDomain(indexR, domain_intersectionValue(R, vR));\n\n      ASSERT(getDomain(indexR));\n      ASSERT(domain_isSolved(getDomain(indexR)));\n      ASSERT(\n        domain_getValue(getDomain(indexR)) ===\n          args.reduce((a, b) => a + force(b), 0)\n      );\n    });\n\n    // From sum to nall.\n    ml_cr2c(ml, offset, argCount, ML_NALL, args);\n    bounty_markVar(bounty, indexR); // Args already done in above loop\n    somethingChanged();\n  }\n\n  function trick_some_sum(ml, offset, argCount, indexR) {\n    // [1 1 n n]=sum([01] [01] [01]   ->   nall(...)\n    TRACE(\n      '   - trick_some_sum; [1 1 n n]=sum([01] [01] [01] ...) is actually a SOME',\n      indexR\n    );\n\n    const args = markAndCollectArgs(ml, offset, argCount);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_some_sum');\n      TRACE(\n        ' - some(A B);',\n        indexR,\n        '= sum(',\n        args,\n        ')  ->  ',\n        domain__debug(getDomain(indexR)),\n        '= sum(',\n        args.map(index => domain__debug(getDomain(index))),\n        ')'\n      );\n\n      // First make sure at least one arg is nonzero. for once if none already is.\n      let none = true;\n      let booly = -1;\n      for (let i = 0; i < argCount; ++i) {\n        const index = args[i];\n        const D = getDomain(index);\n        if (domain_hasNoZero(D)) {\n          none = false;\n          break;\n        }\n\n        if (!domain_isZero(D)) {\n          ASSERT(domain_isBooly(D));\n          booly = index;\n        }\n      }\n\n      if (none) {\n        ASSERT(booly >= 0);\n        let D = getDomain(booly);\n        D = domain_removeValue(D, 0);\n        setDomain(booly, D);\n        ASSERT(D);\n      }\n\n      // Now collect the sum. do it in a new loop because it's just simpler that way.\n      // force all the args because otherwise the sum might be violated\n      let sum = 0;\n      for (let i = 0; i < argCount; ++i) {\n        sum += force(args[i]);\n      }\n\n      // Set R to the sum of all constants\n      let R = getDomain(indexR);\n      R = domain_intersectionValue(R, sum);\n      setDomain(indexR, R);\n      ASSERT(R);\n    });\n\n    // From sum to some.\n    ml_enc8(ml, offset, ML_SOME);\n    ml_enc16(ml, offset + 1, argCount);\n    for (let i = 0; i < argCount; ++i) {\n      ml_enc16(ml, offset + SIZEOF_C + i * 2, args[i]);\n    }\n\n    ml_compileJumpSafe(ml, offset + SIZEOF_C + argCount * 2, 2); // Result var (16bit). for the rest some is same as sum\n    bounty_markVar(bounty, indexR); // Args already done in above loop\n    somethingChanged();\n  }\n\n  function trick_isall_ltelhs_1shared(ml, lteOffset, indexR, countsR) {\n    const indexS = readIndex(ml, lteOffset + OFFSET_C_B);\n\n    TRACE('trick_isall_ltelhs_1shared');\n    TRACE(' - with only R shared on an isall[2]:');\n    TRACE('   - R <= S, R = all?(A B)      =>      some(S | nall?(A B))');\n    TRACE(' - indexes:', indexR, '<=', indexS);\n    TRACE(' - domains:', getDomain(indexR), '<=', getDomain(indexS));\n    TRACE(\n      ' - metaFlags:',\n      bounty__debugMeta(bounty, indexR),\n      '<=',\n      bounty__debugMeta(bounty, indexS)\n    );\n\n    // The next asserts should have been verified by the bounty hunter, so they are only verified in ASSERTs\n    ASSERT(countsR === 2, 'R should be a leaf var with these two constraints');\n    ASSERT(countsR === getCounts(bounty, indexR), 'correct value?');\n    ASSERT(\n      getMeta(bounty, indexR) ===\n        (BOUNTY_FLAG_LTE_LHS | BOUNTY_FLAG_ISALL_RESULT),\n      'A be an lte lhs and isall result var'\n    );\n    ASSERT(ml_dec8(ml, lteOffset) === ML_LTE, 'lteOffset should be lte');\n    ASSERT(\n      ml_dec16(ml, lteOffset + OFFSET_C_A) === indexR,\n      'shared index should be lhs of lteOffset'\n    );\n\n    if (\n      !domain_isBool(getDomain(indexR, true)) ||\n      !domain_isBool(getDomain(indexS, true))\n    ) {\n      TRACE(' - R or S wasnt bool, bailing');\n      return false;\n    }\n\n    const offset1 = bounty_getOffset(bounty, indexR, 0);\n    const offset2 = bounty_getOffset(bounty, indexR, 1);\n    const isallOffset = offset1 === lteOffset ? offset2 : offset1;\n\n    ASSERT(ml_dec8(ml, isallOffset) === ML_ISALL);\n    ASSERT(readIndex(ml, isallOffset + OFFSET_C_R) === indexR);\n\n    if (ml_dec16(ml, isallOffset + 1) !== 2) {\n      TRACE(' - isall did not have 2 args, bailing');\n      return false;\n    }\n\n    const indexA = readIndex(ml, isallOffset + OFFSET_C_A);\n    const indexB = readIndex(ml, isallOffset + OFFSET_C_B);\n\n    if (\n      !domain_isBool(getDomain(indexA, true)) ||\n      !domain_isBool(getDomain(indexB, true))\n    ) {\n      TRACE(' - A or B wasnt bool, bailing');\n      return false;\n    }\n\n    TRACE_MORPH('R <= S, R = all?(A B)', 'S | nall?(A B)');\n\n    TRACE(' - change the isall to an isnall, change the LTE to an OR');\n\n    ml_cr2cr2(ml, isallOffset, 2, ML_ISNALL, indexA, indexB, indexR);\n    ml_c2c2(ml, lteOffset, 2, ML_SOME, indexR, indexS);\n\n    bounty_markVar(bounty, indexR);\n    bounty_markVar(bounty, indexS);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_isall_implhs_1shared(ml, impOffset, indexR, countsR) {\n    const indexS = readIndex(ml, impOffset + OFFSET_C_B);\n\n    TRACE('trick_isall_implhs_1shared');\n    TRACE(' - with only R shared on an isall[2]:');\n    TRACE('   - R -> S, R = all?(A B)      =>      some(S | nall?(A B))');\n    TRACE(' - indexes:', indexR, '<=', indexS);\n    TRACE(' - domains:', getDomain(indexR), '<=', getDomain(indexS));\n    TRACE(\n      ' - metaFlags:',\n      bounty__debugMeta(bounty, indexR),\n      '<=',\n      bounty__debugMeta(bounty, indexR)\n    );\n\n    // The next asserts should have been verified by the bounty hunter, so they are only verified in ASSERTs\n    ASSERT(countsR === 2, 'R should be a leaf var with these two constraints');\n    ASSERT(countsR === getCounts(bounty, indexR), 'correct value?');\n    ASSERT(\n      getMeta(bounty, indexR) ===\n        (BOUNTY_FLAG_IMP_LHS | BOUNTY_FLAG_ISALL_RESULT),\n      'A be an imp lhs and isall result var'\n    );\n    ASSERT(ml_dec8(ml, impOffset) === ML_IMP, 'impOffset should be imp');\n    ASSERT(\n      ml_dec16(ml, impOffset + OFFSET_C_A) === indexR,\n      'shared index should be lhs of impOffset'\n    );\n\n    if (\n      !domain_isBool(getDomain(indexR, true)) ||\n      !domain_isBool(getDomain(indexS, true))\n    ) {\n      TRACE(' - R or S wasnt bool, bailing');\n      return false;\n    }\n\n    const offset1 = bounty_getOffset(bounty, indexR, 0);\n    const offset2 = bounty_getOffset(bounty, indexR, 1);\n    const isallOffset = offset1 === impOffset ? offset2 : offset1;\n\n    ASSERT(ml_dec8(ml, isallOffset) === ML_ISALL);\n    ASSERT(readIndex(ml, isallOffset + OFFSET_C_R) === indexR);\n\n    if (ml_dec16(ml, isallOffset + 1) !== 2) {\n      TRACE(' - isall did not have 2 args, bailing');\n      return false;\n    }\n\n    if (\n      !domain_isBool(getDomain(indexA, true)) ||\n      !domain_isBool(getDomain(indexB, true))\n    ) {\n      TRACE(' - A or B wasnt bool, bailing');\n      return false;\n    }\n\n    TRACE_MORPH('R -> S, R = all?(A B)', 'S | nall?(A B)');\n\n    TRACE(' - change the isall to a nall, change the imp to an or');\n\n    const indexA = readIndex(ml, isallOffset + OFFSET_C_A);\n    const indexB = readIndex(ml, isallOffset + OFFSET_C_B);\n\n    ml_cr2cr2(ml, isallOffset, 2, ML_ISNALL, indexA, indexB, indexR);\n    ml_c2c2(ml, impOffset, 2, ML_SOME, indexR, indexS);\n\n    bounty_markVar(bounty, indexR);\n    bounty_markVar(bounty, indexS);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_isall_ltelhs_2shared(ml, lteOffset, indexR, countsR) {\n    const indexA = readIndex(ml, lteOffset + OFFSET_C_B);\n\n    TRACE('trick_isall_ltelhs_2shared');\n    TRACE(' - with R and an arg shared:');\n    TRACE('   - R <= A, R = all?(A B ...)      ->      R = all?(A B ...)');\n    TRACE('   - (the isall subsumes the lte, regardless of other constraints)');\n    // TRACE(' - with only R shared:');\n    // TRACE('   - R <= A, R = all?(B C)          ->      some(C nall?(A B))');\n    // TRACE('   - (when R is leaf, only A=1 B=1 C=0 is false)');\n    TRACE(' - indexes:', indexR, '<=', indexA);\n    TRACE(' - domains:', getDomain(indexR), '<=', getDomain(indexA));\n    TRACE(\n      ' - metaFlags:',\n      bounty__debugMeta(bounty, indexR),\n      '<=',\n      bounty__debugMeta(bounty, indexR)\n    );\n\n    // The next asserts should have been verified by the bounty hunter, so they are only verified in ASSERTs\n    ASSERT(\n      countsR > 1,\n      'the indexR should be part of at least two constraints'\n    );\n    ASSERT(countsR === getCounts(bounty, indexR), 'correct value?');\n    ASSERT(\n      hasFlags(\n        getMeta(bounty, indexR),\n        BOUNTY_FLAG_LTE_LHS | BOUNTY_FLAG_ISALL_RESULT\n      ),\n      'A must at least be an lte lhs and isall result var'\n    );\n    ASSERT(ml_dec8(ml, lteOffset) === ML_LTE, 'lteOffset should be lte');\n    ASSERT(\n      ml_dec16(ml, lteOffset + OFFSET_C_A) === indexR,\n      'shared index should be lhs of lteOffset'\n    );\n\n    const toCheck = Math.min(countsR, BOUNTY_MAX_OFFSETS_TO_TRACK);\n\n    // Note: it's not guaranteed that we'll actually see an isall in this loop\n    // if countsR is higher than the max number of offsets tracked by bounty\n    // in that case nothing happens and the redundant constraint persists. no biggie\n    for (let i = 0; i < toCheck; ++i) {\n      TRACE(\n        '   - fetching #',\n        i,\n        '/',\n        toCheck,\n        '(',\n        countsR,\n        '||',\n        BOUNTY_MAX_OFFSETS_TO_TRACK,\n        ')'\n      );\n      const offset = bounty_getOffset(bounty, indexR, i);\n      TRACE('   - #' + i, ', offset =', offset);\n      if (offset !== lteOffset) {\n        const op = ml_dec8(ml, offset);\n        if (op === ML_ISALL) {\n          if (_trick_isall_ltelhs_2shared(lteOffset, offset, indexR, indexA))\n            return true;\n        }\n      }\n    }\n\n    TRACE(' - trick_isall_ltelhs_2shared changed nothing');\n    return false;\n  }\n\n  function _trick_isall_ltelhs_2shared(lteOffset, isallOffset, indexR, indexA) {\n    // R <= A, R = all?(A B C ...)    =>     R = all?(A B C ...)   (drop lte)\n    // need to search the isall for the A arg here\n    ASSERT(ml_dec8(ml, isallOffset) === ML_ISALL, 'should be isall');\n\n    const argCount = ml_dec16(ml, isallOffset + 1);\n    const indexS = readIndex(ml, isallOffset + SIZEOF_C + argCount * 2);\n    TRACE(\n      '     - isall with an argCount of',\n      argCount,\n      ', indexR=',\n      indexS,\n      '=indexR=',\n      indexR,\n      'cross checking all args to match',\n      indexA\n    );\n    ASSERT(indexS === indexR, 'R should (at least) be result of isall');\n\n    // Scan for any arg index == A\n    for (let i = 0; i < argCount; ++i) {\n      const argIndex = readIndex(ml, isallOffset + SIZEOF_C + i * 2);\n      if (argIndex === indexA) {\n        TRACE_MORPH(\n          'R <= A, R = all?(A ...)',\n          'R = all?(A ...)',\n          'The isall subsumes the lte'\n        );\n        TRACE(\n          '     - arg index is indexA, match. this is R <= A, R = all?(A ...) so eliminate the lte'\n        );\n        ml_eliminate(ml, lteOffset, SIZEOF_C_2);\n        bounty_markVar(bounty, indexR);\n        bounty_markVar(bounty, indexA);\n        somethingChanged();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function trick_implhs_isall_2shared(ml, impOffset, indexA, countsA) {\n    TRACE(\n      'trick_implhs_isall_2shared',\n      indexA,\n      'at',\n      impOffset,\n      'metaFlags:',\n      bounty__debugMeta(bounty, indexA),\n      '`S -> A, S = all?(A B ...)   ->   S = all?(A B ...)`'\n    );\n    TRACE(\n      ' - imp:',\n      indexA,\n      '->',\n      readIndex(ml, impOffset + OFFSET_C_B),\n      '  =>  ',\n      domain__debug(getDomain(indexA, true)),\n      '->',\n      domain__debug(getDomain(readIndex(ml, impOffset + OFFSET_C_B), true))\n    );\n    TRACE('   - S -> A, S = all?(A B)   =>   S = all?(A B)');\n    TRACE(\n      '   - (the isall subsumes the implication, regardless of other constraints)'\n    );\n\n    // The next asserts should have been verified by the bounty hunter, so they are only verified in ASSERTs\n    ASSERT(\n      countsA > 1,\n      'the indexA should only be part of two constraints',\n      countsA,\n      bounty__debugMeta(bounty, indexA)\n    );\n    ASSERT(\n      countsA === getCounts(bounty, indexA),\n      'correct value?',\n      countsA === getCounts(bounty, indexA)\n    );\n    ASSERT(\n      hasFlags(\n        getMeta(bounty, indexA),\n        BOUNTY_FLAG_IMP_LHS | BOUNTY_FLAG_ISALL_RESULT\n      ),\n      'A must at least be an imp lhs and isall result var'\n    );\n    ASSERT(\n      ml_dec8(ml, impOffset) === ML_IMP,\n      'impOffset should be imp',\n      ml__opName(ml_dec8(ml, impOffset))\n    );\n    ASSERT(\n      ml_dec16(ml, impOffset + OFFSET_C_A) === indexA,\n      'shared index should be lhs of impOffset'\n    );\n\n    const indexB = readIndex(ml, impOffset + OFFSET_C_B);\n\n    const toCheck = Math.min(countsA, BOUNTY_MAX_OFFSETS_TO_TRACK);\n\n    // Note: it's not guaranteed that we'll actually see an isall in this loop\n    // if countsA is higher than the max number of offsets tracked by bounty\n    // in that case nothing happens and the redundant constraint persists. no biggie\n    for (let i = 0; i < toCheck; ++i) {\n      TRACE(\n        '   - fetching #',\n        i,\n        '/',\n        toCheck,\n        '(',\n        countsA,\n        '|',\n        BOUNTY_MAX_OFFSETS_TO_TRACK,\n        ')'\n      );\n      const offset = bounty_getOffset(bounty, indexA, i);\n      TRACE('   - #' + i, ', offset =', offset);\n      if (offset !== impOffset) {\n        const op = ml_dec8(ml, offset);\n        if (op === ML_ISALL) {\n          TRACE(' - Found the isall...');\n          if (_trick_implhs_isall_2shared(impOffset, offset, indexA, indexB))\n            return true;\n        }\n      }\n    }\n\n    TRACE(' - end of trick_implhs_isall_2shared');\n    return false;\n  }\n\n  function _trick_implhs_isall_2shared(impOffset, isallOffset, indexA, indexB) {\n    // A -> B, A = all?(B C D ...)     =>    drop imp\n    TRACE(\n      ' - _trick_implhs_isall_2shared; A -> B, A = all?(B C D ...)    =>    drop imp'\n    );\n\n    ASSERT(ml_dec8(ml, isallOffset) === ML_ISALL, 'should be isall');\n    // TRACE(ml__debug(ml, isallOffset, 1, problem, true));\n    const argCount = ml_dec16(ml, isallOffset + 1);\n    const indexR = readIndex(ml, isallOffset + SIZEOF_C + argCount * 2);\n    TRACE(\n      '     - isall with an argCount of',\n      argCount,\n      ', indexR=',\n      indexR,\n      '=indexA=',\n      indexA,\n      ', cross-checking all args to match',\n      indexB\n    );\n    ASSERT(indexA === indexR, 'A should be R, should be asserted by bounty');\n\n    // Scan for any arg index == B\n    for (let i = 0; i < argCount; ++i) {\n      const argIndex = readIndex(ml, isallOffset + SIZEOF_C + i * 2);\n      if (argIndex === indexB) {\n        TRACE_MORPH(\n          'R -> A, R = all?(A ...)',\n          'R = all?(A ...)',\n          'The isall subsumes the implication'\n        );\n        TRACE(\n          '     - arg index is indexB, match. this is R -> A, R = all?(A ...) so eliminate the imp'\n        );\n        ml_eliminate(ml, impOffset, SIZEOF_C_2);\n        bounty_markVar(bounty, indexA);\n        bounty_markVar(bounty, indexB);\n        somethingChanged();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function trick_isall_lterhs_entry(indexS, lteOffset, counts) {\n    // A <= S, S = all?(B C...)    ->    A <= B, A <= C\n\n    const offset1 = bounty_getOffset(bounty, indexS, 0);\n    const offset2 = bounty_getOffset(bounty, indexS, 1);\n    TRACE(\n      'trick_isall_lterhs_entry; ',\n      indexS,\n      'at',\n      lteOffset,\n      '->',\n      offset1,\n      offset2,\n      '` A <= S, S = all?(B C...)    ->    A <= B, A <= C`'\n    );\n    ASSERT(\n      lteOffset === offset1 || lteOffset === offset2,\n      'expecting current offset to be one of the two offsets found',\n      lteOffset,\n      indexS\n    );\n\n    const isallOffset = lteOffset === offset1 ? offset2 : offset1;\n\n    // This stuff should have been checked by the bounty hunter, so we tuck them in ASSERTs\n    ASSERT(ml_dec8(ml, lteOffset) === ML_LTE, 'lteOffset should be an lte');\n    ASSERT(\n      ml_dec8(ml, isallOffset) === ML_ISALL,\n      'isall offset should be either isall op'\n    );\n    ASSERT(\n      getMeta(bounty, indexS) ===\n        (BOUNTY_FLAG_LTE_RHS | BOUNTY_FLAG_ISALL_RESULT),\n      'kind of redundant, but this is what bounty should have yielded for this var'\n    );\n    ASSERT(counts === 2, 'S should only appear in two constraints');\n    ASSERT(\n      (ml_dec8(ml, isallOffset) === ML_ISALL\n        ? readIndex(\n            ml,\n            isallOffset + SIZEOF_C + ml_dec16(ml, isallOffset + 1) * 2\n          )\n        : readIndex(ml, isallOffset + 5)) === indexS,\n      'S should the result of the isall'\n    );\n\n    // We can replace an isall and lte with ltes on the args of the isall\n    // A <= S, S = isall(C D)   ->    A <= C, A <= D\n\n    // note that A amust be strict bool and A must have a 0 for this to be safe. S is our shared var here.\n    // [01] <= [01], [01] = isall(....)\n\n    // if you dont apply this condition:\n    // [0 0 5 5 9 9] <= [0 0 9 9], [0 0 9 9] = isall([55], [66])\n    // after the morph A _must_ be 0 or 5 while before it could also be 9.\n\n    const indexA = readIndex(ml, lteOffset + OFFSET_C_A);\n    const A = getDomain(indexA, true);\n    ASSERT(\n      indexS === readIndex(ml, lteOffset + OFFSET_C_B),\n      'S should be rhs of lte'\n    );\n    const S = getDomain(indexS, true);\n\n    // Mostly A will be [01] but dont rule out valid cases when A=0 or A=1\n    // A or C (or both) MUST be boolean bound or this trick may be bad (A=100,S=100,C=1,D=1 -> 100<=10,100<=10 while it should pass)\n\n    if (domain_max(A) > 1 && domain_max(S) > 1) {\n      TRACE(\n        ' - neither A nor S was boolean bound, bailing',\n        domain__debug(A),\n        domain__debug(S)\n      );\n      return false;\n    }\n\n    if (domain_hasNoZero(S)) {\n      // (dead code because minifier should eliminate an isall when R>=1)\n      TRACE(\n        '- S has no zero which it would need to reflect any solution as a leaf, bailing',\n        domain__debug(S)\n      );\n      // (unless the isall was already solved, but the minimizer should take care of that)\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    if (domain_max(A) > domain_max(S)) {\n      // (dead code because minifier should eliminate an isall when R=0)\n      TRACE(\n        ' - max(A) > max(S) so there is a value in A that S couldnt satisfy A<=S so we must bail',\n        domain__debug(A),\n        domain__debug(S)\n      );\n      // We can only trick if S can represent any valuation of A and there is a reject possible so no\n      // note that this shouldnt happen when the minimizer runs to the max, but could in single cycle mode\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    TRACE(\n      ' - A and S are okay proceeding with morph, A:',\n      domain__debug(A),\n      'S:',\n      domain__debug(S)\n    );\n\n    ASSERT(\n      ml_dec8(ml, isallOffset) === ML_ISALL,\n      'bounty should have asserted this'\n    );\n\n    const argCount = ml_dec16(ml, isallOffset + 1);\n    TRACE(\n      ' - an isall starting at',\n      isallOffset,\n      'and has',\n      argCount,\n      'args; rewriting A <= S, S=isall(X Y Z ...)  ->  A <= X, A <= Y, A <= Z, ...'\n    );\n\n    const maxA = domain_max(A);\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, isallOffset + SIZEOF_C + i * 2);\n      const domain = getDomain(index, true);\n      if (domain_max(domain) < maxA) {\n        TRACE(\n          ' - there is an isall arg whose max is lower than max(A), this leads to a lossy morph so we must bail',\n          i,\n          index,\n          domain__debug(domain),\n          '<',\n          domain__debug(A)\n        );\n        return false;\n      }\n    }\n\n    if (argCount < 2) {\n      TRACE(\n        ' - argcount < 2, so a bug or an alias. ignoring that here. bailing'\n      );\n      return false;\n    }\n\n    // First encode the isall args beyond the second one (if any) into recycled spaces\n    if (argCount > 2) {\n      const proceed = trick_isall_lterhs_entry_excess(\n        ml,\n        isallOffset,\n        argCount,\n        indexA,\n        isallArgs\n      );\n      if (!proceed) return false;\n    }\n\n    // Now morph the first two args into the existing lte and isall (of same size)\n    const indexX = readIndex(ml, isallOffset + OFFSET_C_A);\n    const indexY = readIndex(ml, isallOffset + OFFSET_C_B);\n\n    TRACE(\n      ' -  A <= S, S=isall(X Y, ...(already done the rest))   ->    A <= X, A <= Y'\n    );\n\n    // Must mark all affected vars. their bounty data is probably obsolete now.\n    // (collect the isall before morphing it!)\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexS);\n    const isallArgs = markAndCollectArgs(ml, isallOffset, argCount);\n    ASSERT(isallArgs[0] === indexX, 'x should be collected');\n    ASSERT(isallArgs[1] === indexY, 'y should be collected');\n\n    TRACE(\n      ' - isall args:',\n      isallArgs,\n      ', and from the lte A=',\n      indexA,\n      ', S=',\n      indexS\n    );\n\n    // Compile A<=left and A<=right over the existing two offsets\n    ml_c2c2(ml, lteOffset, 2, ML_LTE, indexA, indexX);\n    ml_cr2c2(ml, isallOffset, 2, ML_LTE, indexA, indexY);\n\n    TRACE(\n      '   - deferring',\n      indexS,\n      'will be gt',\n      indexA,\n      'and the result of an isall'\n    );\n    solveStack.push((_, force, getDomain, setDomain) => {\n      // Note: we cut out indexS so that's what we restore here!\n      TRACE(' - trick_isall_lterhs_entry; patching index', indexS);\n      TRACE(\n        '   -',\n        indexA,\n        '<=',\n        indexS,\n        '  ->  ',\n        domain__debug(getDomain(indexA)),\n        '<=',\n        domain__debug(getDomain(indexS))\n      );\n      TRACE(\n        '   -',\n        indexS,\n        '= all?(',\n        isallArgs,\n        ')  ->  ',\n        domain__debug(getDomain(indexS)),\n        '= all?(',\n        isallArgs.map(index => domain__debug(getDomain(index))),\n        ')'\n      );\n\n      let S = getDomain(indexS);\n      const A = getDomain(indexA);\n\n      // Was A <= S so S can't contain any value lower than max(A)\n      S = domain_removeLtUnsafe(S, domain_max(A));\n      ASSERT(S, 'should not be empty here');\n\n      // Was S = isall(X Y ...args) so force any arg that is not yet booly-solved until we find one that's 0\n      let someZero = false;\n      for (let i = 0; i < isallArgs.length; ++i) {\n        const D = getDomain(isallArgs[i]);\n        if (domain_isZero(D) || (!domain_hasNoZero(S) && force(D) === 0)) {\n          TRACE(\n            '  - index',\n            isallArgs[i],\n            'was',\n            domain__debug(D),\n            'now',\n            domain__debug(getDomain(isallArgs[i])),\n            ', ends up zero so it fails the isall so S must be 0'\n          );\n          // Either D was already zero, or it was booly and then forced to zero. it fails the isall so S=0\n          someZero = true;\n          break;\n        }\n      }\n\n      TRACE(' -', someZero ? 'at least one' : 'no', 'arg was found to be zero');\n      if (someZero) {\n        S = domain_removeGtUnsafe(S, 0);\n      } else {\n        S = domain_removeValue(S, 0);\n      }\n\n      ASSERT(S, 'S should not be empty here');\n      setDomain(indexS, S);\n    });\n\n    somethingChanged();\n    return true;\n  }\n\n  function trick_isall_lterhs_entry_excess(ml, isallOffset, argCount, indexA) {\n    // Isall has four or more args\n    // A <= S, S=isall(X Y Z ...)  ->  A <= X, A <= Y, A <= Z, ...\n    // note: this function only compiles the args from Z (the third isall arg) onward\n    TRACE(\n      ' - trick_isall_lterhs_entry_excess. Attempting to recycle space to stuff',\n      argCount - 2,\n      'lte constraints'\n    );\n    ASSERT(\n      argCount > 2,\n      'this function should only be called for 4+ isall args'\n    );\n\n    // We have to recycle some space now. we wont know whether we can\n    // actually do the morph until we've collected enough space for it.\n\n    // we'll use lteOffset and isallOffset to compile the last 2 args so only need space for the remaining ones\n    const toRecycle = argCount - 2;\n\n    // Start by collecting toRecycle recycled spaces\n    const bins = ml_getRecycleOffsets(ml, 0, toRecycle, SIZEOF_C_2);\n    if (!bins) {\n      TRACE(\n        ' - Was unable to find enough free space to fit',\n        argCount,\n        'ltes, bailing'\n      );\n      return false;\n    }\n\n    TRACE(\n      ' - Found',\n      bins.length,\n      'jumps (',\n      bins,\n      ') which can host (at least)',\n      toRecycle,\n      'lte constraints. Compiling them now'\n    );\n\n    // Okay, now we'll morph. be careful about clobbering existing indexes... start with\n    // last address to make sure jumps dont clobber existing jump offsets in the bin\n\n    let i = 0;\n    while (i < toRecycle) {\n      let currentOffset = bins.pop();\n      ASSERT(\n        ml_dec8(ml, currentOffset) === ML_JMP,\n        'should only get jumps here'\n      ); // Might trap a case where we clobber\n      let size = ml_getOpSizeSlow(ml, currentOffset);\n      ASSERT(size >= SIZEOF_C_2, 'this is what we asked for');\n      do {\n        const indexB = readIndex(ml, isallOffset + SIZEOF_C + (i + 2) * 2); // Note: i+2 because we skip the first two args. they are done by caller\n        TRACE(\n          '  - compiling lte:',\n          indexA,\n          '<=',\n          indexB,\n          ' -> ',\n          domain__debug(getDomain(indexA, true)),\n          '<=',\n          domain__debug(getDomain(indexB, true))\n        );\n\n        ml_enc8(ml, currentOffset, ML_LTE);\n        ml_enc16(ml, currentOffset + 1, 2);\n        ml_enc16(ml, currentOffset + OFFSET_C_A, indexA);\n        ml_enc16(ml, currentOffset + OFFSET_C_B, indexB);\n\n        ++i;\n        size -= SIZEOF_C_2;\n        currentOffset += SIZEOF_C_2;\n      } while (size >= SIZEOF_C_2 && i < toRecycle);\n\n      if (size) ml_compileJumpSafe(ml, currentOffset, size);\n      if (process.env.NODE_ENV !== 'production') {\n        ml_validateSkeleton(ml); // Cant check earlier\n      }\n    }\n\n    return true;\n  }\n\n  function trick_imprhs_isall_entry(indexS, impOffset, countsS, indexA) {\n    // A -> S, S = all?(B C...)    =>    A -> B, A -> C\n\n    const offset1 = bounty_getOffset(bounty, indexS, 0);\n    const offset2 = bounty_getOffset(bounty, indexS, 1);\n    TRACE(\n      'trick_imprhs_isall_entry; ',\n      indexS,\n      'at',\n      impOffset,\n      '=>',\n      offset1,\n      offset2,\n      '`; A -> S, S = all?(B C...)    =>    A -> B, A -> C`'\n    );\n    ASSERT(\n      impOffset === offset1 || impOffset === offset2,\n      'expecting current offset to be one of the two offsets found',\n      impOffset,\n      indexS\n    );\n\n    const isallOffset = impOffset === offset1 ? offset2 : offset1;\n\n    // This stuff should have been checked by the bounty hunter, so we tuck them in ASSERTs\n    ASSERT(ml_dec8(ml, impOffset) === ML_IMP, 'impOffset should be an imp');\n    ASSERT(\n      ml_dec8(ml, isallOffset) === ML_ISALL,\n      'isall offset should be either isall op'\n    );\n    ASSERT(\n      getMeta(bounty, indexS) ===\n        (BOUNTY_FLAG_IMP_RHS | BOUNTY_FLAG_ISALL_RESULT),\n      'kind of redundant, but this is what bounty should have yielded for this var'\n    );\n    ASSERT(countsS === 2, 'S should only appear in two constraints');\n    ASSERT(\n      (ml_dec8(ml, isallOffset) === ML_ISALL\n        ? readIndex(\n            ml,\n            isallOffset + SIZEOF_C + ml_dec16(ml, isallOffset + 1) * 2\n          )\n        : readIndex(ml, isallOffset + 5)) === indexS,\n      'S should the result of the isall'\n    );\n    ASSERT(\n      readIndex(ml, impOffset + OFFSET_C_A) === indexA,\n      'A should be lhs of IMP'\n    );\n\n    // We can replace an isall and IMP with IMPs on the args of the isall\n    // A -> S, S = isall(C D)    =>     A -> C, A -> D\n\n    // note that A must be strict bool and A must have a 0 for this to be safe. S is our shared var here.\n    // [01] -> [01], [01] = isall(....)\n\n    // if you dont apply this condition:\n    // [0 0 5 5 9 9] -> [0 0 9 9], [0 0 9 9] = isall([55], [66])\n    // after the morph A _must_ be 0 or 5 while before it could also be 9.\n\n    const A = getDomain(indexA, true);\n    ASSERT(\n      indexS === readIndex(ml, impOffset + OFFSET_C_B),\n      'S should be rhs of IMP'\n    );\n    const S = getDomain(indexS, true);\n\n    // Mostly A will be [01] but dont rule out valid cases when A=0 or A=1\n\n    if (domain_max(A) > 1 && domain_max(S) > 1) {\n      TRACE(\n        ' - neither A nor S was boolean bound, bailing',\n        domain__debug(A),\n        domain__debug(S)\n      );\n      return false;\n    }\n\n    if (domain_hasNoZero(S)) {\n      // (dead code because minifier should eliminate an isall when R>=1)\n      TRACE(\n        '- S has no zero which it would need to reflect any solution as a leaf, bailing',\n        domain__debug(S)\n      );\n      // (unless the isall was already solved, but the minimizer should take care of that)\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    if (domain_max(A) > domain_max(S)) {\n      // (dead code because minifier should eliminate an isall when R=0)\n      TRACE(\n        ' - max(A) > max(S) so there is a value in A that S couldnt satisfy A->S so we must bail',\n        domain__debug(A),\n        domain__debug(S)\n      );\n      // We can only trick if S can represent any valuation of A and there is a reject possible so no\n      // note that this shouldnt happen when the minimizer runs to the max, but could in single cycle mode\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    TRACE(\n      ' - A and S are okay proceeding with morph, ',\n      domain__debug(A),\n      '->',\n      domain__debug(S)\n    );\n\n    ASSERT(\n      ml_dec8(ml, isallOffset) === ML_ISALL,\n      'bounty should have asserted this'\n    );\n\n    const argCount = ml_dec16(ml, isallOffset + 1);\n    TRACE(\n      ' - an isall starting at',\n      isallOffset,\n      'and has',\n      argCount,\n      'args; rewriting A -> S, S=isall(X Y Z ...)  =>  A -> X, A -> Y, A -> Z, ...'\n    );\n\n    if (argCount < 2) {\n      TRACE(\n        ' - argcount < 2, so a bug or an alias. ignoring that here. bailing'\n      );\n      requestAnotherCycle = true; // Minifier should tear this down\n      return false;\n    }\n\n    // First encode the isall args beyond the second one (if any) into recycled spaces\n    if (argCount > 2) {\n      const proceed = trick_imprhs_isall_entry_excess(\n        ml,\n        isallOffset,\n        argCount,\n        indexA,\n        isallArgs\n      );\n      if (!proceed) return false;\n    }\n\n    // Now morph the first two args into the existing IMP and isall (of same size)\n    const indexX = readIndex(ml, isallOffset + OFFSET_C_A);\n    const indexY = readIndex(ml, isallOffset + OFFSET_C_B);\n\n    TRACE(\n      ' -  A -> S, S=isall(X Y, ...(already done the rest))   =>    A -> X, A -> Y'\n    );\n\n    // Must mark all affected vars. their bounty data is probably obsolete now.\n    // (collect the isall before morphing it!)\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexS);\n    const isallArgs = markAndCollectArgs(ml, isallOffset, argCount);\n    ASSERT(isallArgs[0] === indexX, 'x should be collected');\n    ASSERT(isallArgs[1] === indexY, 'y should be collected');\n\n    TRACE(\n      ' - isall args:',\n      isallArgs,\n      ', and from the IMP A=',\n      indexA,\n      ', S=',\n      indexS\n    );\n\n    // Compile A->left and A->right over the existing two offsets\n    ml_c2c2(ml, impOffset, 2, ML_IMP, indexA, indexX);\n    ml_cr2c2(ml, isallOffset, argCount, ML_IMP, indexA, indexY);\n\n    TRACE(\n      '   - deferring',\n      indexS,\n      'will be gt',\n      indexA,\n      'and the result of an isall'\n    );\n    solveStack.push((_, force, getDomain, setDomain) => {\n      // Note: we cut out indexS so that's what we restore here!\n      TRACE(' - trick_imprhs_isall_entry; patching index', indexS);\n      TRACE(\n        '   -',\n        indexA,\n        '->',\n        indexS,\n        '  =>  ',\n        domain__debug(getDomain(indexA)),\n        '->',\n        domain__debug(getDomain(indexS))\n      );\n      TRACE(\n        '   -',\n        indexS,\n        '= all?(',\n        isallArgs,\n        ')  =>  ',\n        domain__debug(getDomain(indexS)),\n        '= all?(',\n        isallArgs.map(index => domain__debug(getDomain(index))),\n        ')'\n      );\n\n      const S = getDomain(indexS);\n      const A = getDomain(indexA);\n\n      TRACE(\n        ' - must first scan whether S ought to be set or unset according to the other imp/isall args'\n      );\n\n      // Check whether S is forced at all by the imp or isall\n      let isSet = false;\n      let isUnset = false;\n\n      TRACE(' - A->S so if A is set, S must be set; A>0?', domain_hasNoZero(A));\n      if (domain_hasNoZero(A)) {\n        TRACE(' - A is set so S must be set');\n        isSet = true;\n      }\n\n      TRACE(' - check the \"set\" state of all args');\n      let allSet = true;\n      for (let i = 0; i < argCount; ++i) {\n        const index = isallArgs[i];\n        const D = getDomain(index);\n        TRACE('    - index:', index, ', D:', domain__debug(D));\n        if (domain_isZero(D)) {\n          TRACE('    - isall had an arg that was zero so S must be zero');\n          isUnset = true;\n          allSet = false;\n          break;\n        } else if (domain_hasZero(D)) {\n          TRACE(\n            '    - isall had at least one arg that wasnt set yet so the isall does not force S to be set, at least'\n          );\n          allSet = false;\n        }\n      }\n\n      if (allSet) {\n        TRACE(' - all args of the isall were set so S must be set');\n        isSet = true;\n      }\n\n      TRACE(' - result of scan: set?', isSet, ', unset?', isUnset);\n      ASSERT(!(isSet && isUnset), 'shouldnt be both set and unset');\n      let result = false;\n      if (isSet) {\n        setDomain(indexS, domain_removeValue(S, 0));\n        result = true;\n      } else if (isUnset) {\n        setDomain(indexS, domain_removeGtUnsafe(S, 0));\n        result = false;\n      } else {\n        result = force(indexS) > 0;\n        TRACE(' - forced S to', result);\n      }\n\n      TRACE(\n        ' - now apply the state of S=',\n        result ? 1 : 0,\n        ' to the other args'\n      );\n      TRACE('   -', domain__debug(getDomain(indexA)), '->', result ? 1 : 0);\n      TRACE(\n        '   -',\n        result ? 1 : 0,\n        '= all?(',\n        isallArgs.map(index => domain__debug(getDomain(index))),\n        ')'\n      );\n\n      // A -> S so if S=0 then A=0\n      if (!result) {\n        TRACE(' - A->S, S=0 so A=0');\n        setDomain(indexA, domain_removeGtUnsafe(A, 0));\n      }\n\n      let found = false;\n      for (let i = 0; i < argCount; ++i) {\n        const index = isallArgs[i];\n        const D = getDomain(index);\n        if (result) {\n          // True=isall(...D) so D>0\n          TRACE(' - S>0 so all args must be >0');\n          setDomain(index, domain_removeValue(D, 0));\n        } else if (domain_isZero(D)) {\n          found = true;\n          break;\n        } else if (domain_hasZero(D)) {\n          // False=isall(...D) so D=0\n          TRACE(' - S=0 so one arg must be 0');\n          setDomain(index, domain_removeGtUnsafe(D, 0));\n          found = true;\n          break;\n        }\n      }\n\n      TRACE(' - final result:');\n      TRACE('   -', domain__debug(getDomain(indexA)), '->', result ? 1 : 0);\n      TRACE(\n        '   -',\n        result ? 1 : 0,\n        '= all?(',\n        isallArgs.map(index => domain__debug(getDomain(index))),\n        ')'\n      );\n\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexS));\n      ASSERT(!isallArgs.some(index => !getDomain(index)));\n      ASSERT(\n        domain_hasNoZero(getDomain(indexA))\n          ? domain_hasNoZero(getDomain(indexS))\n          : 1\n      );\n      ASSERT(\n        domain_isZero(getDomain(indexS)) ? domain_isZero(getDomain(indexA)) : 1\n      );\n      ASSERT(domain_isSolved(getDomain(indexS)));\n      ASSERT(\n        domain_isZero(getDomain(indexS)) ===\n          isallArgs.some(index => domain_isZero(getDomain(index)))\n      );\n      ASSERT(\n        result || found,\n        'if result is false at least one arg should be false'\n      );\n    });\n\n    somethingChanged();\n    return true;\n  }\n\n  function trick_imprhs_isall_entry_excess(ml, isallOffset, argCount, indexA) {\n    // Isall has four or more args\n    // A -> S, S=isall(X Y Z ...)  =>  A -> X, A -> Y, A -> Z, ...\n    // note: this function only compiles the args from Z (the third isall arg) onward\n    TRACE(\n      ' - trick_imprhs_isall_entry_excess. Attempting to recycle space to stuff',\n      argCount - 2,\n      'IMP constraints'\n    );\n    ASSERT(\n      argCount > 2,\n      'this function should only be called for 3+ isall args'\n    );\n\n    // We have to recycle some space now. we wont know whether we can\n    // actually do the morph until we've collected enough space for it.\n\n    // we'll use impOffset and isallOffset to compile the last 2 args so only need space for the remaining ones\n    const toRecycle = argCount - 2;\n\n    // Start by collecting toRecycle recycled spaces\n    const bins = ml_getRecycleOffsets(ml, 0, toRecycle, SIZEOF_C_2);\n    if (!bins) {\n      TRACE(\n        ' - Was unable to find enough free space to fit',\n        argCount,\n        'IMPs, bailing'\n      );\n      return false;\n    }\n\n    TRACE(\n      ' - Found',\n      bins.length,\n      'jumps (',\n      bins,\n      ') which can host (at least)',\n      toRecycle,\n      'IMP constraints. Compiling them now'\n    );\n\n    // Okay, now we'll morph. be careful about clobbering existing indexes... start with\n    // last address to make sure jumps dont clobber existing jump offsets in the bin\n\n    let i = 0;\n    while (i < toRecycle) {\n      let currentOffset = bins.pop();\n      ASSERT(\n        ml_dec8(ml, currentOffset) === ML_JMP,\n        'should only get jumps here'\n      ); // Might trap a case where we clobber\n      let size = ml_getOpSizeSlow(ml, currentOffset);\n      ASSERT(size >= SIZEOF_C_2, 'this is what we asked for');\n      do {\n        const indexB = readIndex(ml, isallOffset + SIZEOF_C + (i + 2) * 2); // Note: i+2 because we skip the first two args. they are done by caller\n        TRACE(\n          '  - compiling IMP:',\n          indexA,\n          '->',\n          indexB,\n          ' -> ',\n          domain__debug(getDomain(indexA, true)),\n          '->',\n          domain__debug(getDomain(indexB, true))\n        );\n\n        ml_enc8(ml, currentOffset, ML_IMP);\n        ml_enc16(ml, currentOffset + 1, 2);\n        ml_enc16(ml, currentOffset + OFFSET_C_A, indexA);\n        ml_enc16(ml, currentOffset + OFFSET_C_B, indexB);\n\n        ++i;\n        size -= SIZEOF_C_2;\n        currentOffset += SIZEOF_C_2;\n      } while (size >= SIZEOF_C_2 && i < toRecycle);\n\n      if (size) ml_compileJumpSafe(ml, currentOffset, size);\n      if (process.env.NODE_ENV !== 'production') {\n        ml_validateSkeleton(ml); // Cant check earlier\n      }\n    }\n\n    return true;\n  }\n\n  function trick_issame_lterhs(indexR, lteOffset, countsR, indexC) {\n    TRACE('trick_issame_lterhs');\n    TRACE('   - R = A ==? B, C <= R    =>       R = A ==? B, C -> R');\n    TRACE('   - (if the requirements hold it only morphs an lte to an imp)');\n\n    ASSERT(countsR === 2, 'should be leaf var');\n\n    // Prerequisites: all bools, R leaf (the latter has been confirmed)\n\n    const offset1 = bounty_getOffset(bounty, indexR, 0);\n    const offset2 = bounty_getOffset(bounty, indexR, 1);\n    const issameOffset = offset1 === lteOffset ? offset2 : offset1;\n\n    ASSERT(ml_dec8(ml, issameOffset) === ML_ISSAME, 'should be issame');\n    ASSERT(\n      readIndex(ml, issameOffset + OFFSET_C_R) === indexR,\n      'issame result should be R'\n    );\n    if (ml_dec16(ml, issameOffset + 1) !== 2) {\n      TRACE(' - isall does not have 2 args, bailing');\n      return false;\n    }\n\n    const indexA = readIndex(ml, issameOffset + OFFSET_C_A);\n    const indexB = readIndex(ml, issameOffset + OFFSET_C_B);\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n    const C = getDomain(indexC, true);\n    const R = getDomain(indexR, true);\n    TRACE(\n      ' - domains; A=',\n      domain__debug(A),\n      ', B=',\n      domain__debug(B),\n      ', C=',\n      domain__debug(C),\n      ', R=',\n      domain__debug(R)\n    );\n    if (\n      !domain_isBool(A) ||\n      !domain_isBool(B) ||\n      !domain_isBool(C) ||\n      !domain_isBool(R)\n    ) {\n      TRACE(' - at least one of the three domains isnt bool, bailing');\n      return false;\n    }\n\n    // Okay. morph the lte into implication\n    TRACE(' - morphing, R = A ==? B, C <= R      =>       R = A ==? B, C -> R');\n\n    ml_c2c2(ml, lteOffset, 2, ML_IMP, indexC, indexR);\n    // Dont mark A or B because we did not change their ops\n    bounty_markVar(bounty, indexC);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_isall_nall_2shared(ml, indexR, isallOffset, counts) {\n    // R = all?(A B), nall(R A D)   ->    R = all?(A B), R !& D\n\n    const offset1 = bounty_getOffset(bounty, indexR, 0);\n    const offset2 = bounty_getOffset(bounty, indexR, 1);\n\n    TRACE(\n      'trick_isall_nall_2shared',\n      indexR,\n      'at',\n      isallOffset,\n      'and',\n      offset1,\n      '/',\n      offset2,\n      'metaFlags:',\n      getMeta(bounty, indexR, true),\n      '`R = all?(A B), nall(R A D)`   ->    `R = all?(A B), R !& D`'\n    );\n\n    const nallOffset = offset1 === isallOffset ? offset2 : offset1;\n    const argCountNall = ml_dec16(ml, nallOffset + 1);\n    const argCountIsall = ml_dec16(ml, isallOffset + 1);\n\n    // This stuff should have been checked by the bounty hunter, so we tuck them in ASSERTs\n    ASSERT(\n      getMeta(bounty, indexR) === (BOUNTY_FLAG_NALL | BOUNTY_FLAG_ISALL_RESULT),\n      'the var should only be part of a nall and the result of an isall'\n    );\n    ASSERT(counts === 2, 'R should only appear in two constraints');\n    ASSERT(\n      isallOffset === offset1 || isallOffset === offset2,\n      'expecting current offset to be one of the two offsets found',\n      isallOffset,\n      indexR\n    );\n    ASSERT(\n      ml_dec8(ml, isallOffset) === ML_ISALL,\n      'isall offset should be an isall'\n    );\n    ASSERT(\n      ml_dec8(ml, nallOffset) === ML_NALL,\n      'other offset should be a nall'\n    );\n    ASSERT(getAlias(indexR) === indexR, 'should be unaliased');\n    ASSERT(\n      readIndex(ml, isallOffset + SIZEOF_C + argCountIsall * 2) === indexR,\n      'var should be R of isall'\n    );\n\n    // This should be `R = all?(A B ...), nall(R A D)`\n    // if R = 1 then A and B (etc) are 1, so the nall will have two 1's, meaning D must be 0\n    // if R = 0 then the nall is already satisfied. neither the nall nor the isall is redundant\n    // because `R !& D` must be maintained, so remove the shared arg from the nall\n\n    if (argCountNall !== 3) {\n      TRACE(' - fingerprint didnt match (', argCountNall, ' !== 3) so bailing');\n      return false;\n    }\n\n    // (this is kind of dead code since isall1 wont get 2 args and that's required for this trick)\n    TRACE(' - nall has 3 args, check if it shares an arg with the isall');\n    // Next; one of the two isalls must occur in the nall\n    // R = all?(A B), nall(R A C)\n    // R = all?(A B), nall(X Y Z)\n\n    // nall args\n    const indexX = readIndex(ml, nallOffset + SIZEOF_C);\n    const indexY = readIndex(ml, nallOffset + SIZEOF_C + 2);\n    const indexZ = readIndex(ml, nallOffset + SIZEOF_C + 4);\n    TRACE(\n      ' - nall(' + [indexX, indexY, indexZ] + ') -> nall(',\n      [\n        domain__debug(getDomain(indexX, true)),\n        domain__debug(getDomain(indexY)),\n        domain__debug(getDomain(indexZ)),\n      ],\n      ')'\n    );\n\n    for (let i = 0; i < argCountIsall; ++i) {\n      const argIndex = readIndex(ml, isallOffset + SIZEOF_C + i * 2);\n      if (argIndex === indexX)\n        return _updateNallForTrick(ml, nallOffset, indexY, indexZ, indexX);\n      if (argIndex === indexY)\n        return _updateNallForTrick(ml, nallOffset, indexX, indexZ, indexY);\n      if (argIndex === indexZ)\n        return _updateNallForTrick(ml, nallOffset, indexX, indexY, indexZ);\n    }\n\n    TRACE(' - no shared args');\n    return false;\n  }\n\n  function _updateNallForTrick(ml, offset, indexA, indexB, indexDropped) {\n    TRACE(' - isall arg matches an arg of nall. dropping it from the nall');\n    // Since we know the nall has 3 args we can simply write the two args we want and a noop for the last position\n    // keep A and B, the other index is dropped because we're writing a noop in its place\n\n    ASSERT(ml_dec8(ml, offset) === ML_NALL, 'should be nall');\n    ASSERT(ml_dec16(ml, offset + 1) === 3, 'nall should have 3 args');\n\n    ml_enc16(ml, offset + 1, 2); // Down from 3 to 2 args\n    ml_enc16(ml, offset + OFFSET_C_A, indexA);\n    ml_enc16(ml, offset + OFFSET_C_B, indexB);\n    ml_enc8(ml, offset + OFFSET_C_C, ML_NOOP2);\n    // This only affected the nall and its args so no need to mark the isall vars\n    bounty_markVar(bounty, indexDropped);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_ltelhs_nall_leaf(ml, indexA, countsA) {\n    // A <= B, A !& C   ->   A leaf, all constraints dropped. for _any_ lte_lhs / nall\n\n    TRACE('trick_ltelhs_nall_leaf; bounty A:', bounty__debug(bounty, indexA));\n    TRACE(\n      ' - indexA=',\n      indexA,\n      '; `A <= B, A !& C   ->   nothing (for any number of LTE_LHS and NAND ops).'\n    );\n    TRACE(\n      '   - A=',\n      domain__debug(getDomain(indexA)),\n      '; if it has a zero it can never break LTE_LHS or NALL'\n    );\n\n    // Rationale; assuming A has at least a zero, there's no valuation of B or C that could lead to breaking\n    // the <= or !& constraints. so A can still be considered a leaf var.\n    // note that the number of args of the NALL is irrelevant\n\n    ASSERT(\n      getMeta(bounty, indexA) === BOUNTY_FLAG_LTE_LHS ||\n        getMeta(bounty, indexA) === BOUNTY_FLAG_NALL ||\n        getMeta(bounty, indexA) === (BOUNTY_FLAG_NALL | BOUNTY_FLAG_LTE_LHS),\n      'the var should only be lhs of LTEs or part of NALLs'\n    );\n    ASSERT(getAlias(indexA) === indexA, 'should be unaliased');\n\n    // TODO: what if there aren't any NALLs? then A could still be a leaf even if it was nonzero\n\n    // A must contain zero for this to work for else it may not solve the nall\n    if (domain_hasNoZero(getDomain(indexA, true))) {\n      TRACE(' - A contains no zero, bailing');\n      return false;\n    }\n\n    // No need for further verification.\n\n    TRACE(' - marking LTE/NALL args, eliminating the constraints');\n    for (let i = 0; i < countsA; ++i) {\n      const offset = bounty_getOffset(bounty, indexA, i);\n      const opCode = ml_dec8(ml, offset);\n      TRACE('    - next op:', ml__debug(ml, offset, 1, problem));\n      if (opCode === ML_LTE) {\n        ASSERT(\n          readIndex(ml, offset + OFFSET_C_A) === indexA,\n          'A should (at least) be LTE_LHS'\n        );\n        ASSERT(\n          readIndex(ml, offset + 1) === 2,\n          'LTE is assumed to always have 2 args'\n        );\n\n        const index = readIndex(ml, offset + OFFSET_C_B);\n        if (index !== indexA) {\n          bounty_markVar(bounty, index);\n          ml_eliminate(ml, offset, SIZEOF_C_2);\n        }\n      } else if (opCode === ML_NALL) {\n        const argCount = readIndex(ml, offset + 1);\n        for (let j = 0; j < argCount; ++j) {\n          const index = readIndex(ml, offset + SIZEOF_C + j * 2);\n          if (index !== indexA) {\n            bounty_markVar(bounty, index);\n          }\n        }\n\n        ml_eliminate(ml, offset, SIZEOF_C + argCount * 2);\n      } else {\n        ASSERT(\n          false,\n          'bounty should have asserted A to only be LTE_LHS and NALL so this cant happen?'\n        );\n        TRACE(' - the unthinkable happened, bailing'); // *Shrug* it's not a problem to throw for\n        return false;\n      }\n    }\n\n    // Note: We could go through great lengths in an effort to reduce A as little as possible but since\n    // this trick involves any number of NALLs and LTEs, this leads to a bunch of difficult checks and\n    // heuristics. And even then we're still very likely to set A to zero anyways.\n    // Let's save us the code head ache here and just do it now.\n\n    TRACE(' - setting A to zero for the sake of simplicity');\n    const A = getDomain(indexA, true);\n    const nA = domain_removeGtUnsafe(A, 0);\n    if (A !== nA) setDomain(indexA, nA);\n    bounty_markVar(bounty, indexA);\n\n    somethingChanged();\n    return true;\n  }\n\n  function trick_implhs_nall_leaf(ml, indexA, countsA) {\n    // For all A, A -> B, A !& C   =>   cut A, all constraints dropped. for _any_ imp_lhs / nall on A\n\n    TRACE('trick_implhs_nall_leaf');\n    TRACE(' - indexA=', indexA, ', bounty A:', bounty__debug(bounty, indexA));\n    TRACE_MORPH(\n      'A -> B, A !& C',\n      '',\n      '(for any number of IMP_LHS and NAND ops).'\n    );\n    TRACE(\n      '   - A=',\n      domain__debug(getDomain(indexA)),\n      '; if it has a zero it can never break IMP_LHS or NALL'\n    );\n\n    // Rationale; assuming A has at least a zero, there's no valuation of B or C that could lead to breaking\n    // the -> or !& constraints. so A can still be considered a leaf var.\n    // note that the number of args of the NALL is irrelevant\n\n    ASSERT(\n      getMeta(bounty, indexA) === BOUNTY_FLAG_IMP_LHS ||\n        getMeta(bounty, indexA) === BOUNTY_FLAG_NALL ||\n        getMeta(bounty, indexA) === (BOUNTY_FLAG_NALL | BOUNTY_FLAG_IMP_LHS),\n      'the var should only be lhs of IMPs or part of NALLs'\n    );\n    ASSERT(getAlias(indexA) === indexA, 'should be unaliased');\n\n    // TODO: what if there aren't any NALLs? then A could still be a leaf even if it was nonzero\n\n    // A must contain zero for this to work for else A may not solve the nall\n    if (domain_hasNoZero(getDomain(indexA, true))) {\n      TRACE(' - A contains no zero, bailing');\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    // No need for further verification.\n    // A is only the IMP_LHS or NALL arg\n    // if we set it to 0 here then those immediately solve\n    // we could go into great code complexity here handling everything nicely\n    // or we could just set it to 0 here and request another run. oh yes.\n\n    TRACE_MORPH(\n      'A -> B, A !& C',\n      'A=0',\n      'this will solve all implications and nalls'\n    );\n    TRACE(' - setting A to zero for the sake of simplicity');\n    const A = getDomain(indexA, true);\n    if (!domain_isZero(A)) {\n      const nA = domain_removeGtUnsafe(A, 0);\n      if (A !== nA) setDomain(indexA, nA);\n      bounty_markVar(bounty, indexA);\n    }\n\n    somethingChanged(); // This will require another minimizer as well\n    return true;\n  }\n\n  function trick_ltelhs_some_leaf(ml, lteOffset, indexA, countsA) {\n    // A <= B, A | C   =>   B | C, A leaf\n\n    TRACE('trick_ltelhs_some_leaf');\n    TRACE(' - A <= B, some(A C ...)     =>     some(B C ...), A leaf');\n\n    const A = getDomain(indexA, true);\n    TRACE(' - indexA=', indexA, ', =', domain__debug(A));\n\n    ASSERT(\n      getMeta(bounty, indexA) === (BOUNTY_FLAG_LTE_LHS | BOUNTY_FLAG_SOME),\n      'A is leaf on an LTE and SOME'\n    );\n    ASSERT(getAlias(indexA) === indexA, 'should be unaliased');\n    ASSERT(countsA === 2, 'should have 2 offsets');\n\n    if (!domain_isBool(A)) {\n      TRACE(' - A wasnt a bool, bailing');\n      return false;\n    }\n\n    const indexB = readIndex(ml, lteOffset + OFFSET_C_B);\n    const B = getDomain(indexB, true);\n    if (!domain_isBool(B)) {\n      TRACE(' - B wasnt a bool, bailing');\n      return false;\n    }\n\n    TRACE(' - constraints verified, applying trick');\n    TRACE_MORPH('A <= B, some(A C ...)', 'some(B C ...)', 'A is leaf');\n\n    const offset1 = bounty_getOffset(bounty, indexA, 0);\n    const offset2 = bounty_getOffset(bounty, indexA, 1);\n    const someOffset = offset1 === lteOffset ? offset2 : offset1;\n\n    ASSERT(ml_dec8(ml, someOffset) === ML_SOME);\n    // Note: arg count of the SOME is not important. A must simply be part of it (and bounty asserted that already)\n    const argCount = ml_dec16(ml, someOffset + 1);\n\n    const args = markAndCollectArgs(ml, someOffset, argCount, indexA);\n\n    ml_eliminate(ml, lteOffset, SIZEOF_C_2);\n    ml_cx2cx(ml, someOffset, argCount, ML_SOME, [indexB].concat(args));\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_ltelhs_some_leaf');\n      TRACE(' - A <= B, some(A C ...)    =>     some(B C ...)');\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n\n      let nA = A;\n\n      // Ensure A<=B\n      if (domain_max(nA) > domain_min(B)) {\n        nA = domain_removeGtUnsafe(nA, domain_min(B));\n      }\n\n      // Ensure the SOME holds\n      if (!domain_isZero(nA)) {\n        let removeZero = true; // Without other args, A must be nonzero to satisfy the SOME\n        for (let i = 0, len = args.length; i < len; ++i) {\n          const index = args[i];\n          const D = getDomain(index);\n          if (domain_hasNoZero(D)) {\n            // At least one arg already satisfies the SOME\n            break;\n          }\n\n          if (domain_isBooly(D)) {\n            removeZero = true; // At least one arg is undetermined so to make sure its value is irrelevant we set A>0\n            break;\n          }\n\n          removeZero = false;\n        }\n\n        if (removeZero) {\n          nA = domain_removeValue(nA, 0);\n        }\n      }\n\n      ASSERT(nA, 'A should hold all values');\n      if (A !== nA) setDomain(indexA, nA);\n    });\n\n    bounty_markVar(bounty, indexA);\n\n    somethingChanged();\n    return true;\n  }\n\n  function trick_implhs_some_leaf(ml, impOffset, indexA, countsA) {\n    // A -> B, A | C   =>   B | C, A leaf\n\n    TRACE('trick_implhs_some_leaf');\n    TRACE(' - A -> B, some(A C ...)     =>     some(B C ...), A leaf');\n\n    const A = getDomain(indexA, true);\n    TRACE(' - indexA=', indexA, ', =', domain__debug(A));\n\n    ASSERT(\n      getMeta(bounty, indexA) === (BOUNTY_FLAG_IMP_LHS | BOUNTY_FLAG_SOME),\n      'A is leaf on an IMP and SOME'\n    );\n    ASSERT(getAlias(indexA) === indexA, 'should be unaliased');\n    ASSERT(countsA === 2, 'should have 2 offsets');\n\n    if (!domain_isBool(A)) {\n      TRACE(' - A wasnt a bool, bailing');\n      return false;\n    }\n\n    const indexB = readIndex(ml, impOffset + OFFSET_C_B);\n    const B = getDomain(indexB, true);\n    if (!domain_isBool(B)) {\n      TRACE(' - B wasnt a bool, bailing');\n      return false;\n    }\n\n    TRACE(' - constraints verified, applying trick');\n    TRACE_MORPH('A -> B, some(A C ...)', 'some(B C ...)', 'A is leaf');\n\n    const offset1 = bounty_getOffset(bounty, indexA, 0);\n    const offset2 = bounty_getOffset(bounty, indexA, 1);\n    const someOffset = offset1 === impOffset ? offset2 : offset1;\n\n    ASSERT(ml_dec8(ml, someOffset) === ML_SOME);\n    // Note: arg count of the SOME is not important. A must simply be part of it (and bounty asserted that already)\n    const argCount = ml_dec16(ml, someOffset + 1);\n\n    const args = markAndCollectArgs(ml, someOffset, argCount, indexA);\n\n    ml_eliminate(ml, impOffset, SIZEOF_C_2);\n    ml_cx2cx(ml, someOffset, argCount, ML_SOME, [indexB].concat(args));\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_implhs_some_leaf');\n      TRACE(' - A -> B, some(A C ...)    =>     some(B C ...)');\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n\n      let nA = A;\n\n      // Ensure A->B\n      if (domain_hasNoZero(B)) {\n        nA = domain_removeValue(nA, 0);\n      } else {\n        nA = domain_removeGtUnsafe(nA, 0);\n      }\n\n      // Ensure the SOME holds\n      if (!domain_isZero(nA)) {\n        let removeZero = true; // Without other args, A must be nonzero to satisfy the SOME\n        for (let i = 0, len = args.length; i < len; ++i) {\n          const index = args[i];\n          const D = getDomain(index);\n          if (domain_hasNoZero(D)) {\n            // At least one arg already satisfies the SOME\n            break;\n          }\n\n          if (domain_isBooly(D)) {\n            removeZero = true; // At least one arg is undetermined so to make sure its value is irrelevant we set A>0\n            break;\n          }\n\n          removeZero = false;\n        }\n\n        if (removeZero) {\n          nA = domain_removeValue(nA, 0);\n        }\n      }\n\n      ASSERT(nA, 'A should hold all values');\n      if (A !== nA) setDomain(indexA, nA);\n    });\n\n    bounty_markVar(bounty, indexA);\n\n    somethingChanged();\n    return true;\n  }\n\n  function trick_imp_islte_c_v(islteOffset, indexR, indexA, indexB, countsR) {\n    TRACE('trick_imp_islte_c_v');\n    TRACE(' - R = A <=? B, B -> R, solved(A)  =>  R = A <=? B');\n\n    // First search for the imp offset\n    for (let i = 0; i < countsR; ++i) {\n      const offset = bounty_getOffset(bounty, indexR, i);\n      if (offset !== islteOffset) {\n        const op = ml_dec8(ml, offset);\n        if (op === ML_IMP) {\n          if (\n            readIndex(ml, offset + OFFSET_C_A) === indexB &&\n            readIndex(ml, offset + OFFSET_C_B) === indexR\n          ) {\n            return _trick_imp_islte_c_v(\n              indexR,\n              indexA,\n              indexB,\n              islteOffset,\n              offset\n            );\n          }\n        }\n      }\n    }\n\n    ASSERT(false, 'bounty should have asserted this imp exists');\n    return false;\n  }\n\n  function _trick_imp_islte_c_v(\n    indexR,\n    indexA,\n    indexB,\n    islteOffset,\n    impOffset\n  ) {\n    TRACE(\n      ' - _trick_imp_islte_c_v; R = A <=? B, B -> R   =>   R !^ B, remove [1..A-1] from B'\n    );\n    ASSERT(domain_isSolved(getDomain(indexA)));\n\n    // Note:\n    // - if R=0 then B->R then B->0 then 0->0 so B=0\n    // - if R>0 then B->R always holds and R=vA<=?B holds when B>=vA\n    // - if vA<=min(B) then R>0 because vA cannot be >B\n    // - if vA>max(B) then R=0 because vA cannot be <=B\n    // so R !^ B and remove from B all values from 1 up to but not including vA\n\n    // [01] = 2 <=? [02], [02] -> [01]\n    // R=0\n    // => 0 = 2 <=? [02], [02] -> 0\n    // => 2 > [02], [02] -> 0\n    // => 2 > 0, 0 -> 0\n    // R>0\n    // => 1 = 2 <=? [02], [02] -> 1\n    // => 2 <= [02], [02] -> 1\n    // => 2 <= 2, 2 -> 1\n\n    // [01] = 5 <=? [09], [09] -> [01]\n    // R=0\n    // => 0 = 2 <=? [09], [09] -> 0\n    // => 2 > [09], [09] -> 0\n    // => 2 > [01], [01] -> 0\n    // => 2 > 0, 0 -> 0\n    // R>0\n    // => 1 = 2 <=? [09], [09] -> 1\n    // => 2 <= [09], [09] -> 1\n    // => 2 <= [29], [29] -> 1\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n    const vA = domain_getValue(A);\n\n    TRACE(\n      ' - first checking;',\n      vA,\n      '<=',\n      domain_min(B),\n      ' and ',\n      vA,\n      '>',\n      domain_max(B)\n    );\n\n    if (vA <= domain_min(B)) {\n      // R>0 because if R=0 then A>B and that's not possible\n      // let minimizer take this down\n      TRACE(' - A<=min(B) means R>0, minimizer can solve this, bailing');\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    if (vA > domain_max(B)) {\n      TRACE(' - A > max(B), minimizer can solve this, bailing');\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    TRACE_MORPH('R = A <=? B, B -> R', 'R !^ B, remove [1..A-1] from B');\n    TRACE(' - indexes: A=', indexA, ', B=', indexB, ', R=', indexR);\n    TRACE(\n      ' - domains: A=',\n      domain__debug(getDomain(indexA)),\n      ', B=',\n      domain__debug(getDomain(indexB)),\n      ', R=',\n      domain__debug(getDomain(indexR))\n    );\n\n    // Create a mask that removes 1..A then intersect B with that mask (because B may already be missing more values)\n    const mask = domain_arrToSmallest([0, 0, vA, domain_max(B)]);\n    const nB = domain_intersection(B, mask);\n    TRACE(\n      ' - B mask:',\n      domain__debug(mask),\n      ', B after mask:',\n      domain__debug(mask)\n    ); // Probably the same\n    if (B !== nB) {\n      setDomain(indexB, nB);\n      if (!nB) return (emptyDomain = true);\n    }\n\n    ml_c2c2(ml, impOffset, 2, ML_XNOR, indexR, indexB);\n    ml_eliminate(ml, islteOffset, SIZEOF_VVV);\n\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_imp_islte_v_c(islteOffset, indexR, indexA, indexB, countsR) {\n    TRACE('trick_imp_islte_c_v');\n    TRACE(' - R = A <=? B, A -> R, solved(B)  =>  R > 0, A <= B');\n\n    // First search for the imp offset\n    for (let i = 0; i < countsR; ++i) {\n      const offset = bounty_getOffset(bounty, indexR, i);\n      if (offset !== islteOffset) {\n        const op = ml_dec8(ml, offset);\n        if (op === ML_IMP) {\n          if (\n            readIndex(ml, offset + OFFSET_C_A) === indexA &&\n            readIndex(ml, offset + OFFSET_C_B) === indexR\n          ) {\n            return _trick_imp_islte_v_c(\n              indexR,\n              indexA,\n              indexB,\n              islteOffset,\n              offset\n            );\n          }\n        }\n      }\n    }\n\n    ASSERT(false, 'bounty should have asserted this imp exists');\n    return false;\n  }\n\n  function _trick_imp_islte_v_c(\n    indexR,\n    indexA,\n    indexB,\n    islteOffset,\n    impOffset\n  ) {\n    TRACE(' - _trick_imp_islte_c_v');\n    ASSERT(domain_isSolved(getDomain(indexB)));\n\n    // Note:\n    // - if R=0 then A > vB then A>0 then A->R so R>0 then falsum\n    // - if R>0 then A <= vB then A->R always holds because R>0\n    // - so R>0, islte becomes lte, imp is eliminated\n\n    let R = getDomain(indexR, true);\n    R = domain_removeValue(R, 0);\n    if (!R) {\n      emptyDomain = true;\n      return false;\n    }\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n    if (domain_getValue(B) <= domain_min(A)) {\n      TRACE(' - B <= min(A), minimizer can solve this, bailing');\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    TRACE_MORPH('R = A <=? B, A -> R', 'R > 0, A <= B');\n    TRACE(' - indexes: A=', indexA, ', B=', indexB, ', R=', indexR);\n    TRACE(\n      ' - domains: A=',\n      domain__debug(getDomain(indexA)),\n      ', B=',\n      domain__debug(getDomain(indexB)),\n      ', R=',\n      domain__debug(getDomain(indexR))\n    );\n\n    setDomain(indexR, R);\n    ml_c2c2(ml, impOffset, 2, ML_LTE, indexA, indexB);\n    ml_eliminate(ml, islteOffset, SIZEOF_VVV);\n\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_only_ltelhs_leaf(ml, indexA, countsA) {\n    TRACE('trick_only_ltelhs_leaf; bounty A:', bounty__debug(bounty, indexA));\n    TRACE(\n      ' - A should only be an LTE_LHS for any number of LTE ops. cut it as a leaf and eliminate constraints'\n    );\n\n    // There is no way A breaks any LTEs unless there's already an rhs var that is smaller than it\n    // no need to check here. just go.\n\n    const A = getDomain(indexA, true);\n\n    const rhsArgs = [];\n    for (let i = 0; i < countsA; ++i) {\n      const offset = bounty_getOffset(bounty, indexA, i);\n      TRACE('    - next op:', ml__debug(ml, offset, 1, problem));\n      ASSERT(ml_dec8(ml, offset) === ML_LTE);\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'all LTE have 2 args');\n      ASSERT(\n        readIndex(ml, offset + OFFSET_C_A) === indexA,\n        'A should be the lhs'\n      );\n      const indexB = readIndex(ml, offset + OFFSET_C_B);\n      if (domain_max(getDomain(indexB)) < domain_min(A)) {\n        TRACE(\n          ' indexB=',\n          indexB,\n          'and it is already smaller than A;',\n          domain__debug(A),\n          '>',\n          domain__debug(getDomain(indexB))\n        );\n        TRACE(' constraint cant hold, empty domain, rejecting');\n        setDomain(indexB, 0);\n        return true; // \"true\" as in \"something awful happened\"\n      }\n\n      rhsArgs.push(indexB);\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n    }\n\n    TRACE(' - Adding solve stack entry');\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_only_ltelhs_leaf; shaving A to pass all LTEs');\n\n      const A = getDomain(indexA);\n      let nA = A;\n      for (let i = 0, il = rhsArgs.length; i < il; ++i) {\n        const indexB = rhsArgs[i];\n        TRACE(\n          '   - removing everything >',\n          domain_min(getDomain(indexB)),\n          'from',\n          domain__debug(nA)\n        );\n        nA = domain_removeGtUnsafe(nA, domain_min(getDomain(indexB)));\n      }\n\n      ASSERT(nA, 'A should be able to be <= all the index B args');\n      if (A !== nA) setDomain(indexA, nA);\n    });\n\n    bounty_markVar(bounty, indexA);\n    for (let i = 0, il = rhsArgs.length; i < il; ++i) {\n      bounty_markVar(bounty, rhsArgs[i]);\n    }\n\n    somethingChanged();\n    return true;\n  }\n\n  function trick_only_implhs_leaf(ml, indexA, countsA) {\n    TRACE('trick_only_implhs_leaf; bounty A:', bounty__debug(bounty, indexA));\n    TRACE(\n      ' - A should only be an IMP_LHS for any number of IMP ops. confirm none of the Bs are zero. then cut it as a leaf and eliminate constraints'\n    );\n\n    const A = getDomain(indexA, true);\n    if (domain_isZero(A) || domain_hasNoZero(A)) {\n      TRACE(\n        ' - A is not a booly. implication is resolved, let minimizer take care of it, bailing'\n      );\n      requestAnotherCycle = true; // Force minimizer to take care of this one\n      return false;\n    }\n\n    // The only way A breaks any IMPs is if it has an rhs that is zero. so check that first.\n    for (let i = 0; i < countsA; ++i) {\n      const offset = bounty_getOffset(bounty, indexA, i);\n      TRACE('    - next op:', ml__debug(ml, offset, 1, problem));\n      ASSERT(ml_dec8(ml, offset) === ML_IMP);\n      ASSERT(\n        readIndex(ml, offset + OFFSET_C_A) === indexA,\n        'A should be the lhs'\n      );\n      const indexB = readIndex(ml, offset + OFFSET_C_B);\n      if (domain_isZero(indexB)) {\n        TRACE(\n          ' - indexB=',\n          indexB,\n          'and is already zero;',\n          domain__debug(A),\n          '->',\n          domain__debug(getDomain(indexB))\n        );\n        TRACE(\n          ' - implication is resolved, let minimizer take care of it, bailing'\n        );\n        requestAnotherCycle = true; // Force minimizer to take care of this one\n        return false;\n      }\n    }\n\n    TRACE_MORPH(\n      'A -> B, A -> C, ...',\n      'A==0',\n      'leaf A, they dont break implication now so the implication cant break A once the rhs solves'\n    );\n\n    const rhsArgs = [];\n    for (let i = 0; i < countsA; ++i) {\n      const offset = bounty_getOffset(bounty, indexA, i);\n      const indexB = readIndex(ml, offset + OFFSET_C_B);\n      rhsArgs.push(indexB);\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n    }\n\n    // TODO: could potentially improve \"force\" choice here but A=0 is definitely the simplest play\n    TRACE(\n      ' - forcing A to 0 since thats the most likely outcome anyways and the safest play here'\n    );\n\n    const nA = domain_intersectionValue(A, 0);\n    ASSERT(\n      nA !== A,\n      'since A was confirmed to be a booly before it should be different now'\n    );\n    ASSERT(nA, 'since A was a booly we should be able to set it to 0');\n    setDomain(indexA, nA);\n\n    bounty_markVar(bounty, indexA);\n    for (let i = 0, il = rhsArgs.length; i < il; ++i) {\n      bounty_markVar(bounty, rhsArgs[i]);\n    }\n\n    somethingChanged();\n    return true;\n  }\n\n  function trick_isall_nall_1shared(ml, indexR, isallOffset, countsR) {\n    // R = all?(A B ...), R !& C  ->  nall(A B ... C)\n    // note: this works for any nalls on one isall\n    TRACE(\n      'trick_isall_nall_1shared;',\n      indexR,\n      '`R = all?(A B), R !& C  ->  nall(A B C)` for any nall on one isall, any arg count for either'\n    );\n\n    // This stuff should have been checked by the bounty hunter, so we tuck them in ASSERTs\n    ASSERT(\n      getMeta(bounty, indexR) === (BOUNTY_FLAG_NALL | BOUNTY_FLAG_ISALL_RESULT),\n      'the var should only be nall[2] and isall',\n      bounty__debugMeta(bounty, indexR),\n      countsR\n    );\n    ASSERT(\n      ml_dec8(ml, isallOffset) === ML_ISALL,\n      'isall offset should be an isall'\n    );\n    ASSERT(getAlias(indexR) === indexR, 'should be unaliased');\n    ASSERT(\n      readIndex(\n        ml,\n        isallOffset + SIZEOF_C + ml_dec16(ml, isallOffset + 1) * 2\n      ) === indexR,\n      'R should be result of isall'\n    );\n    ASSERT(\n      countsR < BOUNTY_MAX_OFFSETS_TO_TRACK,\n      'counts should not exceed maxed tracked'\n    );\n\n    const isallArgCount = ml_dec16(ml, isallOffset + 1);\n    const isallSizeof = SIZEOF_C + isallArgCount * 2 + 2;\n    const isallArgs = [];\n    for (let i = 0; i < isallArgCount; ++i) {\n      const index = readIndex(ml, isallOffset + SIZEOF_C + i * 2);\n      isallArgs.push(index);\n    }\n\n    TRACE(\n      ' - trick_isall_nall_1shared; first confirming all other offsets are nalls with 2 args; isall arg count:',\n      isallArgCount,\n      ', isall args:',\n      isallArgs\n    );\n\n    let nalls = 0;\n    for (let i = 0; i < countsR; ++i) {\n      const nallOffset = bounty_getOffset(bounty, indexR, i);\n      ASSERT(\n        nallOffset,\n        'there should be as many offsets as counts unless that exceeds the max and that has been checked already'\n      );\n      if (nallOffset !== isallOffset) {\n        const opcode = ml_dec8(ml, nallOffset);\n        if (opcode !== ML_NALL) {\n          TRACE(' - found at least one other isall, bailing');\n          ASSERT(\n            opcode === ML_ISALL,\n            'bounty should have asserted that the offsets can only be isall and nall'\n          );\n          return false;\n        }\n\n        if (ml_dec16(ml, nallOffset + 1) !== 2) {\n          TRACE(' - found a nall that did not have 2 args, bailing for now');\n          return false;\n        }\n\n        ++nalls;\n      }\n\n      ASSERT(\n        nallOffset === isallOffset ||\n          readIndex(ml, nallOffset + OFFSET_C_A) === indexR ||\n          readIndex(ml, nallOffset + OFFSET_C_B) === indexR,\n        'R should be part of the nall'\n      );\n    }\n\n    // Bounty asserted that all these nalls contain R, rewrite each such nall\n\n    TRACE(\n      ' - trick_isall_nall_1shared; there are',\n      nalls,\n      'nalls; for each nall: `X !& B, X = all?(C D)`   ->   `nall(B C D)`'\n    );\n    TRACE(\n      ' - one nall will fit inside the isall but any others need recycled spaces (because the existing nalls have 2 args)'\n    );\n\n    // Each nall with 2 args becomes a nall with all the isall args + 1, that should be at least 3\n    const sizeofNall = SIZEOF_C + (isallArgCount + 1) * 2;\n\n    const nallSpacesNeeded = nalls - 1; // -1 because we can always recycle the original isall\n    TRACE(\n      ' - isall offset=',\n      isallOffset,\n      ', size(isall)=',\n      isallSizeof,\n      ', size(nall)=',\n      sizeofNall,\n      ', there are',\n      nalls,\n      'nalls[2] and each morphs into a nall[' + isallSizeof + '] so we need',\n      nallSpacesNeeded,\n      'spaces'\n    );\n    ASSERT(\n      isallSizeof === sizeofNall,\n      'both isalls should be a cr-op so should have enough space for this nall'\n    );\n\n    let bins;\n    if (nallSpacesNeeded) {\n      TRACE(\n        ' - need additional space; searching for',\n        nallSpacesNeeded,\n        'spaces of size=',\n        sizeofNall\n      );\n      bins = ml_getRecycleOffsets(ml, 0, nallSpacesNeeded, sizeofNall);\n      if (!bins) {\n        TRACE(\n          ' - Was unable to find enough free space to fit',\n          nalls,\n          'nalls, bailing'\n        );\n        return false;\n      }\n    }\n\n    // If any of the nall args or any of the isall args is 0, then so is R. so collect all args together to defer R\n    const allArgs = isallArgs.slice(0);\n\n    let offsetCounter = 0;\n    let rewrittenNalls = 0; // Only used in ASSERTs, minifier should eliminate this\n\n    if (nallSpacesNeeded) {\n      TRACE(' - starting to morph', nallSpacesNeeded, 'nalls into bins');\n      ml_recycles(\n        ml,\n        bins,\n        nallSpacesNeeded,\n        sizeofNall,\n        (recycledOffset, i, sizeLeft) => {\n          TRACE(\n            '   - using: recycledOffset:',\n            recycledOffset,\n            ', i:',\n            i,\n            ', sizeLeft:',\n            sizeLeft\n          );\n\n          let offset;\n          do {\n            if (offsetCounter >= countsR) {\n              TRACE(' - (last offset must have been offset)');\n              return true;\n            }\n\n            offset = bounty_getOffset(bounty, indexR, offsetCounter++);\n            TRACE('     - offset', offset, 'is isall?', offset === isallOffset);\n          } while (offset === isallOffset);\n\n          TRACE('     - offset', offset, 'is not isall so it should be nall');\n          ASSERT(ml_dec8(ml, offset) === ML_NALL, 'should be nall');\n          ASSERT(\n            offset,\n            'the earlier loop counted the nalls so it should still have that number of offsets now'\n          );\n          ASSERT(\n            sizeLeft === ml_getOpSizeSlow(ml, recycledOffset),\n            'size left should be >=size(op)'\n          );\n          _trick_isall_nall_1shared_CreateNallAndRemoveNall(\n            ml,\n            indexR,\n            isallArgs.slice(0),\n            allArgs,\n            offset,\n            recycledOffset,\n            sizeLeft\n          );\n          ASSERT(++rewrittenNalls);\n\n          return false;\n        }\n      );\n      ASSERT(\n        rewrittenNalls === nallSpacesNeeded,\n        'should have processed all offsets for R',\n        rewrittenNalls,\n        '==',\n        nallSpacesNeeded,\n        '(',\n        offsetCounter,\n        countsR,\n        ')'\n      );\n      TRACE(' - all nalls should be morphed now');\n    }\n\n    // Now recycle the isall. have to do it afterwards because otherwise the found recycled bins may be clobbered\n    // when eliminating the nall. there's no test for this because it's rather complex to create. sad.\n    TRACE(' - recycling the old isall into the last nall');\n    let lastNallOffset = bounty_getOffset(bounty, indexR, offsetCounter++);\n    if (lastNallOffset === isallOffset)\n      lastNallOffset = bounty_getOffset(bounty, indexR, offsetCounter++);\n    _trick_isall_nall_1shared_CreateNallAndRemoveNall(\n      ml,\n      indexR,\n      isallArgs.slice(0),\n      allArgs,\n      lastNallOffset,\n      isallOffset,\n      isallSizeof\n    );\n    ASSERT(++rewrittenNalls);\n\n    TRACE('   - deferring', indexR, 'will be R = all?(', allArgs, ')');\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - trick_isall_nall_1shared;',\n        indexR,\n        '= all?(',\n        allArgs,\n        ')  ->  ',\n        domain__debug(getDomain(indexR)),\n        '= all?(',\n        allArgs.map(index => domain__debug(getDomain(index))),\n        ')'\n      );\n\n      let R = getDomain(indexR);\n      allArgs.some(index => {\n        const X = getDomain(index);\n        if (!domain_hasNoZero(X)) {\n          // If non-zero, this var wont affect R\n          const vX = force(index);\n          if (vX === 0) {\n            R = domain_removeGtUnsafe(R, 0);\n            return true;\n          }\n        }\n      });\n      // R should be updated properly now. basically if any arg solved to zero, it will be zero. otherwise unchanged.\n\n      ASSERT(R, 'R should have at least a value to solve left');\n      setDomain(indexR, R);\n    });\n\n    bounty_markVar(bounty, indexR);\n    for (let i = 0, l = allArgs.length; i < l; ++i) {\n      bounty_markVar(bounty, allArgs[i]);\n    }\n\n    return true;\n  }\n\n  function _trick_isall_nall_1shared_CreateNallAndRemoveNall(\n    ml,\n    indexR,\n    nallArgs,\n    allArgs,\n    nallOffset,\n    recycleOffset,\n    recycleSizeof\n  ) {\n    TRACE(\n      ' - _trick_isall_nall_1shared_CreateNallAndRemoveNall: indexR:',\n      indexR,\n      'nallArgs:',\n      nallArgs,\n      'allArgs:',\n      allArgs,\n      'nallOffset:',\n      nallOffset,\n      'recycleOffset:',\n      recycleOffset,\n      'recycleSizeof:',\n      recycleSizeof\n    );\n\n    ASSERT(ml_dec16(ml, nallOffset + 1) === 2, 'nalls should have 2 args');\n\n    const indexX = readIndex(ml, nallOffset + OFFSET_C_A);\n    const indexY = readIndex(ml, nallOffset + OFFSET_C_B);\n    ASSERT(\n      indexX === indexR || indexY === indexR,\n      'expecting indexR to be part of the nall'\n    );\n    const index = indexX === indexR ? indexY : indexX;\n    TRACE(\n      ' - other nall index is',\n      index,\n      domain__debug(getDomain(index, true))\n    );\n\n    nallArgs.push(index);\n    allArgs.push(index);\n\n    // Note: bounty_markVar happens at caller\n    TRACE(' - writing a new nall');\n    ml_any2c(ml, recycleOffset, recycleSizeof, ML_NALL, nallArgs);\n    if (nallOffset !== recycleOffset) {\n      TRACE(' - removing the nall because we didnt recycle it');\n      ml_eliminate(ml, nallOffset, SIZEOF_C_2);\n    }\n\n    ASSERT(\n      ml_validateSkeleton(\n        ml,\n        '_trick_isall_nall_1shared_CreateNallAndRemoveNall'\n      )\n    );\n  }\n\n  function trick_diff_elimination(diffOffset, indexX, countsX, indexY) {\n    // Bascially we \"invert\" one arg by aliasing it to the other arg and then inverting all ops that relate to it\n\n    // the case with multiple diffs should be eliminated elsewhere\n    // all targeted ops should only have 2 args\n    // see also the xor elimination (similar to this one)\n\n    // A <= X, X != Y    ->    A !& Y\n    // X <= A, X != Y    ->    A | Y\n    // X | A, X != Y     ->    Y <= A\n    // X !& A, X != Y    ->    A <= Y\n    // A -> X, X != Y    ->    A !& Y\n    // X -> A, X != Y    ->    A | Y\n\n    TRACE('trick_diff_elimination');\n    TRACE(' - index:', indexX, '^', indexY);\n    TRACE(\n      ' - domains:',\n      domain__debug(getDomain(indexX)),\n      '!=',\n      domain__debug(getDomain(indexY))\n    );\n    TRACE(\n      ' - meta:',\n      bounty__debugMeta(bounty, indexX),\n      '!=',\n      bounty__debugMeta(bounty, indexY)\n    );\n    TRACE(\n      ' - verying; looking for one DIFF[2], `X != Y` and then we can morph any of these;'\n    );\n    TRACE('   - LTE_LHS:   X != Y, X <= A     =>    A | Y');\n    TRACE('   - LTE_RHS:   X != Y, A <= X     =>    A !& Y');\n    TRACE('   - SOME:      X != Y, X | A      =>    Y <= A    =>    Y -> A');\n    TRACE('   - NALL:      X != Y, X !& A     =>    A <= Y    =>    A -> Y');\n    TRACE('   - IMP_LHS:   X != Y, X -> A     =>    Y | A');\n    TRACE('   - IMP_RHS:   X != Y, A -> X     =>    A !& Y');\n\n    // First we need to validate. we can only have one diff and all ops can only have 2 args\n    ASSERT(\n      countsX < BOUNTY_MAX_OFFSETS_TO_TRACK,\n      'this was already checked in cut_diff'\n    );\n    ASSERT(\n      ml_dec16(ml, diffOffset + 1) === 2,\n      'the diff should be confirmed to have 2 args'\n    );\n\n    if (!domain_isBoolyPair(getDomain(indexX))) {\n      TRACE(' - X is non-bool, bailing');\n      return false;\n    }\n\n    // We need the offsets to eliminate them and to get the \"other\" var index for each\n    const lteLhsOffsets = [];\n    const lteLhsArgs = [];\n    const lteRhsOffsets = [];\n    const lteRhsArgs = [];\n    const someOffsets = [];\n    const someArgs = [];\n    const nallOffsets = [];\n    const nallArgs = [];\n    let seenDiff = false;\n    const diffArgs = [];\n    const impLhsOffsets = [];\n    const impLhsArgs = [];\n    const impRhsOffsets = [];\n    const impRhsArgs = [];\n    TRACE(' - scanning', countsX, 'offsets now..');\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      ASSERT(offset, 'the offset should exist...', offset);\n\n      const op = ml_dec8(ml, offset);\n      TRACE('   - pos=', i, ', offset=', offset, 'op=', ml__opName(op));\n\n      ASSERT(\n        op === ML_LTE ||\n          op === ML_DIFF ||\n          op === ML_SOME ||\n          op === ML_NALL ||\n          op === ML_IMP,\n        'should be one of these four ops, bounty said so',\n        ml__opName(op)\n      );\n\n      if (ml_dec16(ml, offset + 1) !== 2) {\n        TRACE(' - op does not have 2 args, bailing');\n        return false;\n      }\n\n      const indexA = readIndex(ml, offset + OFFSET_C_A);\n      const indexB = readIndex(ml, offset + OFFSET_C_B);\n      const A = getDomain(indexA, true);\n      const B = getDomain(indexB, true);\n      ASSERT(\n        indexA === indexX || indexB === indexX,\n        'bounty should only track ops that use target var'\n      );\n      if (!domain_isBoolyPair(indexA === indexX ? B : A)) {\n        TRACE(' - found an op with a non-bool arg, bailing');\n        return false;\n      }\n\n      const indexC = indexA === indexX ? indexB : indexA;\n\n      if (op === ML_LTE) {\n        // A ^ B, A <= C\n        // [00022]^[01],[0022]<=[01]  what if B must end up zero?\n        // we have to make sure the lte constraint can not possibly be broken at this point\n        if (domain_max(A) > domain_max(B) || domain_min(B) < domain_min(A)) {\n          TRACE(\n            ' - there are valuations of A and B that could break LTE, bailing because minimizer can fix this'\n          );\n          requestAnotherCycle = true;\n          return false;\n        }\n\n        if (indexA === indexX) {\n          lteLhsOffsets.push(offset);\n          lteLhsArgs.push(indexC);\n        } else {\n          lteRhsOffsets.push(offset);\n          lteRhsArgs.push(indexC);\n        }\n      } else if (op === ML_IMP) {\n        if (indexA === indexX) {\n          impLhsOffsets.push(offset);\n          impLhsArgs.push(indexC);\n        } else {\n          impRhsOffsets.push(offset);\n          impRhsArgs.push(indexC);\n        }\n      } else if (op === ML_DIFF) {\n        if (diffOffset !== offset) {\n          TRACE(\n            ' - found a different DIFF, this trick only works on one, bailing'\n          );\n          return false;\n        }\n\n        ASSERT(indexC === indexY);\n        diffArgs.push(indexC);\n        seenDiff = true;\n      } else if (op === ML_SOME) {\n        someOffsets.push(offset);\n        someArgs.push(indexC);\n      } else {\n        ASSERT(op === ML_NALL, 'see assert above');\n        nallOffsets.push(offset);\n        nallArgs.push(indexC);\n      }\n    }\n\n    TRACE(\n      ' - collection complete; indexY =',\n      indexY,\n      ', diff offset =',\n      diffOffset,\n      ', lte lhs offsets:',\n      lteLhsOffsets,\n      ', lte rhs offsets:',\n      lteRhsOffsets,\n      ', SOME offsets:',\n      someOffsets,\n      ', nall offsets:',\n      nallOffsets,\n      ', imp lhs offsets:',\n      impLhsOffsets,\n      ', imp rhs offsets:',\n      impRhsOffsets\n    );\n\n    ASSERT(seenDiff, 'should have seen a diff, bounty said there would be one');\n\n    // Okay. pattern matches. do the rewrite\n\n    TRACE(' - pattern confirmed, morphing ops, removing diff');\n    TRACE('   - X != Y, X <= A     =>    A | Y');\n    TRACE('   - X != Y, A <= X     =>    A !& Y');\n    TRACE('   - X != Y, X | A      =>    Y <= A    =>    Y -> A');\n    TRACE('   - X != Y, X !& A     =>    A <= Y    =>    A -> Y');\n    TRACE('   - X != Y, X -> A     =>    Y | A');\n    TRACE('   - X != Y, A -> X     =>    A !& Y');\n\n    TRACE_MORPH('X != Y', '', 'inverting LTE, SOME, NALL, IMP');\n\n    TRACE(' - processing', lteLhsOffsets.length, 'LTE_LHS ops');\n    for (let i = 0, len = lteLhsOffsets.length; i < len; ++i) {\n      TRACE_MORPH('X <= A, X != Y', 'A | Y');\n      const offset = lteLhsOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_SOME, index, indexY);\n    }\n\n    TRACE(' - processing', lteRhsOffsets.length, 'LTE_RHS ops');\n    for (let i = 0, len = lteRhsOffsets.length; i < len; ++i) {\n      TRACE_MORPH('X <= A, X != Y', 'A | Y');\n      const offset = lteRhsOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_NALL, index, indexY);\n    }\n\n    // Note: this bit is kind of redundant (and untested) because it's rewritten and picked up elsewhere\n    TRACE(' - processing', someOffsets.length, 'SOME ops');\n    for (let i = 0, len = someOffsets.length; i < len; ++i) {\n      TRACE_MORPH('X | A, X != Y', 'Y <= A');\n      const offset = someOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(ml_dec8(ml, offset) === ML_SOME, 'right?');\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_LTE, indexY, index);\n    }\n\n    TRACE(' - processing', nallOffsets.length, 'NALL ops');\n    for (let i = 0, len = nallOffsets.length; i < len; ++i) {\n      TRACE_MORPH('X !& A, X != Y', 'A <= Y');\n      const offset = nallOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_LTE, index, indexY);\n    }\n\n    TRACE(' - processing', impLhsOffsets.length, 'IMP_LHS ops');\n    for (let i = 0, len = impLhsOffsets.length; i < len; ++i) {\n      TRACE_MORPH('X -> A, X != Y', 'A | Y');\n      const offset = impLhsOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_SOME, index, indexY);\n    }\n\n    TRACE(' - processing', impRhsOffsets.length, 'IMP_RHS ops');\n    for (let i = 0, len = impRhsOffsets.length; i < len; ++i) {\n      TRACE_MORPH('X -> A, X != Y', 'A | Y');\n      const offset = impRhsOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_NALL, index, indexY);\n    }\n\n    TRACE(' - and finally removing the DIFF');\n    ASSERT(ml_dec16(ml, diffOffset + 1) === 2, 'diff should have 2 args here');\n    ml_eliminate(ml, diffOffset, SIZEOF_C_2);\n\n    TRACE(' - X is a leaf constraint, defer it', indexX);\n    leafs.push(indexX);\n    solveStack.push((_, force, getDomain, setDomain) => {\n      let X = getDomain(indexX);\n      let Y = getDomain(indexY);\n      TRACE(\n        ' - diff + ops...;',\n        indexX,\n        '!=',\n        indexY,\n        '  ->  ',\n        domain__debug(X),\n        '!=',\n        domain__debug(getDomain(indexY))\n      );\n\n      // TRACE(' - X:',domain__debug(X));\n      // TRACE(' - Y:',domain__debug(getDomain(indexY)));\n      // TRACE(' - ltelhs:', lteLhsArgs.map(a=>domain__debug(getDomain(a))));\n      // TRACE(' - lterhs:', lteRhsArgs.map(a=>domain__debug(getDomain(a))));\n      // TRACE(' - some:', someArgs.map(a=>domain__debug(getDomain(a))));\n      // TRACE(' - nall:', nallArgs.map(a=>domain__debug(getDomain(a))));\n      // TRACE(' - implhs:', impLhsArgs.map(a=>domain__debug(getDomain(a))));\n      // TRACE(' - imprhs:', impRhsArgs.map(a=>domain__debug(getDomain(a))));\n\n      const oX = X;\n\n      const minX = domain_min(X);\n      const maxX = domain_max(X);\n\n      TRACE('  - applying', lteLhsArgs.length, 'LTELHSs (X <= vars)');\n      for (let i = 0; i < lteLhsArgs.length; ++i) {\n        // X <= D\n        const index = lteLhsArgs[i];\n        let D = getDomain(index);\n        TRACE('    - index:', index, ', domain:', domain__debug(D));\n        const minD = domain_min(D);\n        if (maxX > minD) {\n          const maxD = domain_max(D);\n          // At least one value of X is larger than a value in D so there is currently\n          // a valuation of X and D that violates the LTE and we must fix that.\n          if (maxD >= maxX) {\n            // There are values in D that are larger-eq to all values in X. use them.\n            // just remove the intersecting values from D and then lte should satisfy\n            D = domain_removeLtUnsafe(D, maxX);\n            setDomain(index, D);\n          } else {\n            // The largest value of D is smaller than the largest X\n            // maximize D then remove any value from X larger than that\n            D = domain_intersectionValue(D, maxD);\n            setDomain(index, D);\n            X = domain_removeGtUnsafe(X, maxD);\n          }\n\n          ASSERT(D);\n          ASSERT(X);\n          ASSERT(domain_max(X) <= domain_min(D));\n        }\n      }\n\n      TRACE('   - X after LTELHSs:', domain__debug(X));\n\n      TRACE('  - applying', lteRhsArgs.length, 'LTERHSs (vars <= X)');\n      for (let i = 0; i < lteRhsArgs.length; ++i) {\n        // D <= X\n        const index = lteRhsArgs[i];\n        let D = getDomain(index);\n        TRACE('    - index:', index, ', domain:', domain__debug(D));\n        const maxD = domain_max(D);\n        if (minX < maxD) {\n          // At least one value in X is smaller than a value in D so there is currently\n          // a valuation of X and D that violates the LTE and we must fix that.\n          const minD = domain_min(D);\n          if (minD <= minX) {\n            // There are values in D that are smaller-eq to all values in X. use them.\n            // just remove the intersecting values from D and then lte should satisfy\n            D = domain_removeGtUnsafe(D, minX);\n            setDomain(index, D);\n          } else {\n            // The smallest value of D is larger than the smallest X\n            // minimze D then remove any value from X smaller than that\n            D = domain_intersectionValue(D, minD);\n            setDomain(index, D);\n            X = domain_removeLtUnsafe(X, maxD);\n          }\n        }\n\n        ASSERT(D);\n        ASSERT(X);\n        ASSERT(domain_max(D) <= domain_min(X));\n      }\n\n      TRACE('   - X after LTERHSs:', domain__debug(X));\n\n      // Reminder: these are pairs. some(X D) for each d in someArgs\n      for (let i = 0; i < someArgs.length; ++i) {\n        // Some(X ...)\n        const index = someArgs[i];\n        let D = getDomain(index);\n        TRACE(\n          '    - index:',\n          index,\n          ', domain:',\n          domain__debug(getDomain(index))\n        );\n        if (domain_isZero(D)) {\n          // X must be nonzero now\n          X = domain_removeValue(X, 0);\n        } else if (domain_hasZero(D)) {\n          ASSERT(\n            domain_isBooly(D),\n            'assuming D isnt empty, and it wasnt zero but has a zero, it should be a booly'\n          );\n          D = domain_removeValue(D, 0);\n          setDomain(index, D);\n        }\n\n        ASSERT(X);\n        ASSERT(D);\n        ASSERT(domain_hasNoZero(X) || domain_hasNoZero(D));\n      }\n\n      TRACE('   - X after SOMEs:', domain__debug(X));\n\n      // Reminder: these are pairs. nall(X D) for each d in nallArgs\n      for (let i = 0; i < nallArgs.length; ++i) {\n        // Nall(X ...)\n        const index = nallArgs[i];\n        let D = getDomain(index);\n        TRACE('    - index:', index, ', domain:', domain__debug(D));\n        if (domain_hasNoZero(D)) {\n          // X must be zero\n          X = domain_removeGtUnsafe(X, 0);\n        } else if (domain_hasNoZero(D)) {\n          ASSERT(\n            domain_isBooly(D),\n            'assuming D isnt empty, and it wasnt nonzero, it should be a booly'\n          );\n          D = domain_removeGtUnsafe(D, 0);\n          setDomain(index, D);\n        }\n\n        ASSERT(X);\n        ASSERT(D);\n        ASSERT(domain_isZero(X) || domain_isZero(D));\n      }\n\n      TRACE('   - X after NALLs:', domain__debug(X));\n\n      for (let i = 0; i < impLhsArgs.length; ++i) {\n        // X -> D\n        const index = impLhsArgs[i];\n        const D = getDomain(index);\n        TRACE('    - index:', index, ', domain:', domain__debug(D));\n\n        // The easiest out is that D is either nonzero or that X is zero\n        if (!domain_hasNoZero(D) && !domain_isZero(X)) {\n          if (domain_isZero(D)) {\n            // X must be zero otherwise the implication doesnt hold\n            X = domain_removeGtUnsafe(X, 0);\n          } else if (domain_hasNoZero(D)) {\n            // X must be nonzero because D is nonzero\n            X = domain_removeValue(X, 0);\n          } else {\n            ASSERT(domain_isBooly(D));\n            // Setting D to nonzero is the safest thing to do\n            setDomain(index, domain_removeValue(D, 0));\n          }\n        }\n\n        ASSERT(X);\n        ASSERT(D);\n        ASSERT(domain_hasNoZero(X) ? domain_hasNoZero(D) : true);\n        ASSERT(domain_isZero(D) ? domain_isZero(X) : true);\n        ASSERT(\n          domain_isSolved(D) || domain_isZero(X),\n          'if X is zero then D doesnt matter. if D is solved then X is asserted to be fine above'\n        );\n      }\n\n      TRACE('   - X after IMPLHSs:', domain__debug(X));\n\n      for (let i = 0; i < impRhsArgs.length; ++i) {\n        // D -> X\n        const index = impRhsArgs[i];\n        let D = getDomain(index);\n        TRACE('    - index:', index, ', domain:', domain__debug(D));\n\n        if (domain_hasNoZero(D)) {\n          // X must be nonzero\n          X = domain_removeGtUnsafe(X, 0);\n        } else if (domain_isBooly(D)) {\n          // Safest value for imp-lhs is 0\n          D = domain_removeValue(D, 0);\n        }\n\n        ASSERT(X);\n        ASSERT(D);\n        ASSERT(domain_hasNoZero(D) ? domain_hasNoZero(X) : true);\n        ASSERT(domain_isZero(X) ? domain_isZero(D) : true);\n        ASSERT(\n          domain_isSolved(X) || domain_isZero(D),\n          'if D is zero then X doesnt matter. if X is solved then D is asserted to be fine above'\n        );\n      }\n\n      TRACE('   - X after IMPRHSs:', domain__debug(X));\n\n      // X != Y\n      TRACE(' - != Y:', domain__debug(getDomain(indexY)));\n      if (domain_isSolved(X)) {\n        Y = domain_removeValue(Y, domain_getValue(X));\n        setDomain(indexY, Y);\n      } else {\n        X = domain_removeValue(X, force(indexY));\n      }\n\n      TRACE('   - X after DIFFs:', domain__debug(X));\n\n      ASSERT(X, 'X should be able to reflect any solution');\n      if (X !== oX) setDomain(indexX, X);\n    });\n\n    bounty_markVar(bounty, indexX);\n    bounty_markVar(bounty, indexY);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_xor_elimination(xorOffset, indexX, countsX, indexY) {\n    // The xor is basically a diff (!=) in a booly sense. so we can invert all the affected ops by inverting the xor.\n    // bascially we \"invert\" a xor by aliasing one arg to the other arg and then inverting all ops that relate to it\n\n    // all targeted ops should only have 2 args\n\n    // X | A, X ^ Y     ->    Y <= A\n    // X !& A, X ^ Y    ->    A <= Y\n    // A -> X, X ^ Y    ->    A !& Y\n    // X -> A, X ^ Y    ->    A | Y\n\n    // note: eligible LTEs must be morphed to an implication first\n    // A <= X, X ^ Y    ->    A !& Y\n    // X <= A, X ^ Y    ->    A | Y\n\n    TRACE('trick_xor_elimination');\n    TRACE(' - index:', indexX, '^', indexY);\n    TRACE(\n      ' - domains:',\n      domain__debug(getDomain(indexX)),\n      '^',\n      domain__debug(getDomain(indexY))\n    );\n    TRACE(\n      ' - meta:',\n      bounty__debugMeta(bounty, indexX),\n      '^',\n      bounty__debugMeta(bounty, indexY)\n    );\n    TRACE(\n      ' - verying; looking for a XOR, `X ^ Y` and then we can morph any of these;'\n    );\n    // TRACE('   - LTE_LHS:   X ^ Y, X <= A     =>    A | Y');\n    // TRACE('   - LTE_RHS:   X ^ Y, A <= X     =>    A !& Y');\n    TRACE('   - SOME:      X ^ Y, X | A      =>    Y <= A    =>    Y -> A');\n    TRACE('   - NALL:      X ^ Y, X !& A     =>    A <= Y    =>    A -> Y');\n    TRACE('   - IMP_LHS:   X ^ Y, X -> A     =>    Y | A');\n    TRACE('   - IMP_RHS:   X ^ Y, A -> X     =>    A !& Y');\n    TRACE(' - all args must be booly pairs, or bounty-booly without LTE');\n\n    ASSERT(\n      countsX < BOUNTY_MAX_OFFSETS_TO_TRACK,\n      'this was already checked in cut_xor'\n    );\n    ASSERT(ml_dec16(ml, xorOffset + 1) === 2, 'XORs only have two args');\n\n    if (!domain_isBooly(getDomain(indexX))) {\n      TRACE(' - X is non-bool, bailing');\n      return false;\n    }\n\n    // We need the offsets to eliminate them and to get the \"other\" var index for each\n    // first we need to validate.\n    // - we can only have one XOR\n    // - all ops must have 2 args\n    // - the \"other\" arg must also be a booly-pair or bounty-booly\n    const someOffsets = [];\n    const nallOffsets = [];\n    let seenXor = false;\n    const impLhsOffsets = [];\n    const impRhsOffsets = [];\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      ASSERT(offset, 'the offset should exist...', offset);\n\n      const op = ml_dec8(ml, offset);\n\n      ASSERT(\n        op === ML_XOR || op === ML_SOME || op === ML_NALL || op === ML_IMP,\n        'should be one of these four ops, bounty said so',\n        ml__opName(op)\n      );\n\n      if (ml_dec16(ml, offset + 1) !== 2) {\n        TRACE(\n          ' - op',\n          ml__opName(op),\n          'does not have 2 args (',\n          ml_dec16(ml, offset + 1),\n          '), bailing'\n        );\n        return false;\n      }\n\n      const indexA = readIndex(ml, offset + OFFSET_C_A);\n      const indexB = readIndex(ml, offset + OFFSET_C_B);\n      ASSERT(\n        indexA === indexX || indexB === indexX,\n        'bounty should only track ops that use target var'\n      );\n\n      TRACE(\n        '    - current offset:',\n        offset,\n        ', op:',\n        ml__opName(op),\n        'indexes:',\n        indexA,\n        indexB,\n        ', domains:',\n        domain__debug(getDomain(indexA, true)),\n        domain__debug(getDomain(indexB, true))\n      );\n\n      // Get pair\n      const indexT = indexA === indexX ? indexB : indexA;\n\n      if (bounty_getCounts(bounty, indexT) === 0) {\n        TRACE(\n          ' - an arg was marked (counts=0), bailing (we will get this in the rebound)'\n        );\n        // Note: while there may be other ops that could be converted, we'll\n        // get at least one more cutter pass and we'll eventually retry this\n        return false;\n      }\n\n      const T = getDomain(indexT, true);\n      if (\n        !domain_isBoolyPair(T) &&\n        hasFlags(bounty_getMeta(bounty, indexT), BOUNTY_FLAG_NOT_BOOLY)\n      ) {\n        TRACE(\n          ' - found an \"other\" var that was marked not booly in its meta and not a booly pair, bailing'\n        );\n        return false;\n      }\n\n      if (op === ML_IMP) {\n        if (indexA === indexX) {\n          if (impLhsOffsets.indexOf(offset) < 0) impLhsOffsets.push(offset);\n        } else if (impRhsOffsets.indexOf(offset) < 0)\n          impRhsOffsets.push(offset);\n      } else if (op === ML_XOR) {\n        if (xorOffset !== offset) {\n          TRACE(\n            ' - found a different XOR, this trick only works on one, bailing'\n          );\n          return false;\n        }\n\n        seenXor = true;\n      } else if (op === ML_SOME) {\n        if (ml_dec16(ml, offset + 1) !== 2) {\n          TRACE(' - There was a SOME that did not have 2 args, bailing');\n        }\n\n        if (someOffsets.indexOf(offset) < 0) someOffsets.push(offset);\n      } else {\n        ASSERT(op === ML_NALL, 'see assert above');\n        if (nallOffsets.indexOf(offset) < 0) nallOffsets.push(offset);\n      }\n    }\n\n    TRACE(\n      ' - collection complete; indexY =',\n      indexY,\n      ', XOR offset =',\n      xorOffset,\n      ', SOME offsets:',\n      someOffsets,\n      ', NALL offsets:',\n      nallOffsets,\n      ', IMP_LHS offsets:',\n      impLhsOffsets,\n      ', IMP_RHS offsets:',\n      impRhsOffsets\n    );\n\n    ASSERT(seenXor, 'should have seen a XOR, bounty said there would be one');\n\n    // Okay. pattern matches. do the rewrite\n\n    TRACE(' - pattern confirmed, morphing ops, removing XOR');\n    // TRACE('   - X ^ Y, X <= A     =>    A | Y');\n    // TRACE('   - X ^ Y, A <= X     =>    A !& Y');\n    TRACE('   - X ^ Y, X | A      =>    Y -> A; offsets:', someOffsets);\n    TRACE('   - X ^ Y, X !& A     =>    A -> Y; offsets:', nallOffsets);\n    TRACE('   - X ^ Y, X -> A     =>    Y | A; offsets:', impLhsOffsets);\n    TRACE('   - X ^ Y, A -> X     =>    A !& Y; offsets:', impRhsOffsets);\n\n    TRACE_MORPH('X ^ Y, inverting LTE, SOME, NALL, IMP', '');\n\n    TRACE(' - processing', someOffsets.length, 'SOME ops');\n    for (let i = 0, len = someOffsets.length; i < len; ++i) {\n      // X | A, X != Y    ->    Y <= A\n      const offset = someOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(ml_dec8(ml, offset) === ML_SOME, 'right?');\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_IMP, indexY, index);\n    }\n\n    TRACE(' - processing', nallOffsets.length, 'NALL ops');\n    for (let i = 0, len = nallOffsets.length; i < len; ++i) {\n      // X !& A, X != Y    ->    A <= Y\n      const offset = nallOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_IMP, index, indexY);\n    }\n\n    TRACE(' - processing', impLhsOffsets.length, 'IMP_LHS ops');\n    for (let i = 0, len = impLhsOffsets.length; i < len; ++i) {\n      // X -> A, X != Y    ->    A | Y\n      const offset = impLhsOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_SOME, index, indexY);\n    }\n\n    TRACE(' - processing', impRhsOffsets.length, 'IMP_RHS ops');\n    for (let i = 0, len = impRhsOffsets.length; i < len; ++i) {\n      // X -> A, X != Y    ->    A | Y\n      const offset = impRhsOffsets[i];\n      let index = readIndex(ml, offset + OFFSET_C_A);\n      if (index === indexX) index = readIndex(ml, offset + OFFSET_C_B);\n      bounty_markVar(bounty, index);\n      ASSERT(\n        ml_dec16(ml, offset + 1) === 2,\n        'should be explicitly checked above'\n      );\n      ml_c2c2(ml, offset, 2, ML_NALL, index, indexY);\n    }\n\n    TRACE(' - and finally removing the XOR');\n    ASSERT(ml_dec16(ml, xorOffset + 1) === 2, 'diff should have 2 args here');\n    ml_eliminate(ml, xorOffset, SIZEOF_C_2);\n\n    TRACE(' - X is a leaf constraint, defer it', indexX);\n    leafs.push(indexX);\n    solveStack.push((_, force, getDomain, setDomain) => {\n      let X = getDomain(indexX);\n      TRACE(\n        ' - xor + ops...;',\n        indexX,\n        '^',\n        indexY,\n        '  ->  ',\n        domain__debug(X),\n        '^',\n        domain__debug(getDomain(indexY))\n      );\n\n      if (force(indexY) === 0) {\n        X = domain_removeValue(X, 0);\n      } else {\n        X = domain_removeGtUnsafe(X, 0);\n      }\n\n      ASSERT(X, 'X should be able to reflect any solution');\n      setDomain(indexX, X);\n    });\n\n    bounty_markVar(bounty, indexX);\n    bounty_markVar(bounty, indexY);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_diff_xor(ml, diffOffset, indexX, countsX, indexA) {\n    TRACE('trick_diff_xor');\n    TRACE(' - X != A, X ^ B    =>    X!=A,A==B');\n\n    // Find the xor. X may a counts > 2\n    let xorOffset = 0;\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      if (ml_dec8(ml, offset) === ML_XOR) {\n        xorOffset = offset;\n      }\n    }\n\n    ASSERT(xorOffset, 'bounty said there was at least one xor', xorOffset);\n\n    if (ml_dec16(ml, xorOffset + 1) !== 2) {\n      TRACE(' - the XOR did not have 2 args, bailing');\n      return false;\n    }\n\n    ASSERT(\n      readIndex(ml, xorOffset + OFFSET_C_A) === indexX ||\n        readIndex(ml, xorOffset + OFFSET_C_B) === indexX,\n      'X should be part of XOR'\n    );\n    let indexB = readIndex(ml, xorOffset + OFFSET_C_A);\n    if (indexB === indexX) indexB = readIndex(ml, xorOffset + OFFSET_C_B);\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n    const X = getDomain(indexX, true);\n\n    TRACE(' - indexes:', indexX, '!=', indexA, ',', indexX, '^', indexB);\n    TRACE(\n      ' - domains:',\n      domain__debug(X),\n      '!=',\n      domain__debug(A),\n      ',',\n      domain__debug(X),\n      '^',\n      domain__debug(B)\n    );\n\n    if (\n      !domain_isBoolyPair(A) ||\n      !domain_isBoolyPair(B) ||\n      domain_intersection(X, A) !== A ||\n      domain_intersection(X, B) !== B\n    ) {\n      // Note: this implicitly tested whether A is a booly\n      TRACE(\n        ' - A or B wasnt a boolypair or A did not contain all values, bailing'\n      );\n      return false;\n    }\n\n    TRACE(' - pattern confirmed');\n    TRACE_MORPH('X != A, X ^ B', 'X ^ A, A == B');\n\n    ml_eliminate(ml, diffOffset, SIZEOF_C_2);\n\n    cutAddPseudoBoolyAlias(indexB, indexA);\n    somethingChanged();\n\n    return true;\n  }\n\n  function trick_diff_alias(indexX, indexY, countsX) {\n    TRACE(\n      'trick_diff_alias; index X:',\n      indexX,\n      ', index Y:',\n      indexY,\n      ', counts:',\n      countsX\n    );\n    TRACE(' - X!=A,X!=B, size(A)==2,min(A)==min(B),max(A)==max(B)   =>   A==B');\n\n    const X = getDomain(indexX);\n    const Y = getDomain(indexY);\n    TRACE(\n      ' - domains:',\n      domain__debug(X),\n      domain__debug(Y),\n      '(trick only works if these are equal and size=2)'\n    );\n    if (X === Y && domain_size(X) === 2) {\n      // If we can find another diff on X where the domain is also equal to X, we can alias Y to that var\n\n      for (let i = 0; i < countsX; ++i) {\n        const offset = bounty_getOffset(bounty, indexX, i);\n        ASSERT(offset, 'the offset should exist...', offset);\n\n        const op = ml_dec8(ml, offset);\n        TRACE('   - checking offset=', offset, 'op=', op, op === ML_DIFF);\n        if (op === ML_DIFF) {\n          const count = ml_dec16(ml, offset + 1);\n          TRACE('     - is diff with', count, 'indexes');\n          if (count !== 2) {\n            TRACE(\n              '       - count must be 2 for this to work, moving to next op'\n            );\n            continue;\n          }\n\n          const indexA = readIndex(ml, offset + OFFSET_C_A);\n          const indexB = readIndex(ml, offset + OFFSET_C_B);\n          TRACE(\n            ' - indexes:',\n            indexA,\n            indexB,\n            ', domains:',\n            domain__debug(getDomain(indexA)),\n            domain__debug(getDomain(indexB))\n          );\n          ASSERT(\n            indexA === indexX || indexB === indexX,\n            'xor should have X as either arg because bounty said so'\n          );\n          let indexZ;\n          if (indexA === indexX) {\n            if (indexB === indexY) continue;\n            indexZ = indexB;\n          } else {\n            ASSERT(indexB === indexX, 'x should match at least one side');\n            if (indexA === indexY) continue;\n            indexZ = indexA;\n          }\n\n          TRACE('     - not original diff, Z=', indexZ);\n\n          ASSERT(\n            indexY !== indexZ,\n            'deduper should have eliminated duplicate diffs'\n          );\n\n          const Z = getDomain(indexZ);\n          if (X === Z) {\n            TRACE(\n              '     - domains are equal so X!=Y, X!=Z, with X==Y==Z, with size(X)=2, so Y=Z, index',\n              indexY,\n              '=',\n              indexZ\n            );\n            TRACE('     - eliminating this diff, aliasing Z to Y');\n\n            ASSERT(Y === Z);\n            ASSERT(domain_size(Z) === 2);\n\n            // No solve stack required, indexY == indexZ\n            addAlias(indexZ, indexY, 'double bin diff');\n            ml_eliminate(ml, offset, SIZEOF_C_2);\n\n            bounty_markVar(bounty, indexX);\n            bounty_markVar(bounty, indexY);\n            bounty_markVar(bounty, indexZ);\n            somethingChanged();\n            return true;\n          }\n        }\n      }\n    }\n\n    TRACE(' - unable to apply trick_diff_alias, bailing');\n    return false;\n  }\n\n  function trick_xor_alias(indexX, indexY, countsX, Y, sizeY, YisBooly) {\n    TRACE(\n      'trick_xor_alias; index X:',\n      indexX,\n      ', index Y:',\n      indexY,\n      ', counts:',\n      countsX,\n      ', sizeY:',\n      sizeY\n    );\n    ASSERT(indexX !== indexY, 'X^Y is falsum and shouldnt occur here');\n\n    // We are looking for `X^Y,X^B` and if `size(A)==2,dA==dB` or B is a booly then we alias them\n\n    const YisPair = sizeY === 2;\n\n    TRACE(\n      ' - domains:',\n      domain__debug(getDomain(indexX)),\n      domain__debug(Y),\n      'Y is booly var?',\n      YisBooly,\n      ', Y size?',\n      sizeY\n    );\n    if (!YisBooly && !YisPair) {\n      TRACE(\n        ' - Y is neither a booly var nor a pair so cant apply this trick; bailing'\n      );\n      return false;\n    }\n\n    // We now search for any xor that uses x but not y as z\n    // the first z to match YisBooly or domain y==z will be aliased\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      ASSERT(offset, 'the offset should exist...', offset);\n\n      const op = ml_dec8(ml, offset);\n      TRACE('   - checking offset=', offset, 'op=', op, op === ML_XOR);\n      if (op === ML_XOR) {\n        const indexA = readIndex(ml, offset + OFFSET_C_A);\n        const indexB = readIndex(ml, offset + OFFSET_C_B);\n        TRACE(\n          '     - is xor, indexes:',\n          indexA,\n          indexB,\n          'confirming its not the input X and Y',\n          indexX,\n          indexY,\n          '( -> it',\n          (indexX === indexA && indexY === indexB) ||\n            (indexX === indexB && indexY === indexA)\n            ? 'is'\n            : 'isnt',\n          ')'\n        );\n        ASSERT(\n          indexA === indexX || indexB === indexX,\n          'at least one argument should match X since it is X-es bounty'\n        );\n\n        let indexZ;\n        if (indexA === indexX) {\n          if (indexB === indexY) continue;\n          indexZ = indexB;\n        } else if (indexB === indexX) {\n          if (indexA === indexY) continue;\n          indexZ = indexA;\n        } else {\n          THROW('X should be left or right of its xors');\n        }\n\n        ASSERT(\n          indexY !== indexZ,\n          'deduper should have eliminated duplicate xors',\n          indexX,\n          indexY,\n          indexA,\n          indexB\n        );\n\n        let aliased = false;\n        const Z = getDomain(indexZ, true);\n        if (YisPair && Z === Y) {\n          TRACE(\n            ' - true aliases. X^Y X^Z, ' +\n              indexX +\n              '^' +\n              indexY +\n              ' ' +\n              indexX +\n              '^' +\n              indexZ +\n              ', aliasing',\n            indexZ,\n            'to',\n            indexY\n          );\n          // Keep the current xor (X^Y) and drop the found xor (X^Z)\n          addAlias(indexZ, indexY);\n          aliased = true;\n        } else if (YisPair && domain_size(Z) === 2) {\n          TRACE(\n            ' - pseudo aliases. X^Y X^Z, ' +\n              indexX +\n              '^' +\n              indexY +\n              ' ' +\n              indexX +\n              '^' +\n              indexZ +\n              ', aliasing',\n            indexZ,\n            'to',\n            indexY\n          );\n          TRACE(\n            ' - since Y and Z can only be \"zero or nonzero\", the xor forces them to pick either the zero or nonzero value, regardless of anything else'\n          );\n          // Keep the current xor (X^Y) and drop the found xor (X^Z)\n          cutAddPseudoBoolyAlias(indexY, indexZ);\n          aliased = true;\n        } else if (YisBooly) {\n          const metaZ = getMeta(bounty, indexZ, true); // Keep booly flag\n          TRACE(\n            ' - Z isnt a pair, checking meta for booly:',\n            bounty__debugMeta(bounty, indexZ)\n          );\n          if (!hasFlags(metaZ, BOUNTY_FLAG_NOT_BOOLY)) {\n            TRACE(\n              ' - Y and Z are both booly and xor on the same variable. so this is a pseudo alias. slash the found xor.'\n            );\n            // Keep the current xor (X^Y) and drop the found xor (X^Z)\n            cutAddPseudoBoolyAlias(indexY, indexZ);\n            aliased = true;\n          }\n        }\n\n        if (aliased) {\n          TRACE(' - Y was aliased to Z, eliminating this xor and returning');\n          ml_eliminate(ml, offset, SIZEOF_C_2);\n          bounty_markVar(bounty, indexX);\n          bounty_markVar(bounty, indexY); // The alias will mess up Y counts\n          bounty_markVar(bounty, indexZ);\n          somethingChanged();\n          return true;\n        }\n\n        TRACE(' - Z did not match. moving to next constraint');\n      }\n    }\n\n    TRACE('  - did not find a second xor; bailing');\n    return false;\n  }\n\n  function trick_isall_xor(indexA, indexB, xorOffset, countsA, countsB) {\n    TRACE(\n      'trick_isall_xor; index A:',\n      indexA,\n      ', index B:',\n      indexB,\n      ', counts:',\n      countsA,\n      countsB\n    );\n    ASSERT(countsA === 2, 'check function if this changes', countsA, countsB);\n\n    // R^A, R=all?(X Y Z)  ->   A=nall(X Y Z)\n    // the xor kind of acts like a diff in this case so we flip the isall to become a isnall on xor's other arg\n    // we defer R to be xor A in the solvestack\n\n    TRACE(' - first searching for isall op');\n    for (let i = 0; i < countsA; ++i) {\n      const offset = bounty_getOffset(bounty, indexA, i);\n      ASSERT(\n        offset,\n        'there should be as many offsets as counts unless that exceeds the max and that has been checked already'\n      );\n      if (offset !== xorOffset) {\n        const opcode = ml_dec8(ml, offset);\n        if (opcode === ML_ISALL) {\n          TRACE(' - found isall at', offset);\n          return _trick_isall_xor(indexA, indexB, xorOffset, offset);\n        }\n      }\n    }\n\n    THROW('bounty should have asserted that an isall existed');\n  }\n\n  function _trick_isall_xor(indexR, indexB, xorOffset, isallOffset) {\n    TRACE_MORPH('R^S, R=all?(X Y Z ...)', 'S=nall(X Y Z ...)');\n    TRACE(\n      ' - _trick_isall_xor: now applying morph to isall and eliminating the xor'\n    );\n    // Note: R only has 2 counts\n\n    const isallArgCount = ml_dec16(ml, isallOffset + 1);\n    ASSERT(\n      getAlias(ml_dec16(ml, isallOffset + SIZEOF_C + isallArgCount * 2)) ===\n        indexR\n    );\n\n    // Morph the isall to an isnall (simply change the op) on B. dont forget to mark all its args\n    ml_enc8(ml, isallOffset, ML_ISNALL);\n    ml_enc16(ml, isallOffset + SIZEOF_C + isallArgCount * 2, indexB);\n    ml_eliminate(ml, xorOffset, SIZEOF_C_2);\n\n    // A of xor is R of isall. defer resolving the xor because B of xor\n    // is going to be the new R of the isall-flipped-to-isnall\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - _trick_isall_xor');\n\n      let R = getDomain(indexR);\n      let B = getDomain(indexB);\n      TRACE(' -', domain__debug(R), '^', domain__debug(B));\n\n      // Since S is solved according to \"not isall\", we only have to force R^S here\n      // (we didnt eliminate the isall, we just transformed it)\n\n      ASSERT(domain_isBooly(R));\n      if (domain_isBooly(B)) B = domain_createValue(force(indexB));\n      if (domain_isZero(B)) {\n        R = domain_removeValue(R, 0);\n      } else {\n        ASSERT(domain_hasNoZero(B));\n        R = domain_removeGtUnsafe(R, 0);\n      }\n\n      setDomain(indexR, R);\n\n      ASSERT(getDomain(indexR));\n      ASSERT(getDomain(indexB));\n      ASSERT(\n        !domain_isBooly(getDomain(indexR)) && !domain_isBooly(getDomain(indexB))\n      );\n      ASSERT(\n        domain_isZero(getDomain(indexR)) !== domain_isZero(getDomain(indexB))\n      );\n    });\n\n    bounty_markVar(bounty, indexR); // R\n    bounty_markVar(bounty, indexB);\n    markAllArgs(ml, isallOffset, isallArgCount);\n    somethingChanged();\n\n    return true;\n  }\n\n  function trick_issome_xor(indexA, indexR, xorOffset, countsA, countsB) {\n    TRACE(\n      'trick_issome_xor; index A:',\n      indexA,\n      ', index R:',\n      indexR,\n      ', counts:',\n      countsA,\n      countsB\n    );\n    TRACE(' - A^R, R=all?(X Y Z)  ->   A=nall(X Y Z)');\n\n    // The xor kind of acts like a diff in this case so we flip the isall to become a isnone\n    // and use A as the new result var for that isnone\n\n    TRACE(' - first searching for issome op');\n\n    for (let i = 0; i < countsA; ++i) {\n      const offset = bounty_getOffset(bounty, indexA, i);\n      if (offset !== xorOffset) {\n        const opcode = ml_dec8(ml, offset);\n        if (opcode === ML_ISSOME) {\n          TRACE(' - found issome at', offset);\n          return _trick_issome_xor(indexA, indexR, xorOffset, offset);\n        }\n      }\n    }\n\n    THROW('bounty should have asserted that an issome existed');\n  }\n\n  function _trick_issome_xor(indexR, indexA, xorOffset, issomeOffset) {\n    TRACE(\n      ' - _trick_issome_xor: now applying morph to issome and eliminating the xor'\n    );\n    TRACE_MORPH('A^R, R=all?(X Y Z)', 'A=nall(X Y Z)');\n\n    const issomeArgCount = ml_dec16(ml, issomeOffset + 1);\n    const issomeResultOffset = issomeOffset + SIZEOF_C + issomeArgCount * 2;\n\n    ASSERT(indexR === readIndex(ml, issomeResultOffset), 'asserted before');\n\n    const issomeArgs = markAndCollectArgs(ml, issomeOffset, issomeArgCount);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexR);\n\n    // Morph the issome to an isnone (simply change the op). dont forget to mark all its args\n    ml_enc8(ml, issomeOffset, ML_ISNONE);\n    ml_enc16(ml, issomeResultOffset, indexA);\n    ml_eliminate(ml, xorOffset, SIZEOF_C_2);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_issome_xor');\n      let A = getDomain(indexA);\n      let R = getDomain(indexR);\n      TRACE(' -', domain__debug(A), '^', domain__debug(R));\n      if (domain_isZero(A)) {\n        TRACE(' - A=0 so R must >0');\n        R = domain_removeValue(R, 0);\n        setDomain(indexR, R);\n      } else if (domain_isZero(R)) {\n        TRACE(' - R=0 so A must >0');\n        A = domain_removeGtUnsafe(A, 0);\n        setDomain(indexA, A);\n      } else if (domain_hasNoZero(A)) {\n        TRACE(' - A>0 so R must =0');\n        R = domain_removeGtUnsafe(R, 0);\n        setDomain(indexR, R);\n      } else if (domain_hasNoZero(R)) {\n        TRACE(' - R>0 so A must =0');\n        A = domain_removeGtUnsafe(A, 0);\n        setDomain(indexA, A);\n      } else {\n        ASSERT(domain_isBooly(A) && domain_isBooly(R));\n\n        let allNone = true;\n        let some = false;\n        let boolyIndex = -1;\n        for (let i = 0; i < issomeArgs.lenght; ++i) {\n          const index = issomeArgs[i];\n          const D = getDomain(index);\n          if (domain_hasNoZero(D)) {\n            some = true;\n            break;\n          } else if (!domain_isZero(D)) {\n            allNone = false;\n            boolyIndex = i;\n          }\n        }\n\n        if (some) {\n          TRACE(' - found at least one arg that was nonzero, R>0');\n          R = domain_removeValue(R, 0);\n        } else if (allNone) {\n          TRACE(' - all args were zero, R=0');\n          R = domain_removeGtUnsafe(R, 0);\n        } else {\n          TRACE(\n            ' - found no nonzero and at least one arg was booly, forcing R>0 and that arg >0 as well'\n          );\n          R = domain_removeValue(R, 0);\n          const index = issomeArgs[boolyIndex];\n          let D = getDomain(index);\n          ASSERT(domain_isBooly(D), 'we. just. checked. this');\n          D = domain_removeValue(D, 0);\n          ASSERT(D);\n          setDomain(index, D);\n        }\n\n        setDomain(indexR, R);\n      }\n\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexR));\n      ASSERT(\n        !domain_isBooly(getDomain(indexA)) && !domain_isBooly(getDomain(indexR))\n      );\n      ASSERT(\n        domain_isZero(getDomain(indexA)) !== domain_isZero(getDomain(indexR))\n      );\n      ASSERT(\n        domain_hasNoZero(getDomain(indexR)) ===\n          issomeArgs.some(i => domain_hasNoZero(getDomain(i)))\n      );\n    });\n\n    somethingChanged();\n\n    return true;\n  }\n\n  function trick_some_xor(indexX, indexA, xorOffset, countsX) {\n    TRACE('trick_some_xor; X^A,X|B => A->B, X leaf');\n\n    const offset1 = bounty_getOffset(bounty, indexX, 0);\n    const offset2 = bounty_getOffset(bounty, indexX, 1);\n    const someOffset = offset1 === xorOffset ? offset2 : offset1;\n    TRACE(\n      ' - xorOffset:',\n      xorOffset,\n      ', someOffset:',\n      someOffset,\n      ', indexX:',\n      indexX,\n      ', metaX:',\n      bounty__debugMeta(bounty, indexA)\n    );\n\n    ASSERT(ml_dec16(ml, xorOffset + 1) === 2, 'xors have 2 args');\n    ASSERT(countsX === 2, 'x should be part of SOME and XOR');\n\n    if (ml_dec16(ml, someOffset + 1) !== 2) {\n      TRACE(' - SOME doesnt have 2 args, bailing');\n      return false;\n    }\n\n    const X = getDomain(indexX, true);\n    if (!domain_isBooly(X)) {\n      TRACE(' - X is not a booly, this should be solved by minimizer, bailing');\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    ASSERT(\n      readIndex(ml, someOffset + OFFSET_C_A) === indexX ||\n        readIndex(ml, someOffset + OFFSET_C_B) === indexX\n    );\n    let indexB = readIndex(ml, someOffset + OFFSET_C_A);\n    if (indexB === indexX) indexB = readIndex(ml, someOffset + OFFSET_C_B);\n\n    TRACE(' - indexes: X=', indexX, ', A=', indexA, ', B=', indexB);\n    TRACE(\n      ' - domains: X=',\n      domain__debug(getDomain(indexX)),\n      ', A=',\n      domain__debug(getDomain(indexA)),\n      ', B=',\n      domain__debug(getDomain(indexB))\n    );\n\n    TRACE_MORPH('X ^ A, X | B', 'A -> B');\n    TRACE(' - indexes: A=', indexA, ', B=', indexB, ', X=', indexX);\n    TRACE(\n      ' - domains: A=',\n      domain__debug(getDomain(indexA)),\n      ', B=',\n      domain__debug(getDomain(indexB)),\n      ', X=',\n      domain__debug(getDomain(indexX))\n    );\n\n    // We dont have to bother with booly checks since there are two occurrences of X left and they both concern booly ops\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE('trick_some_xor');\n\n      const A = getDomain(indexA);\n      const B = getDomain(indexB);\n      let X = getDomain(indexX);\n      TRACE(' - X ^ A, X | B  =>  A -> B');\n      TRACE(\n        ' - A=',\n        domain__debug(A),\n        ', B=',\n        domain__debug(B),\n        ', X=',\n        domain__debug(X)\n      );\n\n      if (domain_isZero(A)) {\n        TRACE(' - A=0 so X>0');\n        X = domain_removeValue(X, 0);\n      } else if (domain_hasNoZero(A)) {\n        TRACE(' - A>0 so X=0');\n        X = domain_removeGtUnsafe(X, 0);\n      } else if (domain_isZero(B)) {\n        TRACE(' - B=0 so X>0');\n        X = domain_removeValue(X, 0);\n      } else {\n        TRACE(' - A is booly and B>0 so force A and solve X accordingly');\n        if (force(indexA) === 0) {\n          TRACE(' - A=0 so X>0');\n          X = domain_removeValue(X, 0);\n        } else {\n          TRACE(' - A>0 so X=0');\n          X = domain_removeGtUnsafe(X, 0);\n        }\n      }\n\n      setDomain(indexX, X);\n\n      ASSERT(getDomain(indexA) && !domain_isBooly(getDomain(indexA)));\n      ASSERT(getDomain(indexB));\n      ASSERT(getDomain(indexX) && !domain_isBooly(getDomain(indexX)));\n      ASSERT(\n        domain_isZero(getDomain(indexA)) !== domain_isZero(getDomain(indexX))\n      );\n      ASSERT(\n        !domain_hasZero(getDomain(indexX)) || !domain_hasZero(getDomain(indexB))\n      );\n    });\n\n    ml_eliminate(ml, someOffset, SIZEOF_C_2);\n    ml_c2c2(ml, xorOffset, 2, ML_IMP, indexA, indexB);\n\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexX);\n    somethingChanged();\n    return true;\n  }\n\n  function trickNallOnly(indexX, countsX) {\n    TRACE('trickNallOnly;', indexX, ', counts:', countsX);\n\n    if (countsX >= BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      TRACE(\n        ' - counts (',\n        countsX,\n        ') is higher than max number of offsets we track so we bail on this trick'\n      );\n      return false;\n    }\n\n    const X = getDomain(indexX, true);\n    if (domain_isZero(X)) {\n      TRACE(\n        ' - X has is zero so NALL is already solved, rerouting to minimizer'\n      );\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    if (domain_hasNoZero(X)) {\n      TRACE(\n        ' - X has has no zero should be removed from NALL, rerouting to minimizer'\n      );\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    TRACE(\n      ' - X contains zero and is only part of nalls, leaf X and eliminate the nalls'\n    );\n\n    const offsets = []; // To eliminate\n    const indexes = []; // To mark and to defer solve\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      ASSERT(offset, 'bounty should assert that there are counts offsets');\n      ASSERT(\n        ml_dec8(ml, offset) === ML_NALL,\n        'bounty should assert that all ops are nalls'\n      );\n\n      const argCount = ml_dec16(ml, offset + 1);\n      for (let j = 0; j < argCount; ++j) {\n        const index = readIndex(ml, offset + SIZEOF_C + j * 2);\n        if (index !== indexX) indexes.push(index);\n        // Dont mark here because that may affect the getOffset call above\n      }\n\n      // Let's hope this list doenst grow too much... (but we have to dedupe the indexes!)\n      if (offsets.indexOf(offset) < 0) offsets.push(offset);\n    }\n\n    TRACE(' - collected offsets and vars:', offsets, indexes);\n\n    // TODO: we can improve this step and prevent some force solvings\n    TRACE(' - solving X to 0 now to simplify everything');\n    if (!domain_isZero(X)) {\n      ASSERT(domain_hasZero(X), 'checked above');\n      setDomain(indexX, domain_createValue(0));\n    }\n\n    TRACE(' - now remove these nalls:', offsets);\n\n    for (let i = 0, len = offsets.length; i < len; ++i) {\n      const offset = offsets[i];\n      TRACE_MORPH(\n        'nall(X...)',\n        '',\n        'leaf a nall arg that is only used in nalls'\n      );\n      const argCount = ml_dec16(ml, offset + 1);\n      const opSize = SIZEOF_C + argCount * 2;\n      TRACE('   - argcount=', argCount, ', opSize=', opSize);\n      ml_eliminate(ml, offset, opSize);\n    }\n\n    for (let i = 0, len = indexes.length; i < len; ++i) {\n      const indexY = indexes[i];\n      bounty_markVar(bounty, indexY);\n    }\n\n    bounty_markVar(bounty, indexX);\n    somethingChanged();\n\n    return true;\n  }\n\n  function trickSomeOnly(indexX, countsX) {\n    TRACE('trickSomeOnly;', indexX, ', counts:', countsX);\n\n    if (countsX >= BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      TRACE(\n        ' - counts (',\n        countsX,\n        ') is higher than max number of offsets we track so we bail on this trick'\n      );\n      return false;\n    }\n\n    let X = getDomain(indexX, true);\n    if (domain_hasNoZero(X)) {\n      TRACE(\n        ' - X has no zero so SOME is already solved, rerouting to minimizer'\n      );\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    if (domain_isZero(X)) {\n      TRACE(\n        ' - X has is zero so should be removed from this SOME, rerouting to minimizer'\n      );\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    TRACE(\n      ' - X contains a nonzero and is only part of SOMEs, leaf X and eliminate the SOMEs'\n    );\n\n    const offsets = []; // To eliminate\n    const indexes = []; // To mark and to defer solve\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      ASSERT(offset, 'bounty should assert that there are counts offsets');\n      ASSERT(\n        ml_dec8(ml, offset) === ML_SOME,\n        'bounty should assert that all ops are SOMEs'\n      );\n\n      const argCount = ml_dec16(ml, offset + 1);\n      for (let j = 0; j < argCount; ++j) {\n        const index = readIndex(ml, offset + SIZEOF_C + j * 2);\n        if (index !== indexX) indexes.push(index);\n        // Dont mark here because that may affect the getOffset call above\n      }\n\n      // Let's hope this list doenst grow too much... (but we have to dedupe the indexes!)\n      if (offsets.indexOf(offset) < 0) offsets.push(offset);\n    }\n\n    TRACE(' - collected offsets and vars:', offsets, indexes);\n\n    // TODO: we can improve this step and prevent some force solvings\n    TRACE(' - removing 0 from X now to simplify everything');\n    if (domain_hasZero(X)) {\n      ASSERT(domain_isBooly(X), 'checked above');\n      setDomain(indexX, (X = domain_removeValue(X, 0)));\n    }\n\n    TRACE(' - now remove these SOMEs:', offsets);\n\n    for (let i = 0, len = offsets.length; i < len; ++i) {\n      const offset = offsets[i];\n      TRACE_MORPH(\n        'some(X...)',\n        '',\n        'leaf a SOME arg that is only used in SOMEs'\n      );\n      const argCount = ml_dec16(ml, offset + 1);\n      const opSize = SIZEOF_C + argCount * 2;\n      TRACE('   - argcount=', argCount, ', opSize=', opSize);\n      ml_eliminate(ml, offset, opSize);\n    }\n\n    for (let i = 0, len = indexes.length; i < len; ++i) {\n      const indexY = indexes[i];\n      bounty_markVar(bounty, indexY);\n    }\n\n    bounty_markVar(bounty, indexX);\n    somethingChanged();\n\n    return true;\n  }\n\n  function trick_ltelhs_nalls_some(indexX, countsX) {\n    TRACE('trick_ltelhs_nalls_some; indexX=', indexX);\n    TRACE(\n      ' - A !& X, X <= B, X | C    ->     B | C, A <= C    (for any number of nall[2] ops)'\n    );\n    // TOFIX: is this bool only?\n\n    if (!domain_isBool(getDomain(indexX))) {\n      TRACE(\n        ' - X wasnt bool (',\n        domain__debug(getDomain(indexX)),\n        '), bailing'\n      );\n      return false;\n    }\n\n    if (countsX >= BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      TRACE(\n        ' - counts (',\n        countsX,\n        ') is higher than max number of offsets we track so we bail on this trick'\n      );\n      return false;\n    }\n\n    let lteOffset;\n    let someOffset;\n    const nallOffsets = [];\n\n    const indexesA = [];\n    let indexB;\n    let indexC;\n\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      if (!offset) break;\n\n      const opCode = ml_dec8(ml, offset);\n      ASSERT(\n        opCode === ML_NALL || opCode === ML_SOME || opCode === ML_LTE,\n        'bounty should assert it logged one of these three ops'\n      );\n\n      if (ml_dec16(ml, offset + 1) !== 2) {\n        TRACE(' - found an op that did not have 2 args, bailing');\n        return false;\n      }\n\n      const indexL = readIndex(ml, offset + OFFSET_C_A);\n      const indexR = readIndex(ml, offset + OFFSET_C_B);\n      ASSERT(\n        indexX === indexL || indexX === indexR,\n        'bounty should assert that x is part of this op'\n      );\n      const indexY = indexL === indexX ? indexR : indexL;\n\n      if (opCode === ML_NALL) {\n        nallOffsets.push(offset);\n        indexesA.push(indexY);\n      } else if (opCode === ML_SOME) {\n        if (someOffset) {\n          TRACE(' - trick only supported with one OR, bailing');\n          return false;\n        }\n\n        someOffset = offset;\n        indexC = indexY;\n      } else {\n        ASSERT(opCode === ML_LTE, 'if not the others then this');\n        if (lteOffset) {\n          TRACE(' - trick only supported with one LTE, bailing');\n          return false;\n        }\n\n        lteOffset = offset;\n        indexB = indexY;\n      }\n    }\n\n    TRACE(\n      ' - collection complete; or offset:',\n      someOffset,\n      ', indexesA:',\n      indexesA,\n      ', indexB:',\n      indexB,\n      ', indexC:',\n      indexC,\n      ', indexX:',\n      indexX,\n      ', lte offset:',\n      lteOffset,\n      ', nall offsets:',\n      nallOffsets\n    );\n    TRACE_MORPH('A !& X, X <= B, X | C', 'B | C, A <= C');\n    TRACE_MORPH(\n      'A !& X, D !& X, X <= B, X | C',\n      'B | C, A <= C, D <= C',\n      'for any nall, all ops have 2 args'\n    );\n    TRACE('   - every \"other\" arg of each nall should be <= C');\n\n    ml_c2c2(ml, lteOffset, 2, ML_SOME, indexB, indexC);\n    ml_eliminate(ml, someOffset, SIZEOF_C_2);\n    for (let i = 0, len = indexesA.length; i < len; ++i) {\n      const indexA = indexesA[i];\n      ml_c2c2(ml, nallOffsets[i], 2, ML_LTE, indexA, indexC);\n      bounty_markVar(bounty, indexA);\n    }\n\n    // Let t = `\n    //  ${['   - X!&A, ', indexesA.map(indexA => domain__debug(getDomain(indexX)) + ' !& ' + domain__debug(getDomain(indexA))).join(', ')]}\n    //  ${['   - X<=B, ', domain__debug(getDomain(indexX)), '<=', domain__debug(getDomain(indexB))]}\n    //  ${['   - X|C,  ', domain__debug(getDomain(indexX)), '|', domain__debug(getDomain(indexC))]}\n    // `;\n\n    TRACE('   - X is a leaf var', indexX);\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - or+lte+nalls;', indexX);\n      TRACE(' - this was `A !& X, X <= B, X | C` with any number of !&');\n      TRACE(\n        '   - A=',\n        indexesA.map(index => domain__debug(getDomain(index))),\n        ', B=',\n        domain__debug(getDomain(indexB)),\n        ', C=',\n        domain__debug(getDomain(indexC)),\n        ', X=',\n        domain__debug(getDomain(indexX))\n      );\n      // TRACE(t)\n      TRACE(' - before:');\n      TRACE(\n        '   - X!&A, ',\n        indexesA\n          .map(\n            indexA =>\n              domain__debug(getDomain(indexX)) +\n              ' !& ' +\n              domain__debug(getDomain(indexA))\n          )\n          .join(', ')\n      );\n      TRACE(\n        '   - X<=B, ',\n        domain__debug(getDomain(indexX)),\n        '<=',\n        domain__debug(getDomain(indexB))\n      );\n      TRACE(\n        '   - X|C,  ',\n        domain__debug(getDomain(indexX)),\n        '|',\n        domain__debug(getDomain(indexC))\n      );\n\n      let B = getDomain(indexB);\n      let C = getDomain(indexC);\n      let X = getDomain(indexX);\n\n      TRACE(' - first scan whether X should be set or unset');\n      let setIt = false;\n      let unsetIt = false;\n\n      if (domain_isZero(C)) {\n        TRACE(' - C is zero so X must be set');\n        setIt = true;\n      }\n\n      indexesA.forEach(indexA => {\n        const A = getDomain(indexA);\n        if (domain_hasNoZero(A)) {\n          TRACE(' - there was a nall arg that was set so X must be unset');\n          unsetIt = true;\n        }\n      });\n\n      TRACE(' - so; set?', setIt, ', unset?', unsetIt);\n      ASSERT(!(setIt && unsetIt));\n\n      if (setIt) {\n        X = domain_removeValue(X, 0);\n        X = domain_removeGtUnsafe(X, domain_min(B));\n        TRACE(\n          ' - Set X and applied LTE: X=',\n          domain__debug(X),\n          ', B=',\n          domain__debug(B)\n        );\n      } else if (unsetIt) {\n        X = domain_removeGtUnsafe(X, 0);\n        X = domain_removeGtUnsafe(X, domain_min(B));\n        TRACE(\n          ' - Unsetting X and applied LTE: X=',\n          domain__debug(X),\n          ', B=',\n          domain__debug(B)\n        );\n      } else {\n        X = domain_removeGtUnsafe(X, domain_min(B));\n        if (domain_isBooly(X)) X = domain_removeValue(X, 0);\n        TRACE(\n          ' - first applied LTE and then forced a booly state; X=',\n          domain__debug(X),\n          ', B=',\n          domain__debug(B)\n        );\n      }\n\n      setDomain(indexX, X);\n\n      TRACE(' - feedback new value of X (', domain__debug(X), ')');\n\n      // If X is zero then all the NALLs are already satisfied\n      if (domain_hasNoZero(X)) {\n        TRACE(' - X>0 so forcing all NALL args to be zero');\n        indexesA.forEach(indexA => {\n          let A = getDomain(indexA);\n          A = domain_removeGtUnsafe(A, 0);\n          setDomain(indexA, A);\n        });\n      }\n\n      TRACE(\n        ' - Remove any value from B=',\n        domain__debug(B),\n        'that is below X=',\n        domain__debug(X),\n        ', max(X)=',\n        domain_max(X)\n      );\n      B = domain_removeLtUnsafe(B, domain_max(X));\n      setDomain(indexB, B);\n\n      TRACE(\n        ' - if X=0 then C>0, X=',\n        domain__debug(X),\n        ', C=',\n        domain__debug(C)\n      );\n      if (domain_isZero(X)) {\n        C = domain_removeValue(C, 0);\n        setDomain(indexC, C);\n      }\n\n      TRACE(' - result:');\n      TRACE(\n        '   - X!&A, ',\n        indexesA\n          .map(\n            indexA =>\n              domain__debug(getDomain(indexX)) +\n              ' !& ' +\n              domain__debug(getDomain(indexA))\n          )\n          .join(', ')\n      );\n      TRACE(\n        '   - X<=B, ',\n        domain__debug(getDomain(indexX)),\n        '<=',\n        domain__debug(getDomain(indexB))\n      );\n      TRACE(\n        '   - X|C,  ',\n        domain__debug(getDomain(indexX)),\n        '|',\n        domain__debug(getDomain(indexC))\n      );\n\n      ASSERT(getDomain(indexB));\n      ASSERT(getDomain(indexC));\n      ASSERT(getDomain(indexX));\n      ASSERT(\n        !indexesA.some(\n          indexA =>\n            !domain_isZero(getDomain(indexA)) &&\n            !domain_isZero(getDomain(indexX))\n        )\n      );\n      ASSERT(domain_max(getDomain(indexX)) <= domain_min(getDomain(indexX)));\n      ASSERT(\n        domain_hasNoZero(getDomain(indexX)) ||\n          domain_hasNoZero(getDomain(indexC))\n      );\n    });\n\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexC);\n    bounty_markVar(bounty, indexX);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_implhs_nalls_some(indexX, countsX) {\n    TRACE('trick_implhs_nalls_some; indexX=', indexX);\n    TRACE(\n      ' - A !& X, X -> B, X | C    ->     B | C, A -> C    (for any number of nall[2] ops)'\n    );\n    // TOFIX: is this bool only?\n\n    if (countsX >= BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      TRACE(\n        ' - counts (',\n        countsX,\n        ') is higher than max number of offsets we track so we bail on this trick'\n      );\n      return false;\n    }\n\n    let impOffset;\n    let someOffset;\n    const nallOffsets = [];\n\n    const indexesA = [];\n    let indexB;\n    let indexC;\n\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      if (!offset) break;\n\n      const opCode = ml_dec8(ml, offset);\n      ASSERT(\n        opCode === ML_NALL || opCode === ML_SOME || opCode === ML_IMP,\n        'bounty should assert it logged one of these three ops'\n      );\n\n      if (ml_dec16(ml, offset + 1) !== 2) {\n        TRACE(' - found an op that did not have 2 args, bailing');\n        return false;\n      }\n\n      const indexL = readIndex(ml, offset + OFFSET_C_A);\n      const indexR = readIndex(ml, offset + OFFSET_C_B);\n      ASSERT(\n        indexX === indexL || indexX === indexR,\n        'bounty should assert that x is part of this op'\n      );\n      const indexY = indexL === indexX ? indexR : indexL;\n\n      if (opCode === ML_NALL) {\n        nallOffsets.push(offset);\n        indexesA.push(indexY);\n      } else if (opCode === ML_SOME) {\n        if (someOffset) {\n          TRACE(' - trick only supported with one OR, bailing');\n          return false;\n        }\n\n        someOffset = offset;\n        indexC = indexY;\n      } else {\n        ASSERT(opCode === ML_IMP, 'if not the others then this');\n        if (impOffset) {\n          TRACE(' - trick only supported with one IMP, bailing');\n          return false;\n        }\n\n        impOffset = offset;\n        indexB = indexY;\n      }\n    }\n\n    TRACE(\n      ' - collection complete; or offset:',\n      someOffset,\n      ', indexesA:',\n      indexesA,\n      ', indexB:',\n      indexB,\n      ', indexC:',\n      indexC,\n      ', indexX:',\n      indexX,\n      ', imp offset:',\n      impOffset,\n      ', nall offsets:',\n      nallOffsets\n    );\n    TRACE('   - A !& X, X -> B, X | C    ->     B | C, A -> C');\n    TRACE('   - A !& X, D !& X, X -> B, X | C    ->     B | C, A -> C, D -> C');\n    TRACE('   - every \"other\" arg of each nall should be -> C');\n\n    ml_c2c2(ml, impOffset, 2, ML_SOME, indexB, indexC);\n    ml_eliminate(ml, someOffset, SIZEOF_C_2);\n    for (let i = 0, len = indexesA.length; i < len; ++i) {\n      const indexA = indexesA[i];\n      ml_c2c2(ml, nallOffsets[i], 2, ML_IMP, indexA, indexC);\n      bounty_markVar(bounty, indexA);\n    }\n\n    TRACE('   - X is a leaf var', indexX);\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - imp+nalls+some;', indexX);\n      TRACE(' - this was `A !& X, X -> B, X | C` with any number of !&');\n      TRACE(\n        ' - indexes: A=',\n        indexesA,\n        ', B=',\n        indexB,\n        ', C=',\n        indexC,\n        ', X=',\n        indexX\n      );\n      TRACE(\n        ' - domains: A=',\n        indexesA.map(a => domain__debug(getDomain(a))),\n        ', B=',\n        domain__debug(getDomain(indexB)),\n        ', C=',\n        domain__debug(getDomain(indexC)),\n        ', X=',\n        domain__debug(getDomain(indexX))\n      );\n\n      const X = getDomain(indexX);\n      let nX = X;\n\n      // A !& X for all A\n      if (!domain_isZero(nX)) {\n        // If X is 0 then the nall already passes\n        for (let i = 0, len = indexesA.length; i < len; ++i) {\n          const indexA = indexesA[i];\n          const A = getDomain(indexA);\n          if (domain_hasNoZero(A) || force(indexA) !== 0) {\n            TRACE(' - at least one NALL pair had a nonzero so X must be zero');\n            nX = domain_removeGtUnsafe(nX, 0);\n            break; // Now each nall will be fulfilled since X is zero\n          }\n        }\n      }\n\n      // X | C so if C is zero then X must be nonzero\n      let C = getDomain(indexC);\n      if (domain_isBooly(C)) {\n        force(C);\n        C = getDomain(indexC);\n      }\n\n      if (domain_isZero(C)) {\n        TRACE(' - the SOME pair C was zero so X must be nonzero');\n        nX = domain_removeValue(nX, 0);\n      }\n\n      // Maintain X -> B\n      let B = getDomain(indexB);\n      if (domain_isBooly(B)) {\n        force(B);\n        B = getDomain(indexB);\n      }\n\n      if (domain_isZero(B)) {\n        TRACE(' - B is zero so X must be zero');\n        nX = domain_removeGtUnsafe(nX, 0);\n      }\n\n      ASSERT(nX);\n      if (X !== nX) setDomain(indexX, nX);\n    });\n\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexC);\n    bounty_markVar(bounty, indexX);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_lteboth_nall_some(indexX, countsX) {\n    TRACE('trick_lteboth_nall_some', indexX);\n    TRACE(\n      ' - A <= X, B | X, C !& X, X <= D     ->     A !& C, B | D, A <= D, C <= B'\n    );\n    // If we can model `A !& C, A <= D` in one constraint then we should do so but I couldn't find one\n    // (when more lte's are added, that's the pattern we add for each)\n    // TOFIX: is this bool only?\n\n    // we only want exactly four ops here... and if max is set to something lower then this trick has no chance at all\n    if (countsX > 4 || countsX >= BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      TRACE(\n        ' - we need exactly four constraints for this trick but have',\n        countsX,\n        ', bailing'\n      );\n      return false;\n    }\n\n    // Note: bounty tracks lte_rhs and lte_lhs separate so if we have four constraints\n    // here can trust bounty to assert they are all our targets, no more, no less.\n\n    // we should have; LTE_RHS, LTE_LHS, NALL, SOME\n    let lteLhsOffset;\n    let lteRhsOffset;\n    let someOffset;\n    let nallOffset;\n\n    let indexA;\n    let indexB;\n    let indexC;\n    let indexD;\n\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      ASSERT(\n        offset,\n        'bounty should assert to fetch as many offsets as there are counts'\n      );\n\n      const opCode = ml_dec8(ml, offset);\n      ASSERT(\n        opCode === ML_NALL || opCode === ML_SOME || opCode === ML_LTE,\n        'bounty should assert the op is one of these'\n      );\n\n      // TODO: this kind of breaks on an op with 1 arg\n      const indexL = readIndex(ml, offset + OFFSET_C_A);\n      const indexR = readIndex(ml, offset + OFFSET_C_B);\n      ASSERT(\n        indexX === indexL || indexX === indexR,\n        'bounty should assert X is one of the args'\n      );\n      const indexY = indexL === indexX ? indexR : indexL;\n\n      if (opCode === ML_NALL) {\n        ASSERT(!nallOffset, 'cant have a second NALL as per bounty');\n        indexC = indexY;\n        nallOffset = offset;\n      } else if (opCode === ML_SOME) {\n        ASSERT(!someOffset, 'cant have a second SOME as per bounty');\n        indexB = indexY;\n        someOffset = offset;\n      } else {\n        ASSERT(opCode === ML_LTE, 'asserted by bounty see above');\n\n        if (indexL === indexX) {\n          // Lte_lhs\n          ASSERT(!lteLhsOffset, 'cant have a second lte_lhs');\n          lteLhsOffset = offset;\n          indexD = indexY;\n        } else {\n          // Lte_rhs\n          ASSERT(\n            indexR === indexX,\n            'x already asserted to be one of the op args'\n          );\n          ASSERT(!lteRhsOffset, 'cant have a second lte_rhs');\n          lteRhsOffset = offset;\n          indexA = indexY;\n        }\n      }\n    }\n\n    TRACE(\n      ' - collection complete; offsets:',\n      lteLhsOffset,\n      lteRhsOffset,\n      someOffset,\n      nallOffset,\n      ', indexes: X=',\n      indexX,\n      ', A=',\n      indexA,\n      ', B=',\n      indexB,\n      ', C=',\n      indexC,\n      ', D=',\n      indexD\n    );\n    TRACE(\n      ' - A <= X, B | X, C !& X, X <= D     ->     A !& C, B | D, A <= D, C <= B'\n    );\n\n    ml_c2c2(ml, lteLhsOffset, 2, ML_LTE, indexA, indexD);\n    ml_c2c2(ml, lteRhsOffset, 2, ML_LTE, indexC, indexD);\n    ml_c2c2(ml, someOffset, 2, ML_SOME, indexB, indexD);\n    ml_c2c2(ml, nallOffset, 2, ML_NALL, indexA, indexC);\n\n    TRACE('   - X is a leaf var', indexX);\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - some+nall+lte_lhs+lte_rhs;', indexX);\n\n      let X = getDomain(indexX);\n      if (force(indexA) === 1) {\n        // A<=X so if A is 1, X must also be 1\n        X = domain_removeValue(X, 0);\n        ASSERT(X, 'X should be able to reflect the solution');\n        setDomain(indexX, X);\n      } else if (force(indexB) === 0) {\n        // X|B so if B is 0, X must be non-zero\n        X = domain_removeValue(X, 0);\n        ASSERT(X, 'X should be able to reflect the solution');\n        setDomain(indexX, X);\n      } else if (force(indexC) > 0) {\n        // If indexA is set, X must be zero\n        X = domain_removeGtUnsafe(X, 0);\n        ASSERT(X, 'X should be able to reflect the solution');\n        setDomain(indexX, X);\n      } else if (force(indexD) === 0) {\n        // X<=D, if indexD is 0, X must be zero\n        X = domain_removeGtUnsafe(X, 0);\n        ASSERT(X, 'X should be able to reflect the solution');\n        setDomain(indexX, X);\n      }\n    });\n\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexC);\n    bounty_markVar(bounty, indexD);\n    bounty_markVar(bounty, indexX);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_impboth_nall_some(indexX, countsX) {\n    TRACE('trick_impboth_nall_some', indexX);\n    TRACE(\n      ' - A -> X, B | X, C !& X, X -> D             =>     A !& C, B | D, A -> D, C -> B'\n    );\n    // We want a NALL[2], SOME[2], IMP_LHS, and one or more IMP_RHS\n    // if we can model `A !& C, A -> D` in one constraint then we should do so but I couldn't find one\n    // - A->(B<?C)\n    // - A==(C&A&!B)\n    // - B<C|!A       /       B<C|A==0\n    // (when more IMPs are added, we add the same pattern for each)\n    // TOFIX: is this bool only?\n\n    if (countsX !== 4 || countsX >= BOUNTY_MAX_OFFSETS_TO_TRACK) {\n      TRACE(\n        ' - we need 4 constraints for this trick but have',\n        countsX,\n        ', bailing'\n      );\n      return false;\n    }\n\n    // Note: bounty tracks imp_rhs and imp_lhs separate so if we have four constraints\n    // here can trust bounty to assert they are all our targets, no more, no less.\n    // TODO: what if somehow X->X ocurred here? (due to other rewrite inside cutter)\n\n    // we should have; 1x IMP_RHS, 1x IMP_LHS, 1x NALL, 1x SOME\n    let impLhsOffset;\n    let impRhsOffset;\n    let someOffset;\n    let nallOffset;\n\n    let indexA;\n    let indexB;\n    let indexC;\n    let indexD;\n\n    for (let i = 0; i < countsX; ++i) {\n      const offset = bounty_getOffset(bounty, indexX, i);\n      ASSERT(\n        offset,\n        'bounty should assert to fetch as many offsets as there are counts'\n      );\n\n      const opCode = ml_dec8(ml, offset);\n      ASSERT(\n        opCode === ML_NALL || opCode === ML_SOME || opCode === ML_IMP,\n        'bounty should assert the op is one of these'\n      );\n\n      // TODO: this kind of breaks on an op with 1 arg\n      const indexL = readIndex(ml, offset + OFFSET_C_A);\n      const indexR = readIndex(ml, offset + OFFSET_C_B);\n      ASSERT(\n        indexX === indexL || indexX === indexR,\n        'bounty should assert X is one of the args'\n      );\n\n      if (opCode === ML_NALL) {\n        ASSERT(nallOffset === undefined, 'bounty said so');\n\n        indexC = indexL === indexX ? indexR : indexL;\n        nallOffset = offset;\n      } else if (opCode === ML_SOME) {\n        ASSERT(someOffset === undefined, 'bounty said so');\n\n        indexB = indexL === indexX ? indexR : indexL;\n        someOffset = offset;\n      } else {\n        ASSERT(opCode === ML_IMP, 'asserted by bounty see above');\n        const indexY = indexL === indexX ? indexR : indexL;\n\n        if (indexL === indexX) {\n          // Imp_lhs\n          ASSERT(impLhsOffset === undefined, 'bounty said so');\n          impLhsOffset = offset;\n          indexD = indexY;\n        } else {\n          // Imp_rhs\n          ASSERT(\n            indexR === indexX,\n            'x already asserted to be one of the op args'\n          );\n          ASSERT(impRhsOffset === undefined, 'bounty said so');\n          impRhsOffset = offset;\n          indexA = indexY;\n        }\n      }\n    }\n\n    TRACE(\n      ' - collection complete; offsets:',\n      impLhsOffset,\n      impRhsOffset,\n      someOffset,\n      nallOffset,\n      ', indexes: X=',\n      indexX,\n      ', A=',\n      indexA,\n      ', B=',\n      indexB,\n      ', C=',\n      indexC,\n      ', D=',\n      indexD\n    );\n    TRACE(\n      ' - A -> X, B | X, C !& X, X -> D, X -> E     =>     A !& C, B | D, A -> D, C -> B, A -> E, C -> E'\n    );\n\n    if (\n      !domain_isBool(getDomain(indexA, true)) ||\n      !domain_isBool(getDomain(indexB, true)) ||\n      !domain_isBool(getDomain(indexC, true)) ||\n      !domain_isBool(getDomain(indexD, true))\n    ) {\n      TRACE(' - At least one of the domains wasnt a bool, bailing for now');\n      return false;\n    }\n\n    TRACE_MORPH(\n      ' - C !& X, B | X, A -> X, X -> D',\n      ' - A !& C, B | D, A -> D, C -> B'\n    );\n\n    ml_c2c2(ml, impLhsOffset, 2, ML_IMP, indexA, indexD);\n    ml_c2c2(ml, impRhsOffset, 2, ML_IMP, indexC, indexD);\n    ml_c2c2(ml, someOffset, 2, ML_SOME, indexB, indexD);\n    ml_c2c2(ml, nallOffset, 2, ML_NALL, indexA, indexC);\n\n    TRACE('   - X is a leaf var', indexX);\n    leafs.push(indexX);\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - some+nall+imp_lhs+imp_rhs;', indexX);\n\n      // TODO: we can be less forcing here\n\n      let X = getDomain(indexX);\n      if (force(indexA) === 1) {\n        // A->X so if A is 1, X must also be 1\n        X = domain_removeValue(X, 0);\n        ASSERT(X, 'X should be able to reflect the solution');\n        setDomain(indexX, X);\n      } else if (force(indexB) === 0) {\n        // X|B so if B is 0, X must be non-zero\n        X = domain_removeValue(X, 0);\n        ASSERT(X, 'X should be able to reflect the solution');\n        setDomain(indexX, X);\n      } else if (force(indexC) > 0) {\n        // X!&C so if indexA is set, X must be zero\n        X = domain_removeGtUnsafe(X, 0);\n        ASSERT(X, 'X should be able to reflect the solution');\n        setDomain(indexX, X);\n      } else if (force(indexD) === 0) {\n        // X->D, if indexD is 0, X must be zero\n        X = domain_removeGtUnsafe(X, 0);\n        ASSERT(X, 'X should be able to reflect the solution');\n        setDomain(indexX, X);\n      }\n    });\n\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexC);\n    bounty_markVar(bounty, indexD);\n    bounty_markVar(bounty, indexX);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_issame_sum(\n    ml,\n    sumOffset,\n    indexR,\n    counts,\n    argCount,\n    sum,\n    min,\n    max,\n    constantValue,\n    constantArgIndex,\n    allSumArgsBoolyPairs\n  ) {\n    // Only if all sum args are strict bools ([0 1]), one constant excluded\n\n    // (R = sum(A B C) & (S = R==?3)        ->    S = all?(A B C)\n    // (R = sum(A B C) & (S = R==?0)        ->    S = none?(A B C)\n    // (R = sum(A B C) & (S = R==?[0 1])    ->    S = nall?(A B C)\n    // (R = sum(A B C) & (S = R==?[1 2])    ->    S = some?(A B C)\n\n    // R = sum( ... ), S = R ==? count                       ->   S = all?( ... )\n    // R = sum( ... ), S = R ==? 0                           ->   S = none?( ... )\n    // R = sum( ... ), S = R ==? [0 0 count-1 count-1]       ->   S = nall?( ... )\n    // R = sum( ... ), S = R ==? [1 1 count count]           ->   S = some?( ... )\n\n    // R = sum([0 0 3 3], [0 0 5 5]), S = R ==? 8            ->   S = all?( ... )\n    // R = sum( ... ), S = R ==? sum-max-args                ->   S = all?( ... )\n\n    const offset1 = bounty_getOffset(bounty, indexR, 0);\n    const offset2 = bounty_getOffset(bounty, indexR, 1);\n    const issameOffset = offset1 === sumOffset ? offset2 : offset1;\n    TRACE(\n      'trick_issame_sum; sumOffset:',\n      sumOffset,\n      ', issameOffset:',\n      issameOffset,\n      ', indexR:',\n      indexR,\n      ', countsR:',\n      counts,\n      ', metaR:',\n      bounty__debugMeta(bounty, indexR),\n      ', min:',\n      min,\n      ', max:',\n      max,\n      ', const:',\n      constantValue,\n      ', const arg pos:',\n      constantArgIndex\n    );\n\n    ASSERT(min >= 0 && max >= 0 && min <= max, 'min/max check');\n    ASSERT(constantValue >= 0, 'constant value should be positive or zero');\n    ASSERT(issameOffset > 0, 'offset should exist and cant be the first op');\n    ASSERT(\n      counts === 2,\n      'R should only be used in two constraints (sum and issame)'\n    );\n    ASSERT(\n      getMeta(bounty, indexR) ===\n        (BOUNTY_FLAG_ISSAME_ARG | BOUNTY_FLAG_SUM_RESULT),\n      'should be sum and issame arg',\n      counts,\n      bounty__debugMeta(bounty, indexR)\n    );\n    ASSERT(ml_dec8(ml, sumOffset) === ML_SUM, 'check sum offset');\n    ASSERT(ml_dec8(ml, issameOffset) === ML_ISSAME, 'check issame offset');\n    ASSERT(ml_dec16(ml, sumOffset + 1) === argCount, 'argcount should match');\n    ASSERT(constantArgIndex < argCount, 'should be valid const pos');\n\n    const issameArgCount = ml_dec16(ml, issameOffset + 1);\n    if (issameArgCount !== 2) {\n      TRACE(' - issame does not have 2 args, bailing for now');\n      return false;\n    }\n\n    // S = R ==? X\n    const indexA = readIndex(ml, issameOffset + OFFSET_C_A); // R or X\n    const indexB = readIndex(ml, issameOffset + OFFSET_C_B); // R or X\n    const indexS = readIndex(ml, issameOffset + OFFSET_C_R); // S\n\n    ASSERT(\n      indexA === indexR || indexB === indexR,\n      'R should be an arg of the issame'\n    );\n    let indexX = indexA;\n    if (indexX === indexR) indexX = indexB;\n\n    TRACE(' - S = R ==? X; indexes=', indexS, '=', indexR, '==?', indexX);\n    TRACE(\n      ' - ',\n      domain__debug(getDomain(indexS)),\n      '=',\n      domain__debug(getDomain(indexR)),\n      '==?',\n      domain__debug(getDomain(indexX))\n    );\n\n    const R = getDomain(indexR, true);\n    const X = getDomain(indexX, true);\n    const vX = domain_getValue(X);\n\n    if (vX >= 0 && !domain_containsValue(R, vX)) {\n      // This case should be handled by the minimizer but deduper/earlier cutter steps could lead to it here anyways\n      // bailing so minimizer can take care of it in the next cycle\n      TRACE(' - R didnt contain B so unsafe for leaf cutting, bailing');\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    // Let want = domain_createRange(min, max);\n    const Rwant = domain_intersection(R, sum);\n    TRACE(\n      ' - R must contain all values in between;',\n      domain__debug(R),\n      'and',\n      domain__debug(sum),\n      '=',\n      domain__debug(Rwant),\n      '(',\n      sum === Rwant,\n      ')'\n    );\n    if (Rwant !== sum) {\n      TRACE(' - R cant represent all values of the sum'); // , are the args booly pairs?', allSumArgsBoolyPairs, ', vX:', vX, ', max:', max);\n      return false;\n    }\n\n    TRACE(' - sum R range change check passed');\n\n    // Check the case where all the args are boolyPairs and R contains the sum of maxes\n    if (allSumArgsBoolyPairs && vX === max) {\n      // R = sum([0 0 3 3], [0 0 5 5]), S = R ==? 8            ->   S = all?( ... )\n      // R = sum( ... ), S = R ==? sum-max-args                ->   S = all?( ... )\n      TRACE(\n        ' - all sum args are booly and vX is the sum of maxes, morph to isall'\n      );\n      TRACE_MORPH('R = sum( ... ), S = R ==? sum-max-args', 'S = all?( ... )');\n      ml_enc8(ml, sumOffset, ML_ISALL);\n      return _trick_issame_sum_tail(\n        sumOffset,\n        issameOffset,\n        argCount,\n        indexR,\n        indexS,\n        indexX,\n        constantValue,\n        constantArgIndex\n      );\n    }\n\n    if (vX >= 0) {\n      return _trick_issame_sum_constant(\n        ml,\n        sumOffset,\n        argCount,\n        indexR,\n        issameOffset,\n        indexS,\n        indexX,\n        vX,\n        max,\n        constantValue,\n        constantArgIndex\n      );\n    }\n\n    return _trick_issame_sum_domain(\n      ml,\n      sumOffset,\n      argCount,\n      indexR,\n      issameOffset,\n      indexS,\n      indexX,\n      X,\n      constantValue,\n      constantArgIndex\n    );\n  }\n\n  function _trick_issame_sum_constant(\n    ml,\n    sumOffset,\n    argCount,\n    indexR,\n    issameOffset,\n    indexS,\n    indexX,\n    vX,\n    max,\n    constantValue,\n    constantArgIndex\n  ) {\n    TRACE(' - _trick_issame_sum_constant', vX);\n    // This is when the X of S=R==?X is a constant\n\n    // R = sum(A B C), S = R ==? 0          \"are none of ABC set\"\n    // R = sum(A B C 5), S = R ==? 0        S=0 because R is always at least 5. we ignore this here\n    // R = sum(A B C 5), S = R ==? 5        \"are none of ABC set\"\n\n    // R = sum(A B C), S = R ==? 3          \"are all args set\"\n    // R = sum(A B C 5), S = R ==? 3        S=0 because R is always at least 5. we ignore this here\n    // R = sum(A B C 5), S = R ==? 8        \"are all args set\"\n\n    // note: we're not checking the sum bounds here (R is not a leaf). we only want to know how\n    // the sum bounds relate to X of the issame.\n\n    TRACE(\n      ' - vX=',\n      vX,\n      ', constantValue=',\n      constantValue,\n      ', const arg pos:',\n      constantArgIndex,\n      ', argCount=',\n      argCount,\n      ', for isnone, vX must be',\n      constantValue,\n      ', for isall vX must be',\n      argCount + (constantValue ? constantValue - 1 : 0)\n    );\n    ASSERT(constantArgIndex < argCount, 'const pos should be valid');\n    ASSERT(ml_dec16(ml, issameOffset + 1) === 2, 'issame should have 2 args');\n\n    // To remind you; all sum args are at least booly and there is at most one constant among them\n\n    if (vX === constantValue) {\n      // This means all non-constant args must become zero\n      // for example; R=sum(A,B,C,3,8),S=R==?11 => A=B=C=0\n      TRACE(\n        ' - min=X so all non-constants must be set to zero to satisfy the sum+issame. that means morph to isnone'\n      );\n      TRACE_MORPH('R=sum(A,B,C,x,y),S=R==?(x+y)', 'A=B=C=0');\n\n      // Sum will fit isnone. it'll be exactly the same size\n      // only need to update the op code and the result index, as the rest remains the same\n      ml_enc8(ml, sumOffset, ML_ISNONE);\n    } else if (vX === max) {\n      // This means all non-constant args must be non-zero\n      // for example: R=sum(A:[0 1],B:[0 0 2 2],C:[0 1],3,8),S=R==?15 => S=all?(A B C)\n      TRACE(\n        ' - (c+a-1)==X so all non-constants must be set to non-zero to satisfy the sum+issame. that means morph to isall'\n      );\n      TRACE_MORPH(\n        'R=sum(A:boolypair,B:boolypair,...,y,z,...),S=R==?(max(A)+max(B)+x+y+...)',\n        'S=all?(A B C ...)'\n      );\n\n      // Sum will fit isall. it'll be exactly the same size\n      // only need to update the op code and the result index, as the rest remains the same\n      ml_enc8(ml, sumOffset, ML_ISALL);\n    } else {\n      TRACE(' - min < X < max, cant morph this, bailing');\n      return false;\n    }\n\n    return _trick_issame_sum_tail(\n      sumOffset,\n      issameOffset,\n      argCount,\n      indexR,\n      indexS,\n      indexX,\n      constantValue,\n      constantArgIndex\n    );\n  }\n\n  function _trick_issame_sum_domain(\n    ml,\n    sumOffset,\n    argCount,\n    indexR,\n    issameOffset,\n    indexS,\n    indexX,\n    X,\n    constantValue,\n    constantArgIndex\n  ) {\n    TRACE(' - _trick_issame_sum_domain', domain__debug(X));\n    // This is when the X of S=R==?X is an unsolved domain\n\n    // R = sum(A B C), S = R ==? [0 2]      \"are not all of ABC set\"\n    // R = sum(A B C 5), S = R ==? [0 2]    S=0 because R is always at least 5. we ignore this here\n    // R = sum(A B C 5), S = R ==? [5 7]    \"are not all of ABC set\"\n\n    // R = sum(A B C), S = R ==? [1 3]      \"are some of ABC set\"\n    // R = sum(A B C 5), S = R ==? [1 3]    S=0 because R is always at least 5. we ignore this here\n    // R = sum(A B C 5), S = R ==? [6 8]    \"are some of ABC set\"\n\n    // note: we're not checking the sum bounds here (R is not a leaf). we only want to know how\n    // the sum bounds relate to X of the issame.\n\n    TRACE(\n      ' - n=',\n      argCount,\n      ', c=',\n      constantValue,\n      '; X=',\n      domain__debug(X),\n      ', issome means [c+1 c+n-1] so [',\n      constantValue + 1,\n      ',',\n      constantValue + argCount - 1,\n      '], and isnall means [c (c-(C?1:0))+n-1] so [',\n      constantValue,\n      ',',\n      constantValue - (constantValue ? 1 : 0) + (argCount - 1),\n      ']'\n    );\n    ASSERT(ml_dec16(ml, issameOffset + 1) === 2, 'issame should have 2 args');\n\n    if (\n      X ===\n      domain_createRange(\n        constantValue + 1,\n        constantValue + argCount - (constantValue ? 1 : 0)\n      )\n    ) {\n      TRACE(' - X requires at least one var to be set, so issome');\n      TRACE_MORPH(\n        'R = sum(A:bool B:bool C:bool), S = R ==? [1 3]',\n        'S = some?(A B C)'\n      );\n      ml_enc8(ml, sumOffset, ML_ISSOME);\n    } else if (\n      X ===\n      domain_createRange(\n        constantValue,\n        constantValue - (constantValue ? 1 : 0) + (argCount - 1)\n      )\n    ) {\n      TRACE(' - X requires one var to be unset, so isnall');\n      TRACE_MORPH(\n        'R = sum(A:bool B:bool C:bool), S = R ==? [0 2]',\n        'S = nall?(A B C)'\n      );\n      ml_enc8(ml, sumOffset, ML_ISNALL);\n    } else {\n      TRACE(' - sum bounds does not match X in a useful way, bailing');\n      return false;\n    }\n\n    return _trick_issame_sum_tail(\n      sumOffset,\n      issameOffset,\n      argCount,\n      indexR,\n      indexS,\n      indexX,\n      constantValue,\n      constantArgIndex\n    );\n  }\n\n  function _trick_issame_sum_tail(\n    sumOffset,\n    issameOffset,\n    argCount,\n    indexR,\n    indexS,\n    indexX,\n    constantValue,\n    constantArgIndex\n  ) {\n    // Note: NO bailing here\n    TRACE(' - _trick_issame_sum_tail');\n    ASSERT(ml_dec16(ml, issameOffset + 1) === 2, 'issame should have 2 args');\n    const newArgCount = removeOneConstantFromArgs(\n      constantValue,\n      constantArgIndex,\n      argCount,\n      sumOffset\n    );\n\n    // Make S the result var for the isnall/issome/isnone/isall\n    ml_enc16(ml, sumOffset + SIZEOF_C + newArgCount * 2, indexS);\n\n    TRACE(' - eliminating the issame, marking all affected vars');\n\n    const args = markAndCollectArgs(ml, sumOffset, newArgCount);\n\n    // (R = sum(A B C) & (S = R==?3)        ->    S = all?(A B C)\n    // (R = sum(A B C) & (S = R==?0)        ->    S = none?(A B C)\n    // (R = sum(A B C) & (S = R==?[0 1])    ->    S = nall?(A B C)\n    // (R = sum(A B C) & (S = R==?[1 2])    ->    S = some?(A B C)\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - _trick_issame_sum_tail; force solving the issame (only)');\n      // Note: the sum is handled through addSumToSolveStack, which should resolve before this solvestack entry\n\n      let S = getDomain(indexS);\n      const R = getDomain(indexR);\n      let X = getDomain(indexX);\n      ASSERT(\n        domain_isSolved(R),\n        'this should be solved by the solvestack compiled after this one (addSumToSolveStack)'\n      );\n      TRACE(\n        ' - before: S=',\n        domain__debug(S),\n        ' = R=',\n        domain__debug(R),\n        ' ==? X=',\n        domain__debug(X)\n      );\n\n      if (!domain_isBooly(S)) {\n        if (!domain_intersection(R, X)) {\n          TRACE(' R and X dont intersect so S is falsy');\n          S = domain_removeGtUnsafe(S, 0);\n          setDomain(indexS, S);\n        } else {\n          force(indexX);\n          X = getDomain(indexX);\n          // Note: R should be solved here\n          if (R === X) {\n            TRACE(' - X==R so set S to truthy');\n            S = domain_removeValue(S, 0);\n            setDomain(indexS, S);\n          } else {\n            TRACE(' - X!=R so set S to falsy');\n            S = domain_removeGtUnsafe(S, 0);\n            setDomain(indexS, S);\n          }\n        }\n      }\n\n      TRACE(\n        ' - between: S=',\n        domain__debug(S),\n        ' = R=',\n        domain__debug(R),\n        ' ==? X=',\n        domain__debug(X)\n      );\n\n      ASSERT(!domain_isBooly(S));\n      if (domain_isZero(S)) {\n        TRACE(' - S=0 so X != R');\n        X = domain_removeValue(X, domain_getValue(R));\n      } else {\n        TRACE(' - S>0 so X == R');\n        X = domain_intersection(X, R);\n      }\n\n      setDomain(indexX, X);\n\n      TRACE(\n        ' - after: S=',\n        domain__debug(S),\n        ' = R=',\n        domain__debug(R),\n        ' ==? X=',\n        domain__debug(X)\n      );\n\n      ASSERT(getDomain(indexS));\n      ASSERT(getDomain(indexX));\n      ASSERT(getDomain(indexR), 'enforced by other solve stack');\n      ASSERT(!domain_isBooly(getDomain(indexS)));\n      ASSERT(\n        domain_isSolved(getDomain(indexR)),\n        'the sum result should also be solved (enforced by other solve stack)'\n      );\n      ASSERT(\n        domain_isZero(getDomain(indexS)) || domain_isSolved(getDomain(indexX)),\n        'if S>0 then X must be solved to guarantee the eq'\n      );\n      ASSERT(\n        domain_isZero(getDomain(indexS)) ===\n          !domain_intersection(getDomain(indexR), getDomain(indexX))\n      );\n    });\n    addSumToSolveStack(indexR, args, constantValue);\n\n    ml_eliminate(ml, issameOffset, SIZEOF_CR_2);\n\n    ASSERT(newArgCount === args.length);\n    bounty_markVar(bounty, indexS);\n    bounty_markVar(bounty, indexR);\n    bounty_markVar(bounty, indexX);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_islte_sum(\n    ml,\n    sumOffset,\n    indexR,\n    counts,\n    argCount,\n    min,\n    max,\n    constantValue,\n    constantArgIndex\n  ) {\n    // Only if all sum args are strict bools ([0 1]), one constant excluded\n\n    // (R = sum(A B C) & (S = R<=?0)        ->    S = none?(A B C)\n    // (R = sum(A B C) & (S = R<=?2)        ->    S = nall?(A B C)\n    // (R = sum(A B C) & (S = 1<=?R)        ->    S = some?(A B C)\n    // (R = sum(A B C) & (S = 3<=?R)        ->    S = all?(A B C)\n\n    // R = sum( ... ), S = R <=? 0          ->    S = none?( ... )\n    // R = sum( ... ), S = R <=? count-1    ->    S = nall?( ... )\n    // R = sum( ... ), S = 1 <=? R          ->    S = some?( ... )\n    // R = sum( ... ), S = count <=? R      ->    S = all?( ... )\n\n    const offset1 = bounty_getOffset(bounty, indexR, 0);\n    const offset2 = bounty_getOffset(bounty, indexR, 1);\n    const islteOffset = offset1 === sumOffset ? offset2 : offset1;\n    TRACE(\n      'trick_islte_sum; sumOffset:',\n      sumOffset,\n      ', islteOffset:',\n      islteOffset,\n      ', indexR:',\n      indexR,\n      ', countsR:',\n      counts,\n      ', metaR:',\n      bounty__debugMeta(bounty, indexR),\n      ', min=',\n      min,\n      ', max=',\n      max,\n      ', constantValue=',\n      constantValue\n    );\n\n    ASSERT(islteOffset > 0, 'offset should exist and cant be the first op');\n    ASSERT(\n      counts === 2,\n      'R should only be used in two constraints (sum and islte)'\n    );\n    ASSERT(\n      getMeta(bounty, indexR) ===\n        (BOUNTY_FLAG_ISLTE_ARG | BOUNTY_FLAG_SUM_RESULT),\n      'should be sum and islte arg',\n      counts,\n      bounty__debugMeta(bounty, indexR)\n    );\n    ASSERT(ml_dec8(ml, sumOffset) === ML_SUM, 'check sum offset');\n    ASSERT(ml_dec8(ml, islteOffset) === ML_ISLTE, 'check islte offset');\n    ASSERT(ml_dec16(ml, sumOffset + 1) === argCount, 'argcount should match');\n\n    const indexA = readIndex(ml, islteOffset + 1); // R or ?\n    const indexB = readIndex(ml, islteOffset + 3); // R or ?\n    const indexS = readIndex(ml, islteOffset + 5); // S\n\n    ASSERT(\n      indexA === indexR || indexB === indexR,\n      'R should be an arg of the islte'\n    );\n\n    let indexX = indexA;\n    if (indexX === indexR) indexX = indexB;\n\n    // (R = sum(...) & (S = A<=?B)\n    // (R = sum(...) & (S = R<=?X) or\n    // (R = sum(...) & (S = X<=?R)\n\n    const X = getDomain(indexX, true);\n    const vX = domain_getValue(X);\n    // We cant check 0 1 n-1 n here because a constant could affect those values. so only check whether X is solved.\n    if (vX < 0) {\n      TRACE(' - X is not solved, bailing');\n      return false;\n    }\n\n    const R = getDomain(indexR, true);\n\n    if (!domain_containsValue(R, vX)) {\n      // This case should be handled by the minimizer but deduper/earlier cutter steps could lead to it here anyways\n      // bailing so minimizer can take care of it in the next cycle\n      TRACE(' - R didnt contain B so unsafe for leaf cutting, bailing');\n      requestAnotherCycle = true;\n      return false;\n    }\n\n    TRACE(' - validating sum args now');\n\n    const want = domain_createRange(min, max);\n    const Rwant = domain_intersection(R, want);\n    TRACE(\n      ' - sum args summed; min is',\n      min,\n      'and max is',\n      max,\n      ', R must contain all values in between;',\n      domain__debug(R),\n      'and',\n      domain__debug(want),\n      '=',\n      domain__debug(Rwant),\n      '(',\n      Rwant === want,\n      ')'\n    );\n\n    if (Rwant !== want) {\n      TRACE(' - R cant represent all values of the sum so bailing');\n      return false;\n    }\n\n    // Note: we're not checking the sum bounds here (R is not a leaf). we only want to know how\n    // the sum bounds relate to X of the islte.\n\n    // the position of R in the isLte determines what values we care about here\n    // R = sum( ... ), S = R <=? 0          =>    S = none?( ... )\n    // R = sum( ... ), S = R <=? count-1    =>    S = nall?( ... )\n    // R = sum( ... ), S = 1 <=? R          =>    S = some?( ... )\n    // R = sum( ... ), S = count <=? R      =>    S = all?( ... )\n\n    let targetOp = 0;\n    if (indexA === indexR) {\n      ASSERT(indexB === indexX);\n      TRACE(\n        ' - X=',\n        vX,\n        ', n=',\n        argCount,\n        ', c=',\n        constantValue,\n        ', x is to the right. we care about 0 and n-1 (',\n        constantValue,\n        'and',\n        constantValue - (constantValue ? 1 : 0) + (argCount - 1),\n        ')'\n      );\n\n      // R = sum(A B C), S = R <=? 0          \"are none of ABC set\"\n      // R = sum(A B C 5), S = R <=? 0        S=0 because R is always at least 5. we ignore this here\n      // R = sum(A B C 5), S = R <=? 5        \"are non of ABC set\"\n\n      // R = sum(A B C), S = R <=? 2          \"are at most 2 of ABC set\"\n      // R = sum(A B C 5), S = R <=? 2        S=0 because R is always at least 5. we ignore this here\n      // R = sum(A B C 5), S = R <=? 7        \"are at most 2 of ABC set\"\n\n      if (vX === constantValue) {\n        //\n        TRACE(\n          ' - this is \"are none of the sum args set, ignoring the constant\"'\n        );\n        TRACE_MORPH('R = sum(A B C ...), S = R <=? 0', 'S = none?(A B C ...)');\n        targetOp = ML_ISNONE;\n      } else if (\n        vX ===\n        constantValue - (constantValue ? 1 : 0) + (argCount - 1)\n      ) {\n        TRACE(\n          ' - this is \"are not all of the sum args set, ignoring the constant\"'\n        );\n        TRACE_MORPH('R = sum( ... ), S = R <=? count-1', 'S = nall?( ... )');\n        targetOp = ML_ISNALL;\n      } else {\n        TRACE(' - Unable to apply trick, bailing');\n        return false;\n      }\n    } else {\n      ASSERT(indexA === indexX && indexB === indexR);\n      TRACE(\n        ' - X=',\n        vX,\n        ', n=',\n        argCount,\n        ', c=',\n        constantValue,\n        ', x is to the left. we care about 1 and n (',\n        constantValue + 1,\n        'and',\n        constantValue - (constantValue ? 1 : 0) + argCount,\n        ')'\n      );\n\n      // R = sum(A B C), S = 1 <= R          \"are some of ABC set\"\n      // R = sum(A B C 5), S = 1 <=? R        S=1 because R is always at least 5. we ignore this here\n      // R = sum(A B C 5), S = 6 <=? R        \"are some of ABC set\"\n\n      // R = sum(A B C), S = 3 <=? R          \"are all of ABC set\"\n      // R = sum(A B C 5), S = 4 <=? R        S=1 because R is always at least 5. we ignore this here\n      // R = sum(A B C 5), S = 5+4-1 <=? R    \"are all of ABC set\"\n\n      if (vX === constantValue + 1) {\n        TRACE(' - this is \"is at least one sum arg set\"');\n        TRACE('R = sum( ... ), S = 1 <=? R', 'S = some?( ... )');\n        targetOp = ML_ISSOME;\n      } else if (vX === constantValue - (constantValue ? 1 : 0) + argCount) {\n        TRACE(' - this is \"are all of the sum args set\"');\n        TRACE('R = sum( ... ), S = count <=? R', 'S = all?( ... )');\n        targetOp = ML_ISALL;\n      } else {\n        TRACE(' - Unable to apply trick, bailing');\n        return false;\n      }\n    }\n\n    ASSERT(targetOp !== 0, 'should be one of the four reifier ops');\n\n    // NOW update the op. we won't bail after this point.\n    ml_enc8(ml, sumOffset, targetOp);\n\n    TRACE(' - eliminating the islte, marking all affected vars');\n    TRACE(\n      ' - constant value:',\n      constantValue,\n      ', arg index:',\n      constantArgIndex\n    );\n\n    const newArgCount = removeOneConstantFromArgs(\n      constantValue,\n      constantArgIndex,\n      argCount,\n      sumOffset\n    );\n    const args = markAndCollectArgs(ml, sumOffset, newArgCount);\n\n    // The position of R in the isLte determines what values we care about here\n    // R = sum( ... ), S = R <=? 0          =>    S = none?( ... )\n    // R = sum( ... ), S = R <=? count-1    =>    S = nall?( ... )\n    // R = sum( ... ), S = 1 <=? R          =>    S = some?( ... )\n    // R = sum( ... ), S = count <=? R      =>    S = all?( ... )\n\n    // make S the result var for the reifier\n    ml_enc16(ml, sumOffset + SIZEOF_C + newArgCount * 2, indexS);\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_islte_sum; force solving S (only)');\n      // Note: the sum is handled through addSumToSolveStack, which should resolve before this solvestack entry\n\n      let S = getDomain(indexS);\n      const R = getDomain(indexR);\n      ASSERT(\n        domain_isSolved(R),\n        'this should be solved by the solvestack compiled after this one (addSumToSolveStack)'\n      );\n      TRACE(\n        ' - before: S=',\n        domain__debug(S),\n        ', R=',\n        domain__debug(R),\n        ', vX=',\n        vX,\n        ', x left?',\n        indexA === indexX\n      );\n\n      if (!domain_isBooly(S)) {\n        if (indexX === indexA) {\n          // S = x <= R\n          if (vX <= domain_min(R)) {\n            TRACE(' - x<=R so set S to truthy');\n            S = domain_removeValue(S, 0);\n            setDomain(indexS, S);\n          } else {\n            TRACE(' - R>x so set S to falsy');\n            S = domain_removeGtUnsafe(S, 0);\n            setDomain(indexS, S);\n          }\n        } else {\n          // S = R <= x\n          if (domain_max(R) <= vX) {\n            TRACE(' - R<=x so set S to truthy');\n            S = domain_removeValue(S, 0);\n            setDomain(indexS, S);\n          } else {\n            TRACE(' - R>x so set S to falsy');\n            S = domain_removeGtUnsafe(S, 0);\n            setDomain(indexS, S);\n          }\n        }\n      }\n\n      TRACE(\n        ' - after: S=',\n        domain__debug(getDomain(indexS)),\n        ', R=',\n        domain__debug(getDomain(indexR)),\n        ', X=',\n        domain__debug(getDomain(indexX))\n      );\n\n      ASSERT(getDomain(indexS));\n      ASSERT(getDomain(indexR), 'enforced by other solve stack');\n      ASSERT(args.every(getDomain));\n      ASSERT(!domain_isBooly(getDomain(indexS)));\n      ASSERT(\n        domain_isSolved(getDomain(indexR)),\n        'the sum result should also be solved (enforced by other solve stack)'\n      );\n      ASSERT(\n        domain_isZero(getDomain(indexS)) !==\n          (indexX === indexA\n            ? vX <= domain_min(getDomain(indexR))\n            : domain_max(getDomain(indexR)) <= vX),\n        'S=x<=R or S=R<=x should hold'\n      );\n    });\n    addSumToSolveStack(indexR, args, constantValue);\n\n    ml_eliminate(ml, islteOffset, SIZEOF_VVV);\n\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_xnor_pseudoSame(ml, offset, indexA, boolyA, indexB, boolyB) {\n    // A or B or both are only used as a boolean (in the zero-nonzero sense, not strictly 0,1)\n    // the xnor basically says that if one is zero the other one is too, and otherwise neither is zero\n    // cominbing that with the knowledge that both vars are only used for zero-nonzero, one can be\n    // considered a pseudo-alias for the other. we replace it with the other var and defer solving it.\n    // when possible, pick a strictly boolean domain because it's more likely to allow new tricks.\n\n    // note that for a booly, the actual value is irrelevant. whether it's 1 or 5, the ops will normalize\n    // this to zero and non-zero anyways. and by assertion the actual value is not used inside the problem\n\n    TRACE(\n      ' - trick_xnor_pseudoSame; found booly-eq in a xnor:',\n      indexA,\n      '!^',\n      indexB,\n      ', A booly?',\n      boolyA,\n      ', B booly?',\n      boolyB\n    );\n    ASSERT(\n      boolyA || boolyB,\n      'at least one of the args should be a real booly (as reported by bounty)'\n    );\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'should have 2 args');\n\n    // Ok, a little tricky, but we're going to consider the bool to be a full alias of the other var.\n    // once we create a solution we will override the value and apply the booly constraint and assign\n    // it either its zero or nonzero value(s) depending on the other value of this xnor.\n\n    let indexEliminate = indexB; // Eliminate\n    let indexKeep = indexA; // Keep\n\n    // keep the non-bool if possible\n    if (!boolyB) {\n      TRACE(' - keeping B instead because its not a booly');\n      indexEliminate = indexA;\n      indexKeep = indexB;\n    }\n\n    cutAddPseudoBoolyAlias(indexKeep, indexEliminate);\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    somethingChanged();\n  }\n\n  function trick_sum_booly(ml, sumOffset, indexR, countsR, sum, argCount) {\n    // R is used as a result var for a sum\n    // we must first confirm that R is a booly (only used as arg in booly places of ops), except for being a sum-result\n    // in that case the sum is an isSome because that's the only thing that matters for R\n    // note that the meta flags will claim non-booly because (at least) R is the sum result var so we gotta confirm that\n\n    TRACE(\n      'trick_sum_booly; sumOffset:',\n      sumOffset,\n      ', indexR:',\n      indexR,\n      ', countsR:',\n      countsR,\n      ', argCount:',\n      argCount,\n      ', metaR:',\n      bounty__debugMeta(bounty, indexR)\n    );\n\n    ASSERT(\n      (getMeta(bounty, indexR) & BOUNTY_FLAG_SUM_RESULT) ===\n        BOUNTY_FLAG_SUM_RESULT,\n      'shouldve been confirmed'\n    );\n    ASSERT(ml_dec16(ml, sumOffset + 1) === argCount, 'argcount should match');\n\n    const R = getDomain(indexR, true);\n    TRACE(\n      ' - first checking whether R (',\n      domain__debug(R),\n      ') is a booly when not counting this sum (pair?',\n      domain_isBoolyPair(R),\n      ')'\n    );\n\n    if (!domain_isBoolyPair(R)) {\n      // If a var only has a zero and one nonzero value it doesnt matter: it's always booly\n      for (let i = 0; i < countsR; ++i) {\n        const offset = bounty_getOffset(bounty, indexR, i);\n        ASSERT(offset, 'should exist');\n\n        if (offset !== sumOffset) {\n          const opCode = ml_dec8(ml, offset);\n          const isBooly = cut_isBoolyOp(opCode, true, ml, offset, indexR);\n          if (isBooly === ML_BOOLY_NO) {\n            TRACE(\n              ' - R is at least a non-booly in one op (' +\n                ml__opName(opCode) +\n                '), bailing'\n            );\n            return;\n          }\n\n          ASSERT(\n            isBooly === ML_BOOLY_YES,\n            'cannot be maybe because asked for explicit lookups'\n          );\n        }\n      }\n    }\n\n    TRACE(\n      ' - ok, R is booly. next confirming that R can represent any valuation of the sum args, total sum of args:',\n      domain__debug(sum),\n      'R:',\n      domain__debug(R)\n    );\n\n    // If sum doesnt intersect with domain then there are valuations of the sum-args such that the result is not in R\n    // we could theoretically fix that but it'll be too much work and little to show for. so we just bail.\n    if (sum !== domain_intersection(R, sum)) {\n      TRACE('  - R does not contain all possible sums so we bail');\n      return false;\n    }\n\n    TRACE('  - R contains all sums so we can morph the sum to an isall');\n\n    const args = markAndCollectArgs(ml, sumOffset, argCount);\n\n    // So; in the remaining problem R is only used as booly. so we dont care what the actual value is of R, just\n    // whether it's zero or non-zero. so it will arbitrarily be set thusly. we'll add a solveStack entry that\n    // makes sure R is solved to the sum of whatever the args are solved to.\n    const oR = R; // Back up R because the issome may change it irrelevantly\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_sum_booly');\n      // Note: we need to force solve all args to make sure the sum constraint holds\n\n      let vR = 0;\n      for (let i = 0; i < argCount; ++i) {\n        vR += force(args[i]);\n      }\n\n      const R = domain_intersectionValue(oR, vR);\n      ASSERT(R, 'R should be able to reflect the solution');\n      if (oR !== R) setDomain(indexR, R, false, true);\n    });\n\n    // The sum is a count-result-op and so is the isAll so we only need to replace the opcode\n    ml_enc8(ml, sumOffset, ML_ISSOME);\n\n    bounty_markVar(bounty, indexR);\n    somethingChanged();\n    return true;\n  }\n\n  function trick_issame_issame_sum(\n    ml,\n    sumOffset,\n    indexR,\n    countsR,\n    sum,\n    argCount\n  ) {\n    // R = sum(A B), S = R ==? 1, T = R ==? 2    ->    S = A !=? B, T = all?(A B)\n    // the sum is confirmed already\n    // we need to confirm that this concerns 2x issame (and not 2x sum)\n    // we need to confirm that each issame has R and either a literal 1 or 2 (and exactly 2 args)\n\n    TRACE(' - trick_issame_issame_sum');\n    TRACE(\n      ' - R = sum(A B), S = R ==? 1, T = R ==? 2    =>    S = A !=? B, T = all?(A B)'\n    );\n\n    ASSERT(countsR === 3, 'should be 3 links to this sum');\n    let issameOffset1 = bounty_getOffset(bounty, indexR, 0);\n    let issameOffset2 = bounty_getOffset(bounty, indexR, 1);\n    ASSERT(\n      issameOffset1 === sumOffset ||\n        issameOffset2 === sumOffset ||\n        bounty_getOffset(bounty, indexR, 2) === sumOffset,\n      'sum should be one of the three'\n    );\n    if (issameOffset1 === sumOffset)\n      issameOffset1 = bounty_getOffset(bounty, indexR, 2);\n    else if (issameOffset2 === sumOffset)\n      issameOffset2 = bounty_getOffset(bounty, indexR, 2);\n\n    if (\n      ml_dec8(ml, issameOffset1) !== ML_ISSAME ||\n      ml_dec8(ml, issameOffset2) !== ML_ISSAME\n    ) {\n      TRACE(\n        ' - this wasnt sum+issame+issame, bailing',\n        ml__opName(ml_dec8(ml, issameOffset1)),\n        ml__opName(ml_dec8(ml, issameOffset2))\n      );\n      return false;\n    }\n\n    const argCount1 = ml_dec16(ml, issameOffset1 + 1);\n    const argCount2 = ml_dec16(ml, issameOffset2 + 1);\n\n    if (argCount1 !== 2 || argCount2 !== 2) {\n      TRACE(' - at least one of the issame ops does not have 2 args, bailing');\n      return false;\n    }\n\n    // R = sum(A B)      R = sum(A B)\n    // S = K ==? L       S = R ==? X\n    // T = M ==? N       T = R ==? Y\n    //    X==1&Y==2 | X==2&Y==1\n\n    const indexA = readIndex(ml, sumOffset + OFFSET_C_A);\n    const indexB = readIndex(ml, sumOffset + OFFSET_C_B);\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n    TRACE(' - A:', domain__debug(A), ', B:', domain__debug(B));\n    if (!domain_isBool(A) || !domain_isBool(B)) {\n      TRACE(' - A or B wasnt bool, bailing');\n      return false;\n    }\n\n    const indexK = readIndex(ml, issameOffset1 + OFFSET_C_A);\n    const indexL = readIndex(ml, issameOffset1 + OFFSET_C_B);\n    const indexS = readIndex(ml, issameOffset1 + OFFSET_C_R);\n    const indexM = readIndex(ml, issameOffset2 + OFFSET_C_A);\n    const indexN = readIndex(ml, issameOffset2 + OFFSET_C_B);\n    const indexT = readIndex(ml, issameOffset2 + OFFSET_C_R);\n\n    ASSERT(\n      indexK === indexR || indexL === indexR,\n      'R should be arg to this issame'\n    );\n    let indexX = indexK;\n    if (indexX === indexR) indexX = indexL;\n\n    ASSERT(\n      indexM === indexR || indexN === indexR,\n      'R should be arg to this issame'\n    );\n    let indexY = indexM;\n    if (indexY === indexR) indexY = indexN;\n\n    const X = getDomain(indexX, true);\n    const vX = domain_getValue(X);\n    const Y = getDomain(indexY, true);\n    const vY = domain_getValue(Y);\n\n    TRACE(\n      ' - (X)  S=K==?L :',\n      `${indexS}=${indexK}==?${indexL}`,\n      domain__debug(getDomain(indexS, true)),\n      '=',\n      domain__debug(getDomain(indexK, true)),\n      '==?',\n      domain__debug(getDomain(indexL, true))\n    );\n    TRACE(\n      ' - (Y)  T=M==?N :',\n      `${indexT}=${indexM}==?${indexN}`,\n      domain__debug(getDomain(indexT, true)),\n      '=',\n      domain__debug(getDomain(indexM, true)),\n      '==?',\n      domain__debug(getDomain(indexN, true))\n    );\n    TRACE(\n      ' - X=',\n      indexX,\n      '=',\n      domain__debug(X),\n      ', Y=',\n      indexY,\n      '=',\n      domain__debug(Y)\n    );\n\n    if ((vX !== 1 && vX !== 2) || (vY !== 1 && vY !== 2) || vX === vY) {\n      TRACE(' - issame pattern doesnt match, bailing');\n      return false;\n    }\n\n    TRACE_MORPH(\n      'R = sum(A B), S = R ==? 1, T = R ==? 2',\n      'S = A !=? B, T = all?(A B)'\n    );\n    TRACE(\n      ' - pattern should match now so we can start the morph. one issame becomes A!=?B, the sum becomes all?(A B), the other issame is eliminated, sum solve stack entry added for R'\n    );\n    ASSERT(\n      (vX === 1 && vY === 2) || (vX === 2 && vY === 1),\n      'we just checked this!'\n    );\n\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - trick_issame_issame_sum');\n      TRACE(' - ensure the sum result and args are all solved');\n\n      const R = getDomain(indexR);\n\n      // A and B were confirmed to be bools\n      // R is confirmed to be [0 2] (still)\n      ASSERT(R === domain_createRange(0, 2));\n\n      // Force and sum the values of A and B and set R to that\n      const sum = force(indexA) + force(indexB);\n      const nR = domain_intersectionValue(R, sum);\n      if (R !== nR) setDomain(indexR, nR);\n\n      ASSERT(getDomain(indexA));\n      ASSERT(getDomain(indexB));\n      ASSERT(getDomain(indexR));\n      ASSERT(domain_isSolved(getDomain(indexA)));\n      ASSERT(domain_isSolved(getDomain(indexB)));\n      ASSERT(domain_isSolved(getDomain(indexR)));\n      ASSERT(\n        domain_getValue(getDomain(indexR)) ===\n          domain_getValue(getDomain(indexA)) +\n            domain_getValue(getDomain(indexB))\n      );\n    });\n\n    // T = all?(A B)\n    ml_enc8(ml, sumOffset, ML_ISALL);\n    ASSERT(argCount === 2, 'change the offset below if this changes');\n    ml_enc16(ml, sumOffset + OFFSET_C_C, vX === 2 ? indexS : indexT);\n\n    // S = A !=? B\n    ASSERT(\n      ml_dec16(ml, issameOffset1 + 1) === 2,\n      'arg count for issame must be 2'\n    );\n    ml_enc8(ml, issameOffset1, ML_ISDIFF);\n    ml_enc16(ml, issameOffset1 + OFFSET_C_A, indexA);\n    ml_enc16(ml, issameOffset1 + OFFSET_C_B, indexB);\n    ml_enc16(ml, issameOffset1 + OFFSET_C_R, vX === 1 ? indexS : indexT);\n\n    // Drop the other issame\n    ASSERT(\n      ml_dec16(ml, issameOffset2 + 1) === 2,\n      'arg count for issame must be 2'\n    );\n    ml_eliminate(ml, issameOffset2, SIZEOF_CR_2);\n\n    bounty_markVar(bounty, indexA);\n    bounty_markVar(bounty, indexB);\n    bounty_markVar(bounty, indexR);\n    bounty_markVar(bounty, indexS);\n    bounty_markVar(bounty, indexX);\n    bounty_markVar(bounty, indexT);\n    bounty_markVar(bounty, indexY);\n    somethingChanged();\n\n    return true;\n  }\n\n  // ##############\n\n  function cut_isBoolyOp(opCode, checkMaybes, ml, offset, index) {\n    TRACE(\n      ' - cut_isBoolyOp, op=',\n      ml__opName(opCode),\n      ', thorough check?',\n      checkMaybes\n    );\n    switch (opCode) {\n      case ML_LT:\n      case ML_LTE:\n      case ML_MINUS:\n      case ML_DIV:\n      case ML_SUM:\n      case ML_PRODUCT:\n      case ML_DIFF:\n      case ML_SAME:\n        return ML_BOOLY_NO;\n\n      case ML_XOR:\n      case ML_XNOR:\n      case ML_IMP:\n      case ML_NIMP:\n      case ML_ALL:\n      case ML_NALL:\n      case ML_SOME:\n      case ML_NONE:\n        return ML_BOOLY_YES;\n\n      case ML_NOLEAF:\n        return ML_BOOLY_YES;\n      case ML_NOBOOL:\n        return ML_BOOLY_NO;\n\n      case ML_ISDIFF:\n      case ML_ISSAME:\n        // If the var occurs as any of the args, it is not a booly (regardless)\n        if (!checkMaybes) return ML_BOOLY_MAYBE;\n        TRACE(\n          '   - thorough check for',\n          ml__opName(opCode),\n          'on index=',\n          index\n        );\n        const argCount = ml_dec16(ml, offset + 1);\n        for (let i = 0; i < argCount; ++i) {\n          if (readIndex(ml, offset + SIZEOF_C + i * 2) === index)\n            return ML_BOOLY_NO;\n        }\n\n        ASSERT(\n          readIndex(ml, offset + SIZEOF_C + argCount * 2) === index,\n          'if none of the args is index then R must be index'\n        );\n        return ML_BOOLY_YES;\n\n      case ML_ISLT:\n      case ML_ISLTE:\n        // For these ops the result var is fixed in third position\n        if (!checkMaybes) return ML_BOOLY_MAYBE;\n        TRACE(\n          '   - thorough check for',\n          ml__opName(opCode),\n          'on index=',\n          index\n        );\n        if (\n          readIndex(ml, offset + 1) === index ||\n          readIndex(ml, offset + 3) === index\n        )\n          return ML_BOOLY_NO;\n        ASSERT(\n          readIndex(ml, offset + 5) === index,\n          'if neither arg then index must be result'\n        );\n        return ML_BOOLY_YES;\n\n      case ML_ISALL:\n      case ML_ISNALL:\n      case ML_ISSOME:\n      case ML_ISNONE:\n        return ML_BOOLY_YES;\n\n      case ML_START:\n      case ML_JMP:\n      case ML_JMP32:\n      case ML_NOOP:\n      case ML_NOOP2:\n      case ML_NOOP3:\n      case ML_NOOP4:\n      case ML_STOP:\n        return THROW('should not be used for these ops');\n\n      default:\n        TRACE('(ml_isBooly) unknown op: ' + opCode);\n        THROW('(ml_isBooly) unknown op: ' + opCode);\n    }\n  }\n\n  function removeOneConstantFromArgs(\n    constantValue,\n    constantArgIndex,\n    argCount,\n    sumOffset\n  ) {\n    TRACE(\n      ' - removeOneConstantFromArgs; only if there is at most one constant at all; const value:',\n      constantValue,\n      ', arg pos:',\n      constantArgIndex,\n      ', args:',\n      argCount,\n      ', op offset:',\n      sumOffset\n    );\n    ASSERT(constantArgIndex < argCount, 'arg pos should be valid');\n    if (constantArgIndex >= 0) {\n      // We want to eliminate the constant arg\n      // it may not be in last position (it ought to be but *shrug*), if so simply overwrite it by the last element\n      if (constantArgIndex !== argCount - 1) {\n        TRACE(\n          ' - constant wasnt at end, moving it there now, index=',\n          constantArgIndex,\n          ', argCount=',\n          argCount\n        );\n        const lastIndex = readIndex(\n          ml,\n          sumOffset + SIZEOF_C + (argCount - 1) * 2\n        );\n        ml_enc16(ml, sumOffset + SIZEOF_C + constantArgIndex * 2, lastIndex);\n        // We want to drop the constant so we dont need to copy that back\n      }\n\n      TRACE(\n        ' - constant is (now) at the end, reducing arg count to drop it from',\n        argCount,\n        'to',\n        argCount - 1\n      );\n      TRACE(' - op before:', ml__debug(ml, sumOffset, 1, problem));\n      ASSERT(\n        domain_getValue(\n          getDomain(\n            readIndex(ml, sumOffset + SIZEOF_C + (argCount - 1) * 2),\n            true\n          )\n        ) === constantValue,\n        'the constant should now be in last position of the sum'\n      );\n      // Reduce sum arg count\n      --argCount;\n      ml_enc16(ml, sumOffset + 1, argCount);\n      // Note: no need to copy R one position back because we will explicitly write an S there anyways\n      // write a jump in the new open space\n      ml_enc8(ml, sumOffset + SIZEOF_C + (argCount + 1) * 2, ML_NOOP2);\n\n      TRACE(' - op after:', ml__debug(ml, sumOffset, 1, problem));\n      ASSERT(\n        ml_validateSkeleton(\n          ml,\n          'removeOneConstantFromArgs; after constant elimination'\n        )\n      );\n    }\n\n    return argCount;\n  }\n\n  function addSumToSolveStack(indexR, args, constantValue) {\n    TRACE(' - adding solvestack entry for isnone/isall/issome/isnall');\n    TRACE(\n      ' - args sum to',\n      domain__debug(args.map(getDomain).reduce((a, b) => domain_plus(a, b))),\n      ', constant:',\n      constantValue,\n      ', total:',\n      domain__debug(\n        domain_plus(\n          domain_createValue(constantValue),\n          args.map(getDomain).reduce((a, b) => domain_plus(a, b))\n        )\n      ),\n      ', R=',\n      domain__debug(getDomain(indexR)),\n      ', all args:',\n      args\n        .map(getDomain)\n        .map(domain__debug)\n        .join(' ')\n    );\n    ASSERT(\n      domain_intersection(\n        getDomain(indexR),\n        domain_plus(\n          domain_createValue(constantValue),\n          args.map(getDomain).reduce((a, b) => domain_plus(a, b))\n        )\n      ) === getDomain(indexR),\n      'R should be able to reflect the outcome of summing any of its args'\n    );\n\n    // Note: either way, R must reflect the sum of its args. so its the same solve\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(\n        ' - addSumToSolveStack; cut sum+reifier -> isnone/issome/isall/isnall'\n      );\n      const oR = getDomain(indexR);\n      let vR = 0;\n      for (let i = 0, n = args.length; i < n; ++i) {\n        const vN = force(args[i]);\n        ASSERT((vN & 1) >= 0, 'should be bool');\n        if (vN) ++vR;\n      }\n\n      const R = domain_intersectionValue(oR, vR + constantValue);\n      ASSERT(R, 'R should be able to reflect the solution');\n      if (oR !== R) setDomain(indexR, R);\n    });\n  }\n\n  function cutAddPseudoBoolyAlias(indexKeep, indexEliminate) {\n    const oE = getDomain(indexEliminate, true); // Remember what E was because it will be replaced by false to mark it an alias\n    TRACE(\n      ' - pseudo-alias for booly xnor arg;',\n      indexKeep,\n      '@',\n      indexEliminate,\n      '  ->  ',\n      domain__debug(getDomain(indexKeep)),\n      '@',\n      domain__debug(getDomain(indexEliminate)),\n      'replacing',\n      indexEliminate,\n      'with',\n      indexKeep\n    );\n\n    const XNOR_EXCEPTION = true;\n    solveStack.push((_, force, getDomain, setDomain) => {\n      TRACE(' - cutAddPseudoBoolyAlias');\n      TRACE(\n        ' -',\n        indexKeep,\n        '!^',\n        indexEliminate,\n        '  ->  ',\n        domain__debug(getDomain(indexKeep)),\n        '!^',\n        domain__debug(oE)\n      );\n      const vK = force(indexKeep);\n      let E;\n      if (vK === 0) {\n        E = domain_removeGtUnsafe(oE, 0);\n      } else {\n        E = domain_removeValue(oE, 0);\n      }\n\n      TRACE('  -> updating', domain__debug(oE), 'to', domain__debug(E));\n      ASSERT(E, 'E should be able to reflect the solution');\n      // Always set it even if oE==E\n      setDomain(indexEliminate, E, true, XNOR_EXCEPTION);\n    });\n\n    // Note: addAlias will push a defer as well. since the defers are resolved in reverse order,\n    // we must call addAlias after adding our own defer, otherwise our change will be lost.\n    addAlias(indexEliminate, indexKeep, 'cutAddPseudoBoolyAlias');\n  }\n\n  function markAndCollectArgs(ml, opOffset, argCount, except = -1) {\n    TRACE(\n      ' - markAndCollectArgs, from offset',\n      opOffset,\n      'for',\n      argCount,\n      'vars'\n    );\n    const args = [];\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, opOffset + SIZEOF_C + i * 2);\n      if (index !== except) args.push(index);\n      bounty_markVar(bounty, index);\n    }\n\n    return args;\n  }\n\n  function markAllArgs(ml, opOffset, argCount) {\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, opOffset + SIZEOF_C + i * 2);\n      bounty_markVar(bounty, index);\n    }\n  }\n\n  function cut_moveTo(ml, offset, len) {\n    TRACE(\n      ' - trying to move from',\n      offset,\n      'to',\n      offset + len,\n      'delta = ',\n      len\n    );\n    switch (ml_dec8(ml, offset + len)) {\n      case ML_NOOP:\n      case ML_NOOP2:\n      case ML_NOOP3:\n      case ML_NOOP4:\n      case ML_JMP:\n      case ML_JMP32:\n        TRACE('  - moving to another jump so merging them now');\n        ml_compileJumpAndConsolidate(ml, offset, len);\n        pc = offset; // Restart, make sure the merge worked\n        break;\n      default:\n        pc = offset + len;\n        break;\n    }\n  }\n}\n\nexport { cutter };\n","import {\n  ASSERT,\n  TRACE,\n  domain__debug,\n  domain_containsValue,\n  domain_createValue,\n  domain_getValue,\n  domain_isBooly,\n  domain_isBoolyPair,\n  domain_isZero,\n  domain_size,\n  domain_hasNoZero,\n  domain_intersection,\n  domain_isSolved,\n  domain_removeGtUnsafe,\n  domain_removeValue,\n  getTerm,\n} from 'fdlib';\n\nimport {\n  ML_ALL,\n  ML_NOBOOL,\n  ML_NOLEAF,\n  ML_DIFF,\n  ML_DIV,\n  ML_IMP,\n  ML_ISALL,\n  ML_ISDIFF,\n  ML_ISLT,\n  ML_ISLTE,\n  ML_ISNALL,\n  ML_ISNONE,\n  ML_ISSAME,\n  ML_ISSOME,\n  ML_JMP,\n  ML_JMP32,\n  ML_LT,\n  ML_LTE,\n  ML_MINUS,\n  ML_NALL,\n  ML_NIMP,\n  ML_NONE,\n  ML_NOOP,\n  ML_NOOP2,\n  ML_NOOP3,\n  ML_NOOP4,\n  ML_PRODUCT,\n  ML_SAME,\n  ML_SOME,\n  ML_START,\n  ML_STOP,\n  ML_SUM,\n  ML_XNOR,\n  ML_XOR,\n  OFFSET_C_A,\n  OFFSET_C_B,\n  OFFSET_C_R,\n  SIZEOF_V,\n  SIZEOF_W,\n  SIZEOF_VVV,\n  SIZEOF_C,\n  SIZEOF_C_2,\n  SIZEOF_CR_2,\n  ml__debug,\n  ml_cr2c2,\n  ml_dec16,\n  ml_dec32,\n  ml_eliminate,\n  ml_getOpSizeSlow,\n  ml_heapSort16bitInline,\n  ml_throw,\n  ml_vvv2c2,\n} from './ml';\n\nimport { m2d__debug } from './ml2dsl';\n\n// These global counters can be used to trace problems or print a dsl at explicit steps in the solve\nlet __runCounter = 0;\nlet __opCounter = 0;\n\nfunction deduper(ml, problem) {\n  ++__runCounter;\n  TRACE(\n    '\\n ## pr_dedupe, counter=',\n    __runCounter,\n    ',ml=',\n    ml.length < 50 ? ml.join(' ') : '<big>'\n  );\n\n  const { getDomain, setDomain, getAlias, addVar, addAlias } = problem;\n\n  let pc = 0;\n  const constraintHash = {}; // Keys are A@B or R=A@B and the vars can be an index (as is) or a literal prefixed with #\n  const debugHash = {};\n  const removed = 0;\n  const aliased = 0;\n  let emptyDomain = false;\n  innerLoop();\n  getTerm().log(\n    ' - dedupe removed',\n    removed,\n    'constraints and aliased',\n    aliased,\n    'result vars, emptyDomain=',\n    emptyDomain,\n    ', processed',\n    __opCounter,\n    'ops'\n  );\n  TRACE(m2d__debug(problem));\n\n  return emptyDomain ? -1 : aliased; // If aliases were created the minifier will want another go.\n\n  function dedupePairOc2(op) {\n    const indexA = getAlias(ml_dec16(ml, pc + OFFSET_C_A));\n    const indexB = getAlias(ml_dec16(ml, pc + OFFSET_C_B));\n\n    const key = op + ':' + indexA + ',' + indexB;\n    const debugString =\n      op +\n      ':' +\n      domain__debug(getDomain(indexA, true)) +\n      ',' +\n      domain__debug(getDomain(indexB, true));\n\n    if (op === '<' || op === '<=') {\n      if (checkLtLteFromRegular(op, indexA, indexB, debugString)) return;\n    }\n\n    // Below this line no more deduping, only appending\n\n    if (constraintHash[key] !== undefined) {\n      TRACE(\n        ' - dedupePairOc2; Found dupe constraint; eliminating the second one'\n      );\n      TRACE('    - #1:', debugHash[key]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, pc, SIZEOF_C_2);\n      return;\n    }\n\n    constraintHash[key] = 1;\n    debugHash[key] = debugString;\n    pc += SIZEOF_C_2;\n  }\n\n  function checkLtLteFromRegular(op, indexA, indexB, debugString) {\n    // Check whether reifiers have matching non-reifiers (valid artifacts), so `R=A<?B` and `A<B` means `R>0`\n    // R>0 when: '<? <' '<=? <' '<=? <='\n    // R=? when: '<? <=' (because the A==B case always passes '<=' while '<?' depends on R)\n    TRACE('   - checking for matching regular inverted constraints');\n    ASSERT(\n      op === '<' || op === '<=',\n      'update this code if this assertion changes',\n      op\n    );\n\n    // Search for\n    // - R=A<?B A<B\n    // - R=A<=?B A<B\n    // - R=A<=?B A<=B\n    // => R>0\n    if (\n      op === '<' &&\n      checkLtLteFromRegularAB('<?', '<', indexA, indexB, debugString)\n    )\n      return true;\n    if (\n      op === '<' &&\n      checkLtLteFromRegularAB('<=?', '<', indexA, indexB, debugString)\n    )\n      return true;\n    if (\n      op === '<=' &&\n      checkLtLteFromRegularAB('<=?', '<=', indexA, indexB, debugString)\n    )\n      return true;\n\n    // Search for\n    // - R=A<?B B<A\n    // - R=A<?B B<=A\n    // - R=A<=?B B<A\n    // => R=0\n    if (\n      op === '<' &&\n      checkLtLteFromRegularBA('<?', '<', indexA, indexB, debugString)\n    )\n      return true;\n    if (\n      op === '<=' &&\n      checkLtLteFromRegularBA('<?', '<=', indexA, indexB, debugString)\n    )\n      return true;\n    if (\n      op === '<' &&\n      checkLtLteFromRegularBA('<=?', '<', indexA, indexB, debugString)\n    )\n      return true;\n\n    return false;\n  }\n\n  function checkLtLteFromRegularAB(rifop, regop, indexA, indexB, debugString) {\n    const rifKey = rifop + ':R=' + indexA + ',' + indexB;\n    const reifierOffset = constraintHash[rifKey];\n    if (reifierOffset) {\n      const indexR = getAlias(ml_dec16(ml, reifierOffset + 5));\n      const R = getDomain(indexR, true);\n      if (!domain_isBooly(R)) return false;\n      TRACE(\n        ' - checkLtLteFromReifierAB; found `R=A' +\n          rifop +\n          'B` and `A' +\n          regop +\n          'B`, eliminating reifier and booly-solving R, R=',\n        domain__debug(R)\n      );\n      TRACE('    - #1:', debugHash[rifKey]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, reifierOffset, SIZEOF_VVV);\n      TRACE(' - Removing 0 from R');\n      setDomain(indexR, domain_removeValue(R, 0));\n      return true;\n    }\n\n    return false;\n  }\n\n  function checkLtLteFromRegularBA(rifop, regop, indexA, indexB, debugString) {\n    const invRifKey = rifop + ':R=' + indexB + ',' + indexA;\n    const reifierOffset = constraintHash[invRifKey];\n    if (reifierOffset) {\n      const indexR = getAlias(ml_dec16(ml, reifierOffset + 5));\n      const R = getDomain(indexR, true);\n      if (!domain_isBooly(R)) return false;\n      TRACE(\n        ' - checkLtLteFromReifierBA; found `R=A' +\n          rifop +\n          'B` and `B' +\n          regop +\n          'A`, eliminating reifier and booly-solving R, R=',\n        domain__debug(R)\n      );\n      TRACE('    - #1:', debugHash[invRifKey]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, reifierOffset, SIZEOF_VVV);\n      TRACE(' - Setting R to 0');\n      setDomain(indexR, domain_removeGtUnsafe(R, 0));\n      return true;\n    }\n\n    return false;\n  }\n\n  function dedupeTripO(op) {\n    // This assumes the assignment is a fixed value, not booly like reifiers\n    // because in this case we can safely alias any R that with the same A@B\n\n    const indexA = getAlias(ml_dec16(ml, pc + 1));\n    const indexB = getAlias(ml_dec16(ml, pc + 3));\n    const indexR = getAlias(ml_dec16(ml, pc + 5));\n\n    const key = op + ':' + indexA + ',' + indexB;\n    const debugString =\n      op +\n      ':' +\n      domain__debug(getDomain(indexR, true)) +\n      '=' +\n      domain__debug(getDomain(indexA, true)) +\n      ',' +\n      domain__debug(getDomain(indexB, true));\n\n    let index = constraintHash[key];\n    if (index !== undefined) {\n      index = getAlias(index);\n      TRACE(\n        ' - dedupeTripO; Found dupe constraint; eliminating the second one, aliasing',\n        indexR,\n        'to',\n        index\n      );\n      TRACE('    - #1:', debugHash[key]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, pc, SIZEOF_VVV);\n      if (indexR !== index) {\n        const R = domain_intersection(\n          getDomain(indexR, true),\n          getDomain(index, true)\n        );\n        if (!R) return (emptyDomain = true);\n        // This probably wont matter for most of the cases, but it could make a difference\n        // setDomain(indexR, R); // (useless)\n        setDomain(index, R);\n        addAlias(indexR, index);\n      }\n\n      return;\n    }\n\n    constraintHash[key] = indexR;\n    debugHash[key] = debugString;\n    pc += SIZEOF_VVV;\n  }\n\n  function dedupeIsltIslte(op) {\n    // Islt, islte\n\n    const offset = pc;\n\n    const indexA = getAlias(ml_dec16(ml, pc + 1));\n    const indexB = getAlias(ml_dec16(ml, pc + 3));\n    const indexR = getAlias(ml_dec16(ml, pc + 5));\n\n    // We'll add a key by all three indexes and conditionally also on the args and the domain of R\n\n    const key = op + ':' + indexR + '=' + indexA + ',' + indexB;\n    const debugString =\n      op +\n      ':' +\n      domain__debug(getDomain(indexR, true)) +\n      '=' +\n      domain__debug(getDomain(indexA, true)) +\n      ',' +\n      domain__debug(getDomain(indexB, true));\n\n    TRACE('   - key=', key, ';', constraintHash[key] !== undefined);\n    if (constraintHash[key] !== undefined) {\n      TRACE(\n        ' - dedupeReifierTripU; Found dupe constraint; eliminating the second one'\n      );\n      TRACE('    - #1:', debugHash[key]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, pc, SIZEOF_VVV);\n      return;\n    }\n\n    const R = getDomain(indexR, true);\n\n    TRACE('   - checking for matching regular constraints');\n    ASSERT(\n      op.slice(0, -1) === '<' || op.slice(0, -1) === '<=',\n      'update this code if this assertion changes'\n    );\n    const regkey = op.slice(0, -1) + ':' + indexA + ',' + indexB;\n    if (constraintHash[regkey]) {\n      TRACE(\n        ' - dedupeReifierTripU; found R=A' +\n          op +\n          'B and A' +\n          op.slice(0, -1) +\n          'B, eliminating reifier and forcing R to truthy if R has a nonzero, R=',\n        domain__debug(R)\n      );\n      if (!domain_isZero(R)) {\n        // Has non-zero\n        TRACE('    - #1:', debugHash[regkey]);\n        TRACE('    - #2:', debugString);\n        ml_eliminate(ml, pc, SIZEOF_VVV);\n        TRACE(' - Removing 0 from R');\n        setDomain(indexR, domain_removeValue(R, 0));\n        return;\n      }\n    }\n\n    if (checkLtLteFromReifier(op, indexA, indexB, indexR, R, debugString))\n      return;\n\n    const invkey = (op === '<?' ? '<=?' : '<?') + ':R=' + indexB + ',' + indexA;\n    const invOffset = constraintHash[invkey];\n    if (invOffset) {\n      // One of:\n      // R = A <? B, S = B <=? A\n      // R = A <=? B, S = B <? A\n      // (note: not <?<? nor <=?<=? because they are NOT their own inverse)\n\n      TRACE(\n        ' - Found `',\n        op === '<?' ? 'R = A <? B, S = B <=? A' : 'R = A <=? B, S = B <? A',\n        '`'\n      );\n      const indexS = getAlias(ml_dec16(ml, invOffset + 5));\n      TRACE(\n        ' - morphing one op to `R ^ S`;',\n        domain__debug(getDomain(indexR)),\n        '^',\n        domain__debug(getDomain(indexS))\n      );\n      ml_vvv2c2(ml, offset, ML_XOR, indexR, indexS);\n      return;\n    }\n\n    TRACE(\n      '   - R:',\n      domain__debug(R),\n      ', size=',\n      domain_size(R),\n      ', has zero:',\n      !domain_hasNoZero(R),\n      '--> is safe?',\n      domain_isBoolyPair(R)\n    );\n    if (domain_isBoolyPair(R)) {\n      // Okay R has only two values and one of them is zero\n      // try to match the arg constraints only. if we find a dupe with\n      // the same R domain then we can alias that R with this one\n      // otherwise the two R's are pseudo xnor aliases\n\n      // we'll encode the domain instead of indexR to prevent\n      // multiple args on different R's to clash\n\n      // while R may not look it, it still represents a unique domain so we can use the\n      // encoded value as is here. wrap it to prevent clashes with indexes and numdoms\n      const key2 = op + ':[' + R + ']' + '=' + indexA + ',' + indexB;\n      TRACE('   - key2:', key2);\n\n      let index = constraintHash[key2];\n      if (index !== undefined) {\n        index = getAlias(index);\n        TRACE(\n          ' - dedupeIsltIslte; Found dupe reifier; eliminating the second one, aliasing',\n          indexR,\n          'to',\n          index\n        );\n        TRACE('    - #1:', debugHash[key2]);\n        TRACE('    - #2:', debugString);\n        ml_eliminate(ml, pc, SIZEOF_VVV);\n        if (indexR === index) {\n          TRACE(' - same indexes (perhaps aliased) so dont alias them here');\n        } else {\n          addAlias(indexR, index);\n        }\n\n        return;\n      }\n\n      constraintHash[key2] = indexR;\n      debugHash[key2] = debugString;\n    }\n\n    constraintHash[key] = 1;\n    debugHash[key] = debugString;\n\n    const keyr = op + ':R=' + indexA + ',' + indexB;\n    constraintHash[keyr] = offset;\n    debugHash[keyr] = debugString;\n\n    pc += SIZEOF_VVV;\n  }\n\n  function checkLtLteFromReifier(op, indexA, indexB, indexR, R, debugString) {\n    // Check whether reifiers have matching non-reifiers (valid artifacts), so `R=A<?B` and `A<B` means `R>0`\n    // R>0 when: '<? <' '<=? <' '<=? <='\n    // R=? when: '<? <=' (because the A==B case always passes '<=' while '<?' depends on R)\n    TRACE('   - checking for matching regular inverted constraints');\n    const regop = op.slice(0, -1);\n    ASSERT(\n      regop === '<' || regop === '<=',\n      'update this code if this assertion changes'\n    );\n    if (domain_isBooly(R)) {\n      // Search for\n      // - R=A<?B A<B\n      // - R=A<=?B A<B\n      // - R=A<=?B A<=B\n      // => R>0\n      if (\n        op === '<?' &&\n        checkLtLteFromReifierAB(\n          '<?',\n          '<',\n          indexA,\n          indexB,\n          indexR,\n          R,\n          debugString\n        )\n      )\n        return true;\n      if (\n        op === '<=?' &&\n        checkLtLteFromReifierAB(\n          '<=?',\n          '<',\n          indexA,\n          indexB,\n          indexR,\n          R,\n          debugString\n        )\n      )\n        return true;\n      if (\n        op === '<=?' &&\n        checkLtLteFromReifierAB(\n          '<=?',\n          '<=',\n          indexA,\n          indexB,\n          indexR,\n          R,\n          debugString\n        )\n      )\n        return true;\n\n      // Search for\n      // - R=A<?B B<A\n      // - R=A<?B B<=A\n      // - R=A<=?B B<A\n      // => R=0\n      if (\n        op === '<?' &&\n        checkLtLteFromReifierBA(\n          '<?',\n          '<',\n          indexA,\n          indexB,\n          indexR,\n          R,\n          debugString\n        )\n      )\n        return true;\n      if (\n        op === '<?' &&\n        checkLtLteFromReifierBA(\n          '<?',\n          '<=',\n          indexA,\n          indexB,\n          indexR,\n          R,\n          debugString\n        )\n      )\n        return true;\n      if (\n        op === '<=?' &&\n        checkLtLteFromReifierBA(\n          '<=?',\n          '<',\n          indexA,\n          indexB,\n          indexR,\n          R,\n          debugString\n        )\n      )\n        return true;\n    }\n\n    return false;\n  }\n\n  function checkLtLteFromReifierAB(\n    rifop,\n    regop,\n    indexA,\n    indexB,\n    indexR,\n    R,\n    debugString\n  ) {\n    const regkey = regop + ':' + indexA + ',' + indexB;\n    if (constraintHash[regkey]) {\n      TRACE(\n        ' - checkLtLteFromReifierAB; found `R=A' +\n          rifop +\n          'B` and `A' +\n          regop +\n          'B`, eliminating reifier and booly-solving R, R=',\n        domain__debug(R)\n      );\n      TRACE('    - #1:', debugHash[regkey]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, pc, SIZEOF_VVV);\n      TRACE(' - Removing 0 from R');\n      setDomain(indexR, domain_removeValue(R, 0));\n      return true;\n    }\n\n    return false;\n  }\n\n  function checkLtLteFromReifierBA(\n    rifop,\n    regop,\n    indexA,\n    indexB,\n    indexR,\n    R,\n    debugString\n  ) {\n    const reginvkey = regop + ':' + indexB + ',' + indexA;\n    if (constraintHash[reginvkey]) {\n      TRACE(\n        ' - checkLtLteFromReifierBA; found `R=A' +\n          rifop +\n          'B` and `B' +\n          regop +\n          'A`, eliminating reifier and booly-solving R, R=',\n        domain__debug(R)\n      );\n      TRACE('    - #1:', debugHash[reginvkey]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, pc, SIZEOF_VVV);\n      TRACE(' - Setting R to 0');\n      setDomain(indexR, domain_removeGtUnsafe(R, 0));\n      return true;\n    }\n\n    return false;\n  }\n\n  function dedupeBoolyList(op) {\n    // Isall, isnall, isnone, issome\n    // the tricky example:\n    // ####\n    // : A, B, C 1\n    // : R [0 1]\n    // : S [0 0 2 2]\n    // R = xxx?(A B C)\n    // S = xxx?(A B C)\n    // ####\n    // in this case R and S are \"booly alias\" but not actual alias\n    // basically this translates into a xnor (if R then S, if S then R)\n\n    const argCount = ml_dec16(ml, pc + 1);\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n\n    TRACE(' - dedupeBoolyList; args:', argCount, ', opsize:', opSize);\n\n    // First we want to sort the list. we'll do this inline to prevent array creation\n    ml_heapSort16bitInline(ml, pc + SIZEOF_C, argCount);\n\n    // Now collect them. the key should end up with an ordered list\n    let args = '';\n    let debugArgs = '';\n    for (let i = 0; i < argCount; ++i) {\n      const index = getAlias(ml_dec16(ml, pc + SIZEOF_C + i * 2));\n      args += index + ' ';\n      debugArgs += domain__debug(getDomain(index, true));\n    }\n\n    const indexR = getAlias(ml_dec16(ml, pc + SIZEOF_C + argCount * 2));\n\n    // We'll add a key with indexR and conditionally one with just the domain of R\n\n    const key = op + ':' + indexR + '=' + args;\n    const debugString =\n      op + ':' + domain__debug(getDomain(indexR, true)) + '=' + debugArgs;\n\n    TRACE('   - key=', key, ';', constraintHash[key] !== undefined);\n    if (constraintHash[key] !== undefined) {\n      TRACE(\n        ' - dedupeBoolyList; Found dupe constraint; eliminating the second one'\n      );\n      TRACE('    - #1:', debugHash[key]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, pc, opSize);\n      return;\n    }\n\n    constraintHash[key] = 1;\n    debugHash[key] = debugString;\n\n    const R = getDomain(indexR, true);\n    TRACE('   - R:', domain__debug(R), '--> is safe?', domain_isBoolyPair(R));\n    if (domain_isBoolyPair(R)) {\n      // Okay R has only two values and one of them is zero\n      // try to match the arg constraints only. if we find a dupe with\n      // the same R domain then we can alias that R with this one\n\n      // we'll encode the domain instead of indexR to prevent\n      // multiple args on different R's to clash\n\n      // while R may not look it, it still represents a unique domain so we can use the\n      // encoded value as is here. wrap it to prevent clashes with indexes and numdoms\n      const key2 = op + ':[' + R + ']' + '=' + args;\n      TRACE('   - key2:', key2);\n\n      let index = constraintHash[key2];\n      if (index !== undefined) {\n        index = getAlias(index);\n        TRACE(\n          ' - dedupeBoolyList; Found dupe reifier; eliminating the second one, aliasing',\n          indexR,\n          'to',\n          index\n        );\n        TRACE('    - #1:', debugHash[key2]);\n        TRACE('    - #2:', debugString);\n        ml_eliminate(ml, pc, opSize);\n        if (indexR === index) {\n          TRACE(' - same indexes (perhaps aliased) so dont alias them here');\n        } else {\n          ASSERT(\n            getDomain(indexR) === getDomain(index),\n            'should have already asserted that these two domains have only two values, a zero and a non-zero, and that they are equal'\n          );\n          addAlias(indexR, index);\n        }\n\n        return;\n      }\n\n      constraintHash[key2] = indexR;\n      debugHash[key2] = debugString;\n    }\n\n    TRACE(' - (no action, dedupeBoolyList)');\n    pc += opSize;\n  }\n\n  function dedupeNonBoolyList(op) {\n    // Sum, product\n\n    const argCount = ml_dec16(ml, pc + 1);\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n\n    // First we want to sort the list. we'll do this inline to prevent array creation\n    ml_heapSort16bitInline(ml, pc + SIZEOF_C, argCount);\n\n    // Now collect them. the key should end up with an ordered list\n    let args = '';\n    let debugArgs = '';\n    for (let i = 0; i < argCount; ++i) {\n      const argIndex = getAlias(ml_dec16(ml, pc + SIZEOF_C + i * 2));\n      args += argIndex + ' ';\n      debugArgs += domain__debug(getDomain(argIndex, true));\n    }\n\n    const indexR = getAlias(ml_dec16(ml, pc + SIZEOF_C + argCount * 2));\n\n    // We'll add a key without indexR because the results of these ops are fixed (unlike booly ops)\n\n    const key = op + ':' + '=' + args;\n    const debugString = op + ':' + debugArgs;\n\n    let index = constraintHash[key];\n    if (index !== undefined) {\n      index = getAlias(index);\n      TRACE(\n        ' - dedupeNonBoolyList; Found dupe reifier; eliminating the second one, aliasing',\n        indexR,\n        'to',\n        index\n      );\n      TRACE('    - #1:', debugHash[key]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, pc, opSize);\n      if (indexR !== index) {\n        // R = A <=? A (artifact)\n        const domain = domain_intersection(\n          getDomain(index, true),\n          getDomain(indexR, true)\n        );\n        setDomain(index, domain);\n        addAlias(indexR, index);\n      }\n\n      return;\n    }\n\n    constraintHash[key] = indexR;\n    debugHash[key] = debugString;\n\n    pc += opSize;\n  }\n\n  function dedupeVoidList(op) {\n    // Sum, product\n\n    const argCount = ml_dec16(ml, pc + 1);\n    const opSize = SIZEOF_C + argCount * 2;\n\n    // First we want to sort the list. we'll do this inline to prevent array creation\n    ml_heapSort16bitInline(ml, pc + SIZEOF_C, argCount);\n\n    // Now collect them. the key should end up with an ordered list\n    let args = '';\n    let debugArgs = '';\n    for (let i = 0; i < argCount; ++i) {\n      const argIndex = getAlias(ml_dec16(ml, pc + SIZEOF_C + i * 2));\n      args += argIndex + ' ';\n      debugArgs += domain__debug(getDomain(argIndex, true));\n    }\n\n    const key = op + ':' + '=' + args;\n    const debugString = op + ':' + debugArgs;\n\n    if (constraintHash[key] !== undefined) {\n      TRACE(\n        ' - dedupeVoidList; Found dupe constraint; eliminating the second one'\n      );\n      TRACE('    - #1:', debugHash[key]);\n      TRACE('    - #2:', debugString);\n      ml_eliminate(ml, pc, opSize);\n      return;\n    }\n\n    constraintHash[key] = 1;\n    debugHash[key] = debugString;\n\n    pc += opSize;\n  }\n\n  function dedupeInvIsSameIsDiff(op) {\n    TRACE(' - dedupeInvIsSameIsDiff;', op);\n    // Looking for this pattern:\n    // : X [2 3]\n    // R = X ==? 2\n    // S = X !=? 3\n    // which means R !^ S, or even == when R and S are size=2,min=0,R==S\n\n    const argCount = ml_dec16(ml, pc + 1);\n    if (argCount !== 2) {\n      // TODO: support any number of args here\n      TRACE('   - arg count != 2 so bailing, for now');\n      return false;\n    }\n\n    let indexA = getAlias(ml_dec16(ml, pc + OFFSET_C_A));\n    let indexB = getAlias(ml_dec16(ml, pc + OFFSET_C_B));\n    const indexR = getAlias(ml_dec16(ml, pc + OFFSET_C_R));\n\n    // If A or B is a constant, then B will be a constant afterwards, and A (only) as well if they are both constants\n    if (indexB < indexA) {\n      const t = indexB;\n      indexB = indexA;\n      indexA = t;\n    }\n\n    const A = getDomain(indexA, true);\n    const B = getDomain(indexB, true);\n\n    // Verify fingerprint\n    if (domain_size(A) !== 2) {\n      TRACE(' - size(A) != 2, bailing');\n      return false;\n    }\n\n    const vB = domain_getValue(B);\n    if (vB < 0 || !domain_containsValue(A, vB)) {\n      TRACE(\n        ' - B wasnt a constant or A didnt contain B, bailing',\n        domain__debug(A),\n        domain__debug(B)\n      );\n      return false;\n    }\n\n    // Fingerprint matches. A contains the solved value B and one other value\n    // check if opposite op is known\n\n    const invA = domain_removeValue(A, vB);\n    ASSERT(\n      domain_isSolved(invA),\n      'if A had two values and one of them vB, then invA should have one value'\n    );\n    const otherValue = domain_getValue(invA);\n    const indexInvA = addVar(undefined, otherValue, false, false, true); // Just gets the index for this constant\n    ASSERT(\n      getDomain(indexInvA) === domain_createValue(otherValue),\n      'should alias to a constant'\n    );\n    const invOp = op === 'issame' ? 'isdiff' : 'issame';\n    const key = invOp + ':' + indexA + ',' + indexInvA;\n    const debugString =\n      op +\n      ':' +\n      domain__debug(getDomain(indexR, true)) +\n      '=' +\n      domain__debug(getDomain(indexA, true)) +\n      ',' +\n      domain__debug(getDomain(indexB, true));\n\n    const indexS = constraintHash[key];\n    if (indexS === undefined) {\n      const thisKey = op + ':' + indexA + ',' + indexB;\n      TRACE(\n        ' - opposite for ' +\n          op +\n          ' (' +\n          invOp +\n          ') doesnt exist, adding this key then bailing'\n      );\n      TRACE(' - checked for key=', key, ', now adding key:', thisKey);\n\n      constraintHash[thisKey] = indexR;\n      debugHash[thisKey] = debugString;\n\n      return false;\n    }\n\n    TRACE(' - found the opposite of this constraint;');\n    TRACE('    - #1:', debugHash[key]);\n    TRACE('    - #2:', debugString);\n    TRACE(\n      ' - indexR !^ indexS, and perhaps indexR == indexS, check that case first'\n    );\n\n    ASSERT(argCount === 2, 'should have two args');\n\n    const R = getDomain(indexR, true);\n    if (\n      domain_size(R) === 2 &&\n      !domain_hasNoZero(R) &&\n      R === getDomain(indexS, true)\n    ) {\n      TRACE(\n        ' - indexR == indexS because',\n        domain__debug(R),\n        'has two elements, one of them zero, and R==S'\n      );\n      if (indexR === indexS) {\n        TRACE(' - var is same so skipping alias');\n      } else {\n        addAlias(indexR, indexS);\n      }\n\n      ml_eliminate(ml, pc, SIZEOF_CR_2);\n    } else {\n      TRACE(\n        ' - indexR !^ indexS because R=',\n        domain__debug(R),\n        ', S=',\n        domain__debug(getDomain(indexS, true)),\n        '; R may still end up with a different value from S'\n      );\n      TRACE(\n        ' - morphing to an xnor(R S);',\n        ml_getOpSizeSlow(ml, pc),\n        SIZEOF_C + 2 * 2 + 2\n      );\n      ASSERT(\n        ml_getOpSizeSlow(ml, pc) >= SIZEOF_C + 2 * 2 + 2,\n        'the current op should have at least the required space for a 2 arg xnor',\n        ml_getOpSizeSlow(ml, pc)\n      );\n      ml_cr2c2(ml, pc, argCount, ML_XNOR, indexR, indexS);\n    }\n\n    // Dont update pc\n    return true;\n  }\n\n  function innerLoop() {\n    while (pc < ml.length && !emptyDomain) {\n      ++__opCounter;\n      const op = ml[pc];\n      TRACE(' -- DD pc=' + pc + ', op: ' + ml__debug(ml, pc, 1, problem, true));\n      switch (op) {\n        case ML_IMP:\n          dedupePairOc2('->');\n          break;\n        case ML_NIMP:\n          dedupePairOc2('!->');\n          break;\n\n        case ML_ISLT:\n          dedupeIsltIslte('<?');\n          break;\n        case ML_ISLTE:\n          dedupeIsltIslte('<=?');\n          break;\n\n        case ML_ISALL:\n          dedupeBoolyList('isall');\n          break;\n        case ML_ISDIFF:\n          if (!dedupeInvIsSameIsDiff('isdiff')) dedupeBoolyList('isdiff');\n          break;\n        case ML_ISNALL:\n          dedupeBoolyList('isnall');\n          break;\n        case ML_ISNONE:\n          dedupeBoolyList('isnone');\n          break;\n        case ML_ISSAME:\n          if (!dedupeInvIsSameIsDiff('issame')) dedupeBoolyList('issame');\n          break;\n        case ML_ISSOME:\n          dedupeBoolyList('issome');\n          break;\n\n        case ML_ALL:\n          dedupeVoidList('all');\n          break;\n        case ML_DIFF:\n          dedupeVoidList('diff');\n          break;\n        case ML_LT:\n          dedupePairOc2('<');\n          break;\n        case ML_LTE:\n          dedupePairOc2('<=');\n          break;\n        case ML_NALL:\n          dedupeVoidList('nall');\n          break;\n        case ML_NONE:\n          dedupeVoidList('none');\n          break;\n        case ML_SAME:\n          dedupeVoidList('same');\n          break;\n        case ML_SOME:\n          dedupeVoidList('some');\n          break;\n        case ML_XNOR:\n          dedupeVoidList('xnor');\n          break;\n        case ML_XOR:\n          dedupeVoidList('^');\n          break;\n\n        case ML_MINUS:\n          dedupeTripO('-');\n          break;\n        case ML_DIV:\n          dedupeTripO('/');\n          break;\n\n        case ML_SUM:\n          dedupeNonBoolyList('sum');\n          break;\n        case ML_PRODUCT:\n          dedupeNonBoolyList('product');\n          break;\n\n        case ML_START:\n          if (pc !== 0) {\n            return ml_throw(ml, pc, 'deduper problem found START');\n          }\n\n          ++pc;\n          break;\n\n        case ML_STOP:\n          return constraintHash;\n\n        case ML_NOBOOL: // No deduping this!\n        case ML_NOLEAF: // No deduping this!\n          pc += SIZEOF_V;\n          break;\n\n        case ML_JMP:\n          pc += SIZEOF_V + ml_dec16(ml, pc + 1);\n          break;\n        case ML_JMP32:\n          pc += SIZEOF_W + ml_dec32(ml, pc + 1);\n          break;\n\n        case ML_NOOP:\n          ++pc;\n          break;\n        case ML_NOOP2:\n          pc += 2;\n          break;\n        case ML_NOOP3:\n          pc += 3;\n          break;\n        case ML_NOOP4:\n          pc += 4;\n          break;\n\n        default:\n          ml_throw(ml, pc, '(dd) unknown op');\n      }\n    }\n\n    if (!emptyDomain) ml_throw(ml, pc, '(dd) ML OOB');\n  }\n}\n\nexport { deduper };\n","// This is an import function for config\n// it converts a DSL string to a $config\n// see /docs/dsl.txt for syntax\n// see exporter.js to convert a config to this DSL\nimport { ASSERT, TRACE } from 'fdlib';\n\nimport { SUB, SUP } from 'fdlib';\n\nimport { domain_createRange } from 'fdlib';\n\nimport { getTerm } from 'fdlib';\n\nimport {\n  ML_ALL,\n  ML_NOBOOL,\n  ML_NOLEAF,\n  ML_DIFF,\n  ML_DIV,\n  ML_IMP,\n  ML_ISALL,\n  ML_ISDIFF,\n  ML_ISLT,\n  ML_ISLTE,\n  ML_ISNALL,\n  ML_ISNONE,\n  ML_ISSAME,\n  ML_ISSOME,\n  ML_JMP,\n  ML_JMP32,\n  ML_LT,\n  ML_LTE,\n  ML_MINUS,\n  ML_NALL,\n  ML_NIMP,\n  ML_NONE,\n  ML_NOOP,\n  ML_NOOP2,\n  ML_NOOP3,\n  ML_NOOP4,\n  ML_PRODUCT,\n  ML_SAME,\n  ML_SOME,\n  ML_START,\n  ML_STOP,\n  ML_SUM,\n  ML_XNOR,\n  ML_XOR,\n  SIZEOF_V,\n  SIZEOF_W,\n} from './ml';\n\n// Ords (number matching is faster, especially since we use a buffer anyways)\nconst $$AND = 38;\nconst $$AT = 64;\nconst $$BANG = 33;\nconst $$COLON = 58;\nconst $$COMMA = 44;\nconst $$CR = 10;\nconst $$LF = 13;\nconst $$DASH = 45;\nconst $$DIV = 47;\nconst $$EQ = 61;\nconst $$GT = 62;\nconst $$HASH = 35;\nconst $$LEFTBRACK = 91;\nconst $$LEFTPAREN = 40;\nconst $$LT = 60;\nconst $$OR = 124;\nconst $$PLUS = 43;\nconst $$QM = 63;\nconst $$SPACE = 32;\nconst $$RIGHTBRACK = 93;\nconst $$RIGHTPAREN = 41;\nconst $$SQUOTE = 39;\nconst $$STAR = 42;\nconst $$TAB = 9;\nconst $$XOR = 94;\nconst $$0 = 48;\nconst $$1 = 49;\nconst $$2 = 50;\nconst $$3 = 51;\nconst $$4 = 52;\nconst $$5 = 53;\nconst $$6 = 54;\nconst $$7 = 55;\nconst $$8 = 56;\nconst $$9 = 57;\nconst $$a = 97;\nconst $$c = 99;\nconst $$d = 100;\nconst $$e = 101;\nconst $$f = 102;\nconst $$g = 103;\nconst $$i = 105;\nconst $$l = 108;\nconst $$m = 109;\nconst $$n = 110;\nconst $$o = 111;\nconst $$p = 112;\nconst $$r = 114;\nconst $$s = 115;\nconst $$t = 116;\nconst $$x = 120;\nconst $$z = 122;\nconst $$A = 65;\nconst $$Z = 98;\n\n/**\n * Compile the constraint dsl to a bytecode\n *\n * @param {string} dslStr\n * @param {Object} problem\n * @param {boolean} [_debug] Improved error reporting when true\n * @returns {string}\n */\nfunction dsl2ml(dslStr, problem, _debug) {\n  TRACE('# dsl2ml:', [\n    dslStr.slice(0, 100).replace(/ +/g, ' ') +\n      (dslStr.replace(/ +/g, ' ').length > 100 ? '...' : ''),\n  ]);\n\n  problem.input.varstrat = 'default';\n  problem.input.valstrat = 'default';\n  problem.input.dsl = dslStr;\n\n  const { addVar, setDomain, name2index } = problem;\n\n  let constraints = 0;\n  let freeDirective = -1; // For `@custom free x`. this var tries to ensure exactly x bytes are \"free\"\n\n  let dslPointer = 0;\n\n  let dslBuf;\n  if (typeof Buffer === 'undefined') {\n    dslBuf = new window.TextEncoder('utf-8').encode(dslStr);\n  } else {\n    dslBuf = new Uint8Array(Buffer.from(dslStr, 'binary'));\n  }\n\n  ASSERT(dslBuf instanceof Uint8Array);\n  const len = dslBuf.length;\n\n  let mlBufSize = Math.ceil(dslBuf.length / 5); // 20% is arbitrary choice. grown dynamically when needed\n  let mlBuffer = new Uint8Array(mlBufSize).fill(0);\n  let mlPointer = 0;\n\n  // This is for a hack\n  let lastAssignmentIndex = -1;\n  let lastUnknownIndex = -1;\n\n  encode8bit(ML_START);\n\n  while (!isEof()) parseStatement();\n\n  if (freeDirective > 0) {\n    // Compile a jump of given size. this will be considered available space\n    TRACE('forcing', freeDirective, 'bytes of available space');\n    compileJump(freeDirective);\n  }\n\n  encode8bit(ML_STOP); // This step will be undone but serves to ensure the buffer isnt grown in the actual compilation step (which happens after the available-space-checks)\n  --mlPointer;\n\n  if (freeDirective < 0) {\n    // Compile a jump for the remainder of the space, if any, which could be used by the recycle mechanisms\n    // only do this here when the free directive is absent\n    const leftFree = mlBufSize - mlPointer - 1; // STOP will occupy 1 byte\n    TRACE('space available', leftFree, 'bytes');\n    if (leftFree > 0) compileJump(leftFree);\n  }\n\n  encode8bit(ML_STOP); // Put the STOP at the end\n\n  // if there is now still space left, we need to crop it because freeDirective was set and didnt consume it all\n  if (mlBufSize - mlPointer) {\n    TRACE(\n      'cropping excess available space',\n      mlBufSize,\n      mlPointer,\n      mlBufSize - mlPointer\n    );\n    // If the free directive was given, remove any excess free space\n    // note that one more byte needs to be compiled after this (ML_STOP)\n    mlBuffer.splice(mlPointer);\n  }\n\n  ASSERT(\n    mlPointer === mlBuffer.length,\n    'mlPointer should now be at the first unavailable cell of the buffer',\n    mlPointer,\n    mlBuffer.length,\n    mlBuffer\n  );\n\n  problem.ml = mlBuffer;\n  if (!problem.input.targets) problem.input.targets = 'all';\n\n  getTerm().log(\n    '# dsl2ml: parsed',\n    constraints,\n    'constraints and',\n    problem.domains.length,\n    'vars'\n  );\n\n  // ########################################################################\n\n  function startConstraint(op) {\n    ++constraints;\n    encode8bit(op);\n  }\n\n  function encode8bit(num) {\n    ASSERT(typeof num === 'number' && num >= 0 && num <= 0xff, 'OOB number');\n    TRACE(\n      'encode8bit:',\n      num,\n      'dsl pointer:',\n      dslPointer,\n      ', ml pointer:',\n      mlPointer\n    );\n\n    if (mlPointer >= mlBufSize) grow();\n\n    mlBuffer[mlPointer++] = num;\n  }\n\n  function encode16bit(num) {\n    TRACE(\n      'encode16bit:',\n      num,\n      '->',\n      num >> 8,\n      num & 0xff,\n      'dsl pointer:',\n      dslPointer,\n      ', ml pointer:',\n      mlPointer,\n      '/',\n      mlBufSize\n    );\n    ASSERT(\n      typeof num === 'number',\n      'Encoding 16bit must be num',\n      typeof num,\n      num\n    );\n    ASSERT(num >= 0, 'OOB num', num);\n    if (num > 0xffff) THROW('Need 32bit num support but missing it', num);\n\n    if (mlPointer >= mlBufSize - 1) grow();\n\n    mlBuffer[mlPointer++] = (num >> 8) & 0xff;\n    mlBuffer[mlPointer++] = num & 0xff;\n  }\n\n  function encode32bit(num) {\n    TRACE(\n      'encode32bit:',\n      num,\n      '->',\n      (num >> 24) & 0xff,\n      (num >> 16) & 0xff,\n      (num >> 8) & 0xff,\n      num & 0xff,\n      'dsl pointer:',\n      dslPointer,\n      ', ml pointer:',\n      mlPointer\n    );\n    ASSERT(\n      typeof num === 'number',\n      'Encoding 32bit must be num',\n      typeof num,\n      num\n    );\n    ASSERT(num >= 0, 'OOB num', num);\n    if (num > 0xffffffff) THROW('This requires 64bit support', num);\n\n    if (mlPointer >= mlBufSize - 3) grow();\n\n    mlBuffer[mlPointer++] = (num >> 24) & 0xff;\n    mlBuffer[mlPointer++] = (num >> 16) & 0xff;\n    mlBuffer[mlPointer++] = (num >> 8) & 0xff;\n    mlBuffer[mlPointer++] = num & 0xff;\n  }\n\n  function grow(forcedExtraSpace) {\n    TRACE(' - grow(' + (forcedExtraSpace || '') + ') from', mlBufSize);\n    // grow the buffer by 10% or `forcedExtraSpace`\n    // you can't really grow existing buffers, instead you create a bigger buffer and copy the old one into it...\n    const oldSize = mlBufSize;\n    if (forcedExtraSpace) mlBufSize += forcedExtraSpace;\n    else mlBufSize += Math.max(Math.ceil(mlBufSize * 0.1), 10);\n    ASSERT(\n      mlBufSize > mlBuffer.length,\n      'grow() should grow() at least a bit...',\n      mlBuffer.length,\n      '->',\n      mlBufSize\n    );\n\n    if (typeof Buffer === 'undefined') {\n      if (ArrayBuffer.transfer)\n        mlBuffer = new Uint8Array(\n          ArrayBuffer.transfer(mlBuffer.buffer, mlBufSize)\n        );\n      else\n        mlBuffer = new Uint8Array(\n          ArrayBufferTransferPoly(mlBuffer.buffer, mlBufSize)\n        );\n    } else {\n      mlBuffer = new Uint8Array(Buffer.concat([mlBuffer], mlBufSize)); // Wont actually concat, but will copy the existing buffer into a buffer of given size\n      mlBuffer.fill(0, oldSize);\n    }\n\n    ASSERT(mlBuffer instanceof Uint8Array);\n  }\n\n  function read() {\n    return dslBuf[dslPointer];\n  }\n\n  function readD(delta) {\n    return dslBuf[dslPointer + delta];\n  }\n\n  function substr_expensive(start, stop) {\n    // Use sparingly!\n    return String.fromCharCode(...dslBuf.slice(start, stop));\n  }\n\n  function skip() {\n    ++dslPointer;\n  }\n\n  function is(c, desc) {\n    if (!desc) desc = '';\n    if (read() !== c)\n      THROW('Expected ' + desc + ' `' + c + '`, found `' + read() + '`');\n    skip();\n  }\n\n  function skipWhitespaces() {\n    while (dslPointer < len && isWhitespace(read())) skip();\n  }\n\n  function skipWhites() {\n    while (!isEof()) {\n      const c = read();\n      if (isWhite(c)) {\n        skip();\n      } else if (isComment(c)) {\n        skipComment();\n      } else {\n        break;\n      }\n    }\n  }\n\n  function isWhitespace(s) {\n    // Make sure you dont actually want isNewlineChar()\n    return s === $$SPACE || s === $$TAB;\n  }\n\n  function isNewlineChar(s) {\n    return s === $$CR || s === $$LF;\n  }\n\n  function atEol(c) {\n    return isNewlineChar(c) || isComment(c) || isEof();\n  }\n\n  function isLineEnd(s) {\n    // The line ends at a newline or a comment\n    return s === $$CR || s === $$LF || s === $$HASH;\n  }\n\n  function isComment(s) {\n    return s === $$HASH;\n  }\n\n  function isWhite(s) {\n    return isWhitespace(s) || isNewlineChar(s);\n  }\n\n  function expectEol() {\n    skipWhitespaces();\n    if (dslPointer < len) {\n      const c = read();\n      if (c === $$HASH) {\n        skipComment();\n      } else if (isNewlineChar(c)) {\n        skip();\n      } else {\n        THROW('Expected EOL but got `' + read() + '`');\n      }\n    }\n  }\n\n  function isEof() {\n    return dslPointer >= len;\n  }\n\n  function parseStatement() {\n    // Either:\n    // - start with colon: var decl\n    // - start with hash: line comment\n    // - empty: empty\n    // - otherwise: constraint\n\n    skipWhites();\n\n    ASSERT(read() !== $$HASH, 'comments should be parsed by skipWhites');\n    switch (read()) {\n      case $$COLON:\n        parseVar();\n        return;\n      case $$AT:\n        parseAtRule();\n        return;\n      default:\n        if (!isEof()) {\n          parseVoidConstraint();\n        }\n    }\n  }\n\n  function parseVar() {\n    skip(); // Already is($$COLON)\n    skipWhitespaces();\n    let nameNames = parseIdentifier();\n    skipWhitespaces();\n    if (read() === $$COMMA) {\n      nameNames = [nameNames];\n      do {\n        skip();\n        skipWhitespaces();\n        nameNames.push(parseIdentifier());\n        skipWhitespaces();\n      } while (!isEof() && read() === $$COMMA);\n    }\n\n    if (read() === $$EQ) {\n      skip();\n      skipWhitespaces();\n    }\n\n    const domain = parseDomain();\n    skipWhitespaces();\n    const mod = parseModifier();\n    expectEol();\n\n    if (typeof nameNames === 'string') {\n      addParsedVar(nameNames, domain, mod);\n    } else {\n      nameNames.forEach(name => addParsedVar(name, domain, mod));\n    }\n  }\n\n  function addParsedVar(name, domain, mod) {\n    return addVar(name, domain, mod, false, true, THROW);\n  }\n\n  function parseIdentifier() {\n    if (read() === $$SQUOTE) return parseQuotedIdentifier();\n    return parseUnquotedIdentifier();\n  }\n\n  function parseQuotedIdentifier() {\n    is($$SQUOTE);\n\n    let ident = '';\n    while (!isEof()) {\n      const c = read();\n      if (c === $$SQUOTE) break;\n      if (c !== $$HASH && isLineEnd(c))\n        THROW('Quoted identifier wasnt closed at eol');\n      ident += String.fromCharCode(c);\n      skip();\n    }\n\n    if (isEof()) THROW('Quoted identifier wasnt closed at eof');\n    if (!ident) THROW('Expected to parse identifier, found none');\n    skip(); // Quote\n    return ident; // Return unquoted ident\n  }\n\n  function parseUnquotedIdentifier() {\n    // Anything terminated by whitespace\n    let c = read();\n    let ident = '';\n    if (c >= $$0 && c <= $$9) THROW('Unquoted ident cant start with number');\n    while (!isEof()) {\n      c = read();\n      if (!isValidUnquotedIdentChar(c)) break;\n      ident += String.fromCharCode(c);\n      skip();\n    }\n\n    if (!ident) THROW('Expected to parse identifier, found none');\n    return ident;\n  }\n\n  function isValidUnquotedIdentChar(c) {\n    switch (c) {\n      case $$LEFTPAREN:\n      case $$RIGHTPAREN:\n      case $$COMMA:\n      case $$LEFTBRACK:\n      case $$RIGHTBRACK:\n      case $$SQUOTE:\n      case $$HASH:\n        return false;\n    }\n\n    if (isWhite(c)) return false;\n    return true;\n  }\n\n  function parseDomain() {\n    // []\n    // [lo hi]\n    // [[lo hi] [lo hi] ..]\n    // *\n    // 25\n    // (comma's optional and ignored)\n\n    let domain;\n    const c = read();\n    switch (c) {\n      case $$LEFTBRACK:\n        is($$LEFTBRACK, 'domain start');\n        skipWhitespaces();\n\n        domain = [];\n\n        if (read() === $$LEFTBRACK) {\n          // Range inside the domain that is wrapped in brakcets\n          do {\n            skip();\n            skipWhitespaces();\n            const lo = parseNumber();\n            skipWhitespaces();\n            if (read() === $$COMMA) {\n              skip();\n              skipWhitespaces();\n            }\n\n            const hi = parseNumber();\n            skipWhitespaces();\n            is($$RIGHTBRACK, 'range-end');\n            skipWhitespaces();\n\n            domain.push(lo, hi);\n\n            if (read() === $$COMMA) {\n              skip();\n              skipWhitespaces();\n            }\n          } while (read() === $$LEFTBRACK);\n        } else {\n          // Individual ranges not wrapped\n          while (read() !== $$RIGHTBRACK) {\n            skipWhitespaces();\n            const lo = parseNumber();\n            skipWhitespaces();\n            if (read() === $$COMMA) {\n              skip();\n              skipWhitespaces();\n            }\n\n            const hi = parseNumber();\n            skipWhitespaces();\n\n            domain.push(lo, hi);\n\n            if (read() === $$COMMA) {\n              skip();\n              skipWhitespaces();\n            }\n          }\n        }\n\n        is($$RIGHTBRACK, 'domain-end');\n        if (domain.length === 0)\n          THROW('Empty domain [] in dsl, this problem will always reject');\n        return domain;\n\n      case $$STAR:\n        skip();\n        return [SUB, SUP];\n\n      case $$0:\n      case $$1:\n      case $$2:\n      case $$3:\n      case $$4:\n      case $$5:\n      case $$6:\n      case $$7:\n      case $$8:\n      case $$9:\n        const v = parseNumber();\n        skipWhitespaces();\n        return [v, v];\n    }\n\n    THROW('Expecting valid domain start, found `' + c + '`');\n  }\n\n  function parseModifier() {\n    if (read() !== $$AT) return;\n    skip();\n\n    const mod = {};\n\n    let stratName = '';\n    while (true) {\n      const c = read();\n      if (!((c >= $$a && c <= $$z) || (c >= $$A && c <= $$Z))) break;\n      stratName += String.fromCharCode(c);\n      skip();\n    }\n\n    switch (stratName) {\n      case 'list':\n        parseList(mod);\n        break;\n\n      case 'markov':\n        parseMarkov(mod);\n        break;\n\n      case 'max':\n      case 'mid':\n      case 'min':\n      case 'naive':\n        mod.valtype = stratName;\n        break;\n\n      case 'minMaxCycle':\n      case 'splitMax':\n      case 'splitMin':\n        THROW('TODO: implement this modifier [' + stratName + ']');\n        break;\n      default:\n        THROW('implement me (var mod) [`' + stratName + '`]');\n    }\n\n    mod.valtype = stratName;\n\n    return mod;\n  }\n\n  function parseList(mod) {\n    skipWhitespaces();\n\n    if (\n      !(\n        readD(0) === $$p &&\n        readD(1) === $$r &&\n        readD(2) === $$i &&\n        readD(3) === $$o &&\n        readD(4) === $$LEFTPAREN\n      )\n    ) {\n      THROW('Expecting the priorities to follow the `@list`');\n    }\n\n    dslPointer += 5;\n    mod.valtype = 'list';\n    mod.list = parseNumList();\n\n    is($$RIGHTPAREN, 'list end');\n  }\n\n  function parseMarkov(mod) {\n    mod.valtype = 'markov';\n    let repeat = true;\n    while (repeat) {\n      repeat = false;\n      skipWhitespaces();\n      switch (read()) {\n        case $$m: // Matrix\n          if (\n            readD(1) === $$a &&\n            readD(2) === $$t &&\n            readD(3) === $$r &&\n            readD(4) === $$i &&\n            readD(5) === $$x &&\n            readD(6) === $$LEFTPAREN\n          ) {\n            // TOFIX: there is no validation here. apply stricter and safe matrix parsing\n\n            dslPointer += 7;\n            const start = dslPointer;\n            while (read() !== $$RIGHTPAREN && !isEof()) skip();\n            if (isEof())\n              THROW('The matrix must be closed by a `)` but did not find any');\n            ASSERT(\n              read() === $$RIGHTPAREN,\n              'code should only stop at eof or )'\n            );\n\n            const matrix = substr_expensive(start, dslPointer);\n            const code = 'return ' + matrix;\n            const func = new Function(code);\n            /* eslint no-new-func: \"off\" */\n            mod.matrix = func();\n\n            is($$RIGHTPAREN, 'end of matrix'); // Kind of a redundant double check. could also just skip() here.\n\n            repeat = true;\n          }\n\n          break;\n\n        case $$l: // Legend\n          if (\n            readD(1) === $$e &&\n            readD(2) === $$g &&\n            readD(3) === $$e &&\n            readD(4) === $$n &&\n            readD(5) === $$d &&\n            readD(6) === $$LEFTPAREN\n          ) {\n            dslPointer += 7;\n            skipWhitespaces();\n            mod.legend = parseNumList();\n            skipWhitespaces();\n            is($$RIGHTPAREN, 'legend closer');\n\n            repeat = true;\n          }\n\n          break;\n\n        case $$e: // Expand\n          if (\n            readD(1) === $$x &&\n            readD(2) === $$p &&\n            readD(3) === $$a &&\n            readD(4) === $$n &&\n            readD(5) === $$d &&\n            readD(6) === $$LEFTPAREN\n          ) {\n            dslPointer += 7;\n            skipWhitespaces();\n            mod.expandVectorsWith = parseNumber();\n            skipWhitespaces();\n            is($$RIGHTPAREN, 'expand closer');\n\n            repeat = true;\n          }\n\n          break;\n      }\n    }\n  }\n\n  function skipComment() {\n    is($$HASH, 'comment start'); // is('#', 'comment hash');\n    while (!isEof() && !isNewlineChar(read())) skip();\n    if (!isEof()) skip();\n  }\n\n  function parseVoidConstraint() {\n    // Parse a constraint that does not return a value itself\n\n    // first try to parse single value constraints without value like markov() and diff()\n    if (parseUexpr()) return;\n\n    // So the first value must be a value returning expr\n    parseComplexVoidConstraint();\n\n    expectEol();\n  }\n\n  function parseComplexVoidConstraint() {\n    // Parse a constraint that at least starts with a Vexpr but ultimately doesnt return anything\n\n    const indexA = parseVexpr(undefined, true);\n\n    skipWhitespaces();\n    // `A==B<eof>` then A==B would be part of A and the parser would want to parse a cop here. there's a test case.\n    if (isEof()) THROW('Expected to parse a cop but reached eof instead');\n\n    const cop = parseCop();\n    skipWhitespaces();\n\n    if (cop === '=') {\n      lastAssignmentIndex = indexA;\n      parseAssignment(indexA);\n    } else {\n      ASSERT(cop, 'the cop parser should require to parse a valid cop');\n      const indexB = parseVexpr();\n      compileVoidConstraint(indexA, cop, indexB);\n    }\n  }\n\n  function compileVoidConstraint(indexA, cop, indexB) {\n    switch (cop) {\n      case '==':\n        startConstraint(ML_SAME);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        break;\n\n      case '!=':\n        startConstraint(ML_DIFF);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        break;\n\n      case '<':\n        startConstraint(ML_LT);\n        encode16bit(2);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        break;\n\n      case '<=':\n        startConstraint(ML_LTE);\n        encode16bit(2);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        break;\n\n      case '>':\n        startConstraint(ML_LT);\n        encode16bit(2);\n        encode16bit(indexB);\n        encode16bit(indexA);\n        break;\n\n      case '>=':\n        startConstraint(ML_LTE);\n        encode16bit(2);\n        encode16bit(indexB);\n        encode16bit(indexA);\n        break;\n\n      case '&':\n        startConstraint(ML_ALL);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        break;\n\n      case '!&':\n        startConstraint(ML_NALL);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        break;\n\n      case '|':\n        startConstraint(ML_SOME);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        break;\n\n      case '!|':\n        startConstraint(ML_NONE);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        break;\n\n      case '^':\n        startConstraint(ML_XOR);\n        encode16bit(2); // This brings the op size in line with all other ops. kind of a waste but so be it.\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        break;\n\n      case '!^':\n        startConstraint(ML_XNOR);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        break;\n\n      case '->':\n        startConstraint(ML_IMP);\n        encode16bit(2);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        break;\n\n      case '!->':\n        startConstraint(ML_NIMP);\n        encode16bit(2);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        break;\n\n      default:\n        THROW('Unknown constraint op: [' + cop + ']');\n    }\n  }\n\n  function parseAssignment(indexC) {\n    const indexA = parseVexpr(indexC);\n    skipWhitespaces();\n    const c = read();\n    if (isEof() || isLineEnd(c)) {\n      // Any var, literal, or group without \"top-level\" op (`A=5`, `A=X`, `A=(B+C)`, `A=sum(...)`, etc)\n      if (indexA !== indexC) {\n        compileVoidConstraint(indexA, '==', indexC);\n      }\n    } else {\n      const rop = parseRop();\n      if (!rop) THROW('Expecting right paren or rop, got [' + rop + ']');\n      skipWhitespaces();\n      const indexB = parseVexpr();\n      return compileValueConstraint(indexA, rop, indexB, indexC);\n    }\n  }\n\n  function compileValueConstraint(indexA, rop, indexB, indexC) {\n    let wasReifier = false;\n\n    switch (rop) {\n      case '==?':\n        startConstraint(ML_ISSAME);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        encode16bit(indexC);\n        wasReifier = true;\n        break;\n\n      case '!=?':\n        startConstraint(ML_ISDIFF);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        encode16bit(indexC);\n        wasReifier = true;\n        break;\n\n      case '<?':\n        startConstraint(ML_ISLT);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        encode16bit(indexC);\n        wasReifier = true;\n        break;\n\n      case '<=?':\n        startConstraint(ML_ISLTE);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        encode16bit(indexC);\n        wasReifier = true;\n        break;\n\n      case '&?':\n        startConstraint(ML_ISALL);\n        encode16bit(2);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        encode16bit(indexC);\n        break;\n\n      case '!&?':\n        startConstraint(ML_ISNALL);\n        encode16bit(2);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        encode16bit(indexC);\n        break;\n\n      case '|?':\n        startConstraint(ML_ISSOME);\n        encode16bit(2);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        encode16bit(indexC);\n        break;\n\n      case '!|?':\n        startConstraint(ML_ISNONE);\n        encode16bit(2);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        encode16bit(indexC);\n        break;\n\n      case '+':\n        startConstraint(ML_SUM);\n        encode16bit(2); // Count\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        encode16bit(indexC);\n        break;\n\n      case '-':\n        startConstraint(ML_MINUS);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        encode16bit(indexC);\n        break;\n\n      case '*':\n        startConstraint(ML_PRODUCT);\n        encode16bit(2);\n        encode16bit(indexA < indexB ? indexA : indexB);\n        encode16bit(indexA < indexB ? indexB : indexA);\n        encode16bit(indexC);\n        break;\n\n      case '/':\n        startConstraint(ML_DIV);\n        encode16bit(indexA);\n        encode16bit(indexB);\n        encode16bit(indexC);\n        break;\n\n      case '>?':\n        return compileValueConstraint(indexB, '<?', indexA, indexC);\n\n      case '>=?':\n        return compileValueConstraint(indexB, '<=?', indexA, indexC);\n\n      default:\n        THROW('Expecting right paren or rop, got [' + rop + ']');\n    }\n\n    if (\n      wasReifier &&\n      indexC === lastAssignmentIndex &&\n      indexC === lastUnknownIndex\n    )\n      setDomain(indexC, domain_createRange(0, 1));\n\n    return indexC;\n  }\n\n  function parseCop() {\n    const c = read();\n    switch (c) {\n      case $$EQ:\n        skip();\n        if (read() === $$EQ) {\n          skip();\n          return '==';\n        }\n\n        return '=';\n      case $$BANG:\n        skip();\n        const r = read();\n        if (r === $$EQ) {\n          skip();\n          return '!=';\n        }\n\n        if (r === $$AND) {\n          skip();\n          return '!&';\n        }\n\n        if (r === $$XOR) {\n          skip();\n          return '!^';\n        }\n\n        if (r === $$OR) {\n          skip();\n          return '!|';\n        }\n\n        if (r === $$DASH && readD(1) === $$GT) {\n          skip();\n          skip();\n          return '!->';\n        }\n\n        return THROW('Unknown cop that starts with [!]');\n      case $$LT:\n        skip();\n        if (read() === $$EQ) {\n          skip();\n          return '<=';\n        }\n\n        return '<';\n      case $$GT:\n        skip();\n        if (read() === $$EQ) {\n          skip();\n          return '>=';\n        }\n\n        return '>';\n      case $$DASH:\n        if (readD(1) === $$GT) {\n          skip();\n          skip();\n          return '->';\n        }\n\n        break; // Error\n      case $$AND:\n        skip();\n        return '&';\n      case $$OR:\n        skip();\n        return '|';\n      case $$XOR:\n        skip();\n        return '^';\n      case $$HASH:\n        return THROW('Expected to parse a cop but found a comment instead');\n    }\n\n    if (isEof()) THROW('Expected to parse a cop but reached eof instead');\n    THROW('Unknown cop char: `' + c + '`');\n  }\n\n  function parseRop() {\n    switch (read()) {\n      case $$EQ:\n        skip();\n        if (read() === $$EQ) {\n          skip();\n          is($$QM, 'reifier suffix');\n          return '==?';\n        }\n\n        return '=';\n\n      case $$BANG:\n        skip();\n        let r = '';\n        if (read() === $$EQ) {\n          is($$EQ, 'middle part of !=? op');\n          r = '!=?';\n        } else if (read() === $$AND) {\n          is($$AND, 'middle part of !&? op');\n          r = '!&?';\n        } else if (read() === $$OR) {\n          is($$OR, 'middle part of !|? op');\n          r = '!|?';\n        } else {\n          THROW('invalid rop that starts with a bang');\n        }\n\n        is($$QM, 'reifier suffix');\n        return r;\n\n      case $$LT:\n        skip();\n        if (read() === $$EQ) {\n          skip();\n          is($$QM, 'reifier suffix');\n          return '<=?';\n        }\n\n        is($$QM, 'reifier suffix');\n        return '<?';\n\n      case $$GT:\n        skip();\n        if (read() === $$EQ) {\n          skip();\n          is($$QM, 'reifier suffix');\n          return '>=?';\n        }\n\n        is($$QM, 'reifier suffix');\n        return '>?';\n\n      case $$OR:\n        skip();\n        is($$QM, 'issome suffix');\n        return '|?';\n\n      case $$AND:\n        skip();\n        is($$QM, 'isall suffix');\n        return '&?';\n\n      case $$PLUS:\n        skip();\n        return '+';\n\n      case $$DASH:\n        skip();\n        return '-';\n\n      case $$STAR:\n        skip();\n        return '*';\n\n      case $$DIV:\n        skip();\n        return '/';\n\n      default:\n        return '';\n    }\n  }\n\n  function parseUexpr() {\n    // It's not very efficient (we could parse an ident before and check that result here) but it'll work for now\n\n    const c = read();\n\n    // Distinct is legacy support, same as diff()\n    if (\n      c === $$d &&\n      readD(1) === $$i &&\n      readD(2) === $$s &&\n      readD(3) === $$t &&\n      readD(4) === $$i &&\n      readD(5) === $$n &&\n      readD(6) === $$c &&\n      readD(7) === $$t &&\n      readD(8) === $$LEFTPAREN\n    ) {\n      parseCalledListConstraint(ML_DIFF, 9);\n      return true;\n    }\n\n    if (\n      c === $$d &&\n      readD(1) === $$i &&\n      readD(2) === $$f &&\n      readD(3) === $$f &&\n      readD(4) === $$LEFTPAREN\n    ) {\n      parseCalledListConstraint(ML_DIFF, 5);\n      return true;\n    }\n\n    if (\n      c === $$a &&\n      readD(1) === $$l &&\n      readD(2) === $$l &&\n      readD(3) === $$LEFTPAREN\n    ) {\n      parseCalledListConstraint(ML_ALL, 4);\n      return true;\n    }\n\n    if (\n      c === $$n &&\n      readD(1) === $$a &&\n      readD(2) === $$l &&\n      readD(3) === $$l &&\n      readD(4) === $$LEFTPAREN\n    ) {\n      parseCalledListConstraint(ML_NALL, 5);\n      return true;\n    }\n\n    if (\n      c === $$s &&\n      readD(1) === $$a &&\n      readD(2) === $$m &&\n      readD(3) === $$e &&\n      readD(4) === $$LEFTPAREN\n    ) {\n      parseCalledListConstraint(ML_SAME, 5);\n      return true;\n    }\n\n    if (\n      c === $$s &&\n      readD(1) === $$o &&\n      readD(2) === $$m &&\n      readD(3) === $$e &&\n      readD(4) === $$LEFTPAREN\n    ) {\n      parseCalledListConstraint(ML_SOME, 5);\n      return true;\n    }\n\n    if (\n      c === $$n &&\n      readD(1) === $$o &&\n      readD(2) === $$n &&\n      readD(3) === $$e &&\n      readD(4) === $$LEFTPAREN\n    ) {\n      parseCalledListConstraint(ML_NONE, 5);\n      return true;\n    }\n\n    if (\n      c === $$x &&\n      readD(1) === $$n &&\n      readD(2) === $$o &&\n      readD(3) === $$r &&\n      readD(4) === $$LEFTPAREN\n    ) {\n      parseCalledListConstraint(ML_XNOR, 5);\n      return true;\n    }\n\n    return false;\n  }\n\n  function parseCalledListConstraint(opcode, delta) {\n    dslPointer += delta;\n    skipWhitespaces();\n    const vals = parseVexpList();\n    ASSERT(vals.length <= 255, 'dont do lists with more than 255 vars :(');\n    startConstraint(opcode);\n    encode16bit(vals.length);\n    vals.forEach(encode16bit);\n    skipWhitespaces();\n    is($$RIGHTPAREN, 'parseCalledListConstraint call closer');\n    expectEol();\n  }\n\n  function parseVexpList() {\n    const list = [];\n    skipWhitespaces();\n    while (!isEof() && read() !== $$RIGHTPAREN) {\n      const index = parseVexpr();\n      list.push(index);\n\n      skipWhitespaces();\n      if (read() === $$COMMA) {\n        skip();\n        skipWhitespaces();\n      }\n    }\n\n    if (!list.length) THROW('Expecting at least one expression in the list');\n    return list;\n  }\n\n  function parseVexpr(resultIndex, canBeUnknown) {\n    // Types: valcall, ident, number, group\n    // ALWAYS return a var or constant INDEX!\n\n    // resultIndex is only passed on if this was an explicit\n    // assignment (like the index of `X` in `X = sum(A B C)`)\n\n    const c = read();\n    let index;\n    if (c >= $$0 && c <= $$9) {\n      const num = parseNumber();\n      index = addVar(undefined, num, false, false, true);\n    } else if (c === $$LEFTPAREN) {\n      index = parseGrouping();\n    } else if (c === $$LEFTBRACK) {\n      const domain = parseDomain();\n      index = addVar(undefined, domain, false, false, true);\n    } else {\n      const ident = parseIdentifier();\n\n      if (read() === $$LEFTPAREN) {\n        if (ident === 'sum') index = parseArgs(ML_SUM, resultIndex, false);\n        else if (ident === 'product')\n          index = parseArgs(ML_PRODUCT, resultIndex, false);\n        else if (ident === 'all?')\n          index = parseArgs(ML_ISALL, resultIndex, true);\n        else if (ident === 'diff?')\n          index = parseArgs(ML_ISDIFF, resultIndex, true);\n        else if (ident === 'nall?')\n          index = parseArgs(ML_ISNALL, resultIndex, true);\n        else if (ident === 'none?')\n          index = parseArgs(ML_ISNONE, resultIndex, true);\n        else if (ident === 'same?')\n          index = parseArgs(ML_ISSAME, resultIndex, true);\n        else if (ident === 'some?')\n          index = parseArgs(ML_ISSOME, resultIndex, true);\n        else THROW('Unknown reifier constraint func: ' + ident);\n      } else {\n        // Implicitly declare unknown vars as [SUB,SUP]\n        index = name2index(ident, false, true);\n        if (index < 0) {\n          if (canBeUnknown)\n            lastUnknownIndex = index = addVar(\n              ident,\n              undefined,\n              false,\n              false,\n              true\n            );\n          else\n            THROW(\n              'CONSTRAINT_VARS_SHOULD_BE_DECLARED; Unknown var [' + ident + ']'\n            );\n        }\n      }\n    }\n\n    TRACE('parseVexpr resulted in index:', index);\n\n    return index;\n  }\n\n  function parseGrouping() {\n    is($$LEFTPAREN, 'group open');\n    skipWhitespaces();\n    let indexA = parseVexpr();\n    skipWhitespaces();\n\n    // Just wrapping a vexpr is okay, otherwise it needs a rop\n    if (read() !== $$RIGHTPAREN) {\n      const rop = parseRop();\n      if (!rop) THROW('Expecting right paren or rop');\n      skipWhitespaces();\n      const indexB = parseVexpr();\n      const indexC = addVar(\n        undefined,\n        rop[rop.length - 1] === '?' ? [0, 1] : undefined,\n        false,\n        false,\n        true\n      );\n      indexA = compileValueConstraint(indexA, rop, indexB, indexC);\n      skipWhitespaces();\n    }\n\n    is($$RIGHTPAREN, 'group closer');\n    return indexA;\n  }\n\n  function parseNumber() {\n    const numstr = parseNumstr();\n    if (!numstr) {\n      THROW(\n        'Expecting to parse a number but did not find any digits c=[ord(' +\n          read() +\n          ')=' +\n          String.fromCharCode(read()) +\n          ']'\n      );\n    }\n\n    return parseInt(numstr, 10);\n  }\n\n  function parseArgs(op, resultIndex, defaultBoolResult) {\n    is($$LEFTPAREN, 'args call opener');\n    skipWhitespaces();\n    const refs = parseVexpList();\n\n    // Note: the var may not declared if the constraint was anonymously grouped (ie `(sum(A B)>10)`)\n    if (resultIndex === undefined)\n      resultIndex = addVar(\n        undefined,\n        defaultBoolResult ? [0, 1] : undefined,\n        false,\n        false,\n        true\n      );\n    else if (\n      resultIndex === lastAssignmentIndex &&\n      resultIndex === lastUnknownIndex &&\n      defaultBoolResult\n    )\n      setDomain(resultIndex, domain_createRange(0, 1));\n\n    TRACE(\n      'parseArgs refs:',\n      resultIndex,\n      ' = all(',\n      refs,\n      '), defaultBoolResult:',\n      defaultBoolResult\n    );\n\n    startConstraint(op);\n    encode16bit(refs.length); // Count\n    refs.sort((a, b) => a - b);\n    refs.forEach(encode16bit);\n    encode16bit(resultIndex);\n\n    skipWhitespaces();\n    is($$RIGHTPAREN, 'args closer');\n    return resultIndex;\n  }\n\n  function parseNumstr() {\n    let numstr = '';\n    while (!isEof()) {\n      const c = read();\n      if (c < $$0 || c > $$9) break;\n      numstr += String.fromCharCode(c);\n      skip();\n    }\n\n    return numstr;\n  }\n\n  function parseNumList() {\n    const nums = [];\n\n    skipWhitespaces();\n    let numstr = parseNumstr();\n    while (numstr) {\n      nums.push(parseInt(numstr, 10));\n      skipWhitespaces();\n      if (read() === $$COMMA) {\n        ++dslPointer;\n        skipWhitespaces();\n      }\n\n      numstr = parseNumstr();\n    }\n\n    if (!nums.length)\n      THROW('Expected to parse a list of at least some numbers but found none');\n    return nums;\n  }\n\n  function parseIdentsTo(target) {\n    const idents = parseIdents(target);\n    if (!idents.length)\n      THROW(\n        'Expected to parse a list of at least some identifiers but found none'\n      );\n    return idents;\n  }\n\n  function parseIdents(target) {\n    const idents = [];\n\n    skipWhitespaces();\n    while (!isEof()) {\n      let c = read();\n      if (c === target) return idents;\n      if (isLineEnd(c)) break;\n\n      if (c === $$COMMA) {\n        if (!idents.length) THROW('Leading comma not supported');\n        skip();\n        skipWhitespaces();\n        if (atEol(read())) THROW('Trailing comma not supported'); // Mmmm or should we? dont believe it to be relevant for this language\n        c = read();\n        if (c === $$COMMA) THROW('Double comma not supported');\n      }\n\n      const ident = parseIdentifier();\n      idents.push(ident);\n\n      skipWhitespaces();\n    }\n\n    if (target === undefined) return idents;\n    THROW('Missing target char at eol/eof');\n  }\n\n  function readLineRest() {\n    let str = '';\n    while (!isEof()) {\n      const c = read();\n      if (isNewlineChar(c)) break;\n      str += String.fromCharCode(c);\n      skip();\n    }\n\n    return str;\n  }\n\n  function parseAtRule() {\n    is($$AT);\n    // Mostly temporary hacks while the dsl stabilizes...\n\n    const ruleName = parseIdentifier();\n\n    if (ruleName === 'custom') {\n      skipWhitespaces();\n      const ident = parseIdentifier();\n      skipWhitespaces();\n      if (read() === $$EQ) {\n        skip();\n        skipWhitespaces();\n      }\n\n      switch (ident) {\n        case 'var-strat':\n          parseVarStrat();\n          break;\n        case 'val-strat':\n          parseValStrat();\n          break;\n        case 'set-valdist':\n          skipWhitespaces();\n          const target = parseIdentifier();\n          const config = parseRestCustom();\n          setValDist(name2index(target, true), JSON.parse(config));\n          break;\n        case 'noleaf': {\n          skipWhitespaces();\n\n          const idents = parseIdentsTo(undefined);\n          for (let i = 0, len = idents.length; i < len; ++i) {\n            // Debug vars are never considered leaf vars until we change that (to something else and update this to something that still does the same thing)\n            // this is for testing as a simple tool to prevent many trivial optimizations to kick in. it's not flawless.\n\n            // encode 3x to artificially inflate the count beyond most tricks\n            // these should not be deduped... but keep in mind that a noleafed alias gets double the counts\n            const index = name2index(idents[i]);\n            for (let j = 0; j < 3; ++j) {\n              encode8bit(ML_NOLEAF);\n              encode16bit(index);\n            }\n          }\n\n          break;\n        }\n\n        case 'nobool': {\n          // Debugging tool; bounty should consider this var a non-booly regardless of whether it actually is\n          skipWhitespaces();\n\n          const idents = parseIdentsTo(undefined);\n          for (let i = 0, len = idents.length; i < len; ++i) {\n            const index = name2index(idents[i]);\n            encode8bit(ML_NOBOOL);\n            encode16bit(index);\n          }\n\n          break;\n        }\n\n        case 'free':\n          skipWhitespaces();\n          const size = parseNumber();\n          TRACE('Found a jump of', size);\n          freeDirective = size;\n          break;\n\n        case 'targets':\n          parseTargets();\n          break;\n\n        default:\n          THROW('Unsupported custom rule: ' + ident);\n      }\n    } else {\n      THROW('Unknown atrule [' + ruleName + ']');\n    }\n\n    expectEol();\n  }\n\n  function setValDist(varIndex, dist) {\n    ASSERT(typeof varIndex === 'number', 'expecting var indexes');\n    ASSERT(\n      problem.valdist[varIndex] === undefined,\n      'not expecting valdists to be set twice for the same var'\n    );\n    problem.valdist[varIndex] = dist;\n  }\n\n  function compileJump(size) {\n    TRACE('compileJump(' + size + '), mlPointer=', mlPointer);\n    ASSERT(size > 0, 'dont call this function on size=0');\n    switch (size) {\n      case 0: // Dead code. test code should catch these cases at call site. runtime can still just ignore it.\n        break; // ignore. only expliclty illustrates no free space\n      case 1:\n        encode8bit(ML_NOOP);\n        break;\n      case 2:\n        encode8bit(ML_NOOP2);\n        encode8bit(0);\n        break;\n      case 3:\n        encode8bit(ML_NOOP3);\n        encode8bit(0);\n        encode8bit(0);\n        break;\n      case 4:\n        encode8bit(ML_NOOP4);\n        encode8bit(0);\n        encode8bit(0);\n        encode8bit(0);\n        break;\n      default:\n        // because we manually update mlPointer the buffer may not grow accordingly. so do that immediately\n        // but only if necessary\n        const jumpDestination = mlPointer + size;\n        if (mlBufSize <= jumpDestination) {\n          const sizeDifference = jumpDestination - mlBufSize;\n          const growAmount = (jumpDestination / 10) | 0 + sizeDifference;\n          grow(growAmount);\n        }\n\n        if (size < 0xffff) {\n          encode8bit(ML_JMP);\n          encode16bit(size - SIZEOF_V);\n          mlPointer += size - SIZEOF_V;\n        } else {\n          encode8bit(ML_JMP32);\n          encode32bit(size - SIZEOF_W);\n          mlPointer += size - SIZEOF_W;\n        }\n      // Buffer is explicitly fill(0)'d so no need to clear it out here (otherwise we probably should)\n    }\n  }\n\n  function parseVarStrat() {\n    // @custom var-strat [fallback] [=] naive\n    // @custom var-strat [fallback] [=] size\n    // @custom var-strat [fallback] [=] min\n    // @custom var-strat [fallback] [=] max\n    // @custom var-strat [fallback] [=] throw\n    // @custom var-strat [fallback] [inverted] [list] (a b c)\n\n    let fallback = false; // List only\n    let inverted = false; // List only\n    let issed = false; // Had equal sign (illegal for list)\n\n    if (read() === $$f) {\n      const ident = parseIdentifier();\n      if (ident !== 'fallback')\n        THROW('Expecting var strat name, found [' + ident + ']');\n      fallback = true;\n      skipWhitespaces();\n    }\n\n    if (read() === $$i) {\n      const ident = parseIdentifier();\n      if (ident !== 'inverted')\n        THROW('Expecting var strat name, found [' + ident + ']');\n      inverted = true;\n      skipWhitespaces();\n    }\n\n    if (read() === $$EQ) {\n      skip();\n      issed = true;\n      skipWhitespaces();\n    }\n\n    if (read() === $$LEFTPAREN) {\n      parseVarStratList(fallback, inverted);\n    } else {\n      const ident = parseIdentifier();\n\n      if (\n        ident === 'naive' ||\n        ident === 'size' ||\n        ident === 'min' ||\n        ident === 'max' ||\n        ident === 'throw'\n      ) {\n        if (inverted) THROW('The `inverted` keyword is only used with a list');\n        if (fallback) {\n          addFallbackToVarStrat(ident);\n        } else {\n          problem.input.varstrat = ident;\n        }\n      } else if (ident === 'list') {\n        skipWhitespaces();\n        if (issed) THROW('The `=` should not be used for a list');\n        if (read() !== $$LEFTPAREN) THROW('Expecting list of idents now');\n        parseVarStratList(fallback, inverted);\n      } else {\n        THROW('Unknown var strat [' + ident + ']');\n      }\n    }\n\n    skipWhitespaces();\n  }\n\n  function parseVarStratList(fallback, inverted) {\n    is($$LEFTPAREN, 'List open');\n    skipWhitespaces();\n    const idents = parseIdents($$RIGHTPAREN);\n    skipWhitespaces();\n    is($$RIGHTPAREN, 'List must be closed');\n\n    const strat = { type: 'list', inverted, priorityByName: idents };\n    if (fallback) {\n      addFallbackToVarStrat(strat);\n    } else {\n      problem.input.varstrat = strat;\n    }\n  }\n\n  function addFallbackToVarStrat(strat) {\n    let vs = problem.input.varstrat;\n    ASSERT(vs, 'should set the var strat before declaring its backup'); // Should we just throw for this?\n    if (typeof vs === 'string') vs = problem.input.varstrat = { type: vs };\n\n    while (vs.fallback) {\n      if (typeof vs.fallback === 'string') {\n        vs = vs.fallback = { type: vs.fallback };\n      } else {\n        vs = vs.fallback;\n      }\n    }\n\n    vs.fallback = strat;\n  }\n\n  function parseValStrat() {\n    problem.input.valstrat = parseIdentifier();\n  }\n\n  function parseRestCustom() {\n    skipWhitespaces();\n    if (read() === $$EQ) {\n      skip();\n      skipWhitespaces();\n    }\n\n    return readLineRest();\n  }\n\n  function parseTargets() {\n    skipWhitespaces();\n    if (read() === $$EQ) THROW('Unexpected double eq sign');\n\n    if (read() === $$a && readD(1) === $$l && readD(2) === $$l) {\n      dslPointer += 3;\n    } else {\n      is(\n        $$LEFTPAREN,\n        'ONLY_USE_WITH_SOME_TARGET_VARS; The @targets left-paren'\n      );\n      const list = parseIdentsTo($$RIGHTPAREN);\n      problem.freezeTargets(list);\n      is($$RIGHTPAREN, 'The @targets right-paren');\n    }\n\n    expectEol();\n  }\n\n  function THROW(msg) {\n    if (_debug) {\n      TRACE(\n        String.fromCharCode(...dslBuf.slice(0, dslPointer)) +\n          '##|PARSER_IS_HERE[' +\n          msg +\n          ']|##' +\n          String.fromCharCode(...dslBuf.slice(dslPointer))\n      );\n    }\n\n    msg +=\n      ', source at ' +\n      dslPointer +\n      ' #|#: `' +\n      String.fromCharCode(\n        ...dslBuf.slice(Math.max(0, dslPointer - 20), dslPointer)\n      ) +\n      '#|#' +\n      String.fromCharCode(\n        ...dslBuf.slice(dslPointer, Math.min(dslBuf.length, dslPointer + 20))\n      ) +\n      '`';\n    throw new Error(msg);\n  }\n}\n\nfunction ArrayBufferTransferPoly(source, length) {\n  // C/p https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/transfer\n\n  if (!(source instanceof ArrayBuffer))\n    throw new TypeError('Source must be an instance of ArrayBuffer');\n  if (length <= source.byteLength)\n    return source.slice(0, length);\n  const sourceView = new Uint8Array(source),\n    destView = new Uint8Array(new ArrayBuffer(length));\n  destView.set(sourceView);\n  return destView.buffer;\n}\n\nexport { dsl2ml };\n","// Problem optimizer\n// take an input problem and determine whether constraints can be pruned\n// or domains cut before actually generating their propagators\n\nimport {\n  ASSERT,\n  ASSERT_NORDOM,\n  TRACE,\n  TRACE_MORPH,\n  $CHANGED,\n  $REJECTED,\n  $SOLVED,\n  $STABLE,\n  domain__debug,\n  domain_createBoolyPair,\n  domain_createEmpty,\n  domain_createValue,\n  domain_divby,\n  domain_getValue,\n  domain_hasNoZero,\n  domain_hasZero,\n  domain_intersection,\n  domain_intersectionValue,\n  domain_invMul,\n  domain_isBool,\n  domain_isBooly,\n  domain_isBoolyPair,\n  domain_isSolved,\n  domain_isZero,\n  domain_max,\n  domain_min,\n  domain_minus,\n  domain_mul,\n  domain_plus,\n  domain_removeGtUnsafe,\n  domain_removeGte,\n  domain_removeLtUnsafe,\n  domain_removeLte,\n  domain_removeValue,\n  domain_sharesNoElements,\n  domain_size,\n  THROW,\n  getTerm,\n} from 'fdlib';\n\nimport {\n  ML_ALL,\n  ML_DIFF,\n  ML_DIV,\n  ML_IMP,\n  ML_ISALL,\n  ML_ISDIFF,\n  ML_ISLT,\n  ML_ISLTE,\n  ML_ISNALL,\n  ML_ISNONE,\n  ML_ISSAME,\n  ML_ISSOME,\n  ML_JMP,\n  ML_JMP32,\n  ML_LT,\n  ML_LTE,\n  ML_MINUS,\n  ML_NALL,\n  ML_NIMP,\n  ML_NOBOOL,\n  ML_NOLEAF,\n  ML_NONE,\n  ML_NOOP,\n  ML_NOOP2,\n  ML_NOOP3,\n  ML_NOOP4,\n  ML_PRODUCT,\n  ML_SAME,\n  ML_SOME,\n  ML_START,\n  ML_STOP,\n  ML_SUM,\n  ML_XNOR,\n  ML_XOR,\n  OFFSET_C_A,\n  OFFSET_C_B,\n  // OFFSET_C_C,\n  OFFSET_C_R,\n  SIZEOF_C,\n  SIZEOF_CR_2,\n  SIZEOF_C_2,\n  SIZEOF_V,\n  SIZEOF_VVV,\n  SIZEOF_W,\n  ml__debug,\n  ml__opName,\n  ml_c2c2,\n  ml_compileJumpAndConsolidate,\n  ml_compileJumpSafe,\n  ml_cr2c2,\n  ml_cr2cr2,\n  ml_dec16,\n  ml_dec32,\n  ml_dec8,\n  ml_eliminate,\n  ml_enc16,\n  ml_enc8,\n  ml_heapSort16bitInline,\n  ml_validateSkeleton,\n  ml_vvv2c2,\n} from './ml';\n\nimport { m2d__debug } from './ml2dsl';\n\nfunction min_run(ml, problem, domains, names, firstRun, once) {\n  TRACE(\n    'min_run, loop:',\n    firstRun,\n    ', byte code:',\n    ml.length < 50 ? ml.join(' ') : '<big>'\n  );\n  TRACE(ml__debug(ml, 0, 20, problem));\n\n  // Now we can access the ml in terms of bytes, jeuj\n  const state = min_optimizeConstraints(\n    ml,\n    problem,\n    domains,\n    names,\n    firstRun,\n    once\n  );\n  if (state === $SOLVED) {\n    TRACE('minimizing solved it!', state); // All constraints have been eliminated\n  } else if (state === $REJECTED) {\n    TRACE('minimizing rejected it!', state); // An empty domain was found or a literal failed a test\n  } else {\n    TRACE('pre-optimization finished, not yet solved');\n  }\n\n  return state;\n}\n\nfunction min_optimizeConstraints(ml, problem, domains, names, firstRun, once) {\n  TRACE('min_optimizeConstraints', ml.length < 50 ? ml.join(' ') : '');\n  TRACE(\n    problem.domains.length > 100\n      ? ''\n      : '  <' +\n          problem.domains\n            .map(\n              (d, i) =>\n                i +\n                ' : ' +\n                problem.varNames[i] +\n                ' : ' +\n                domain__debug(problem.getDomain(i))\n            )\n            .join('>, <') +\n          '>'\n  );\n  TRACE(\n    'minimize sweep, ml len=',\n    ml.length,\n    ', firstRun=',\n    firstRun,\n    'once=',\n    once\n  );\n  let varChanged = true;\n  let onlyJumps = false;\n  let emptyDomain = false;\n  let lastPcOffset = 0;\n  let lastOp = 0;\n  let pc = 0;\n  let loops = 0;\n  let constraints = 0; // Count a constraint going forward, ignore jumps, reduce when restarting from same pc\n  let restartedRelevantOp = false; // Annoying, but restartedRelevantOp could mean more scrubbing is required. but it may not...\n\n  const term = getTerm();\n\n  const {\n    addVar,\n    addAlias,\n    getAlias,\n    getDomain,\n    setDomain,\n    solveStack,\n  } = problem;\n\n  // Function addPseudoAlias(indexA, indexB, A, B) {\n  //  ASSERT(domain_isBoolyPair(A) && domain_isBoolyPair(B), 'assuming A and B are booly pairs');\n  //  ASSERT(A !== B, 'booly pairs that are equal are regular aliases so dont call this function on them');\n  //\n  //  addAlias(indexA, indexB); // A is replaced by B\n  //\n  //  // consider them aliases but add a special solve stack\n  //  // entry to restore the max to A if B turns out nonzero\n  //  solveStack.push((_, force, getDomain, setDomain) => {\n  //    TRACE(' - deduper psuedo alias; was:', domain__debug(A), '!^', domain__debug(B), ', now:', domain__debug(getDomain(indexA)), '!^', domain__debug(getDomain(indexB)));\n  //    let vB = force(indexB);\n  //    TRACE(' - B forced to', vB);\n  //    if (vB > 0) {\n  //      setDomain(indexA, domain_removeValue(A, 0), true, true);\n  //    }\n  //\n  //    ASSERT(getDomain(indexA));\n  //    ASSERT(getDomain(indexB));\n  //    ASSERT(domain_isSolved(getDomain(indexA)));\n  //    ASSERT(domain_isSolved(getDomain(indexB)));\n  //    ASSERT((domain_getValue(getDomain(indexA)) === 0) === (domain_getValue(getDomain(indexB)) === 0));\n  //  });\n  // }\n\n  while (!onlyJumps && (varChanged || restartedRelevantOp)) {\n    ++loops;\n    // Term.log('- looping', loops);\n    term.time('-> min_loop ' + loops);\n    TRACE('min outer loop');\n    varChanged = false;\n    onlyJumps = true; // Until proven otherwise\n    restartedRelevantOp = false;\n    pc = 0;\n    constraints = 0;\n    const ops = min_innerLoop();\n    TRACE(\n      'changed?',\n      varChanged,\n      'only jumps?',\n      onlyJumps,\n      'empty domain?',\n      emptyDomain,\n      'restartedRelevantOp?',\n      restartedRelevantOp\n    );\n    if (emptyDomain) {\n      term.log(\n        'Empty domain at',\n        lastPcOffset,\n        'for opcode',\n        lastOp,\n        [ml__debug(ml, lastPcOffset, 1, problem)],\n        ml.slice(lastPcOffset, lastPcOffset + 10)\n      );\n      term.log('Empty domain, problem rejected');\n    }\n\n    term.timeEnd('-> min_loop ' + loops);\n    term.log('   - ops this loop:', ops, 'constraints:', constraints);\n    if (emptyDomain) return $REJECTED;\n    if (onlyJumps) return $SOLVED;\n\n    TRACE('\\n## Intermediate state: ##');\n    TRACE(ml__debug(ml, 0, 20, problem));\n    TRACE(m2d__debug(problem));\n\n    if (once) break;\n    firstRun = false;\n  }\n\n  if (loops === 1) return $STABLE;\n  return $CHANGED;\n\n  // ####################################################################################\n\n  function readIndex(ml, offset) {\n    // Get an index from ml. check for alias, and if so, immediately compile back the alias to improve future fetches.\n    const index = ml_dec16(ml, offset);\n    const alias = getAlias(index);\n    if (alias !== index) ml_enc16(ml, offset, alias);\n    return alias;\n  }\n\n  function getDomainFast(index) {\n    ASSERT(index >= 0 && index <= 0xffff, 'expecting valid index', index);\n    ASSERT(\n      getAlias(index) === index,\n      'index should be unaliased',\n      index,\n      getAlias(index)\n    );\n\n    const domain = getDomain(index, true);\n    ASSERT(domain, 'domain cant be falsy', domain);\n    ASSERT_NORDOM(domain);\n\n    if (!domain)\n      setEmpty(\n        index,\n        'bad state (empty domain should have been detected sooner)'\n      );\n    return domain;\n  }\n\n  function updateDomain(index, domain, desc) {\n    TRACE(\n      ' - updateDomain; {',\n      index,\n      '} updated from',\n      domain__debug(getDomain(index)),\n      'to',\n      domain__debug(domain)\n    );\n    ASSERT(\n      !domain || domain_intersection(getDomain(index), domain),\n      'should never add new values to a domain, only remove them',\n      'index=',\n      index,\n      'old=',\n      domain__debug(getDomain(index)),\n      'new=',\n      domain__debug(domain),\n      'desc=',\n      desc\n    );\n\n    setDomain(index, domain, false, true);\n\n    if (domain) {\n      varChanged = true;\n    } else {\n      TRACE(' - (updateDomain: EMPTY DOMAIN)');\n      emptyDomain = true;\n    }\n\n    return emptyDomain;\n  }\n\n  function setEmpty(index, desc) {\n    TRACE(\" - :'( setEmpty({\", index, '})', desc);\n    emptyDomain = true;\n    if (index >= 0)\n      updateDomain(\n        index,\n        domain_createEmpty(),\n        'explicitly empty' + (desc ? '; ' + desc : '')\n      );\n  }\n\n  function min_innerLoop() {\n    let ops = 0;\n    onlyJumps = true;\n    let wasMetaOp = false; // Jumps, start, stop, etc. not important if they \"change\"\n    while (pc < ml.length && !emptyDomain) {\n      ++ops;\n      ++constraints;\n      wasMetaOp = false;\n      const pcStart = pc;\n      lastPcOffset = pc;\n      const op = ml[pc];\n      lastOp = op;\n\n      // ASSERT(ml_validateSkeleton(ml, 'min_innerLoop'));\n\n      TRACE(' # CU pc=' + pcStart, ', op=', op, ml__opName(op));\n      TRACE(' -> op: ' + ml__debug(ml, pc, 1, problem, true));\n\n      switch (op) {\n        case ML_START:\n          if (pc !== 0) {\n            TRACE(\n              'reading a op=zero at position ' +\n                pc +\n                ' which should not happen',\n              ml.slice(Math.max(pc - 100, 0), pc),\n              '<here>',\n              ml.slice(pc, pc + 100)\n            );\n            return THROW(' ! optimizer problem @', pc);\n          }\n\n          wasMetaOp = true;\n          ++pc;\n          --constraints; // Not a constraint\n          break;\n\n        case ML_STOP:\n          TRACE(' ! good end @', pcStart);\n          wasMetaOp = true;\n          --constraints; // Not a constraint\n          return ops;\n\n        case ML_LT:\n          TRACE('- lt vv @', pcStart);\n          min_lt(ml, pc);\n          break;\n\n        case ML_LTE:\n          TRACE('- lte vv @', pcStart);\n          min_lte(ml, pc);\n          break;\n\n        case ML_NONE:\n          TRACE('- none @', pcStart);\n          min_none(ml, pc);\n          break;\n\n        case ML_XOR:\n          TRACE('- xor @', pcStart);\n          min_xor(ml, pc);\n          break;\n\n        case ML_XNOR:\n          TRACE('- xnor @', pcStart);\n          min_xnor(ml, pc);\n          break;\n\n        case ML_IMP:\n          TRACE('- imp @', pcStart);\n          min_imp(ml, pc);\n          break;\n\n        case ML_NIMP:\n          TRACE('- nimp @', pcStart);\n          min_nimp(ml, pc);\n          break;\n\n        case ML_DIFF:\n          TRACE('- diff @', pcStart);\n          min_diff(ml, pc);\n          break;\n\n        case ML_ALL:\n          TRACE('- all() @', pcStart);\n          min_all(ml, pc);\n          break;\n\n        case ML_ISDIFF:\n          TRACE('- isdiff @', pcStart);\n          min_isDiff(ml, pc);\n          break;\n\n        case ML_NALL:\n          TRACE('- nall @', pcStart);\n          min_nall(ml, pc);\n          break;\n\n        case ML_SAME:\n          TRACE('- same @', pcStart);\n          min_same(ml, pc);\n          break;\n\n        case ML_SOME:\n          TRACE('- some @', pcStart);\n          min_some(ml, pc);\n          break;\n\n        case ML_ISLT:\n          TRACE('- islt vvv @', pcStart);\n          min_isLt(ml, pc);\n          break;\n\n        case ML_ISLTE:\n          TRACE('- islte vvv @', pcStart);\n          min_isLte(ml, pc);\n          break;\n\n        case ML_ISALL:\n          TRACE('- isall @', pcStart);\n          min_isAll(ml, pc);\n          break;\n\n        case ML_ISNALL:\n          TRACE('- isnall @', pcStart);\n          min_isNall(ml, pc);\n          break;\n\n        case ML_ISSAME:\n          TRACE('- issame @', pcStart);\n          min_isSame(ml, pc);\n          break;\n\n        case ML_ISSOME:\n          TRACE('- issome @', pcStart);\n          min_isSome(ml, pc);\n          break;\n\n        case ML_ISNONE:\n          TRACE('- isnone @', pcStart);\n          min_isNone(ml, pc);\n          break;\n\n        case ML_MINUS:\n          TRACE('- minus @', pcStart);\n          min_minus(ml, pc);\n          break;\n\n        case ML_DIV:\n          TRACE('- div @', pcStart);\n          min_div(ml, pc);\n          break;\n\n        case ML_SUM:\n          TRACE('- sum @', pcStart);\n          min_sum(ml, pc);\n          break;\n\n        case ML_PRODUCT:\n          TRACE('- product @', pcStart);\n          min_product(ml, pc);\n          break;\n\n        case ML_NOBOOL:\n          TRACE('- nobool @', pc);\n          pc += SIZEOF_V;\n          wasMetaOp = true;\n          break;\n        case ML_NOLEAF:\n          TRACE('- noleaf @', pc);\n          pc += SIZEOF_V;\n          wasMetaOp = true;\n          break;\n\n        case ML_NOOP:\n          TRACE('- noop @', pc);\n          min_moveTo(ml, pc, 1);\n          --constraints; // Not a constraint\n          wasMetaOp = true;\n          break;\n        case ML_NOOP2:\n          TRACE('- noop2 @', pc);\n          min_moveTo(ml, pc, 2);\n          --constraints; // Not a constraint\n          wasMetaOp = true;\n          break;\n        case ML_NOOP3:\n          TRACE('- noop3 @', pc);\n          min_moveTo(ml, pc, 3);\n          --constraints; // Not a constraint\n          wasMetaOp = true;\n          break;\n        case ML_NOOP4:\n          TRACE('- noop4 @', pc);\n          min_moveTo(ml, pc, 4);\n          --constraints; // Not a constraint\n          wasMetaOp = true;\n          break;\n        case ML_JMP:\n          TRACE('- jmp @', pc);\n          min_moveTo(ml, pc, SIZEOF_V + ml_dec16(ml, pc + 1));\n          --constraints; // Not a constraint\n          wasMetaOp = true;\n          break;\n        case ML_JMP32:\n          TRACE('- jmp32 @', pc);\n          min_moveTo(ml, pc, SIZEOF_W + ml_dec32(ml, pc + 1));\n          --constraints; // Not a constraint\n          wasMetaOp = true;\n          break;\n\n        default:\n          THROW('(mn) unknown op: 0x' + op.toString(16), ' at', pc);\n      }\n\n      if (pc === pcStart && !emptyDomain) {\n        TRACE(' - restarting op from same pc...');\n        if (!wasMetaOp) restartedRelevantOp = true; // TODO: undo this particular step if the restart results in the offset becoming a jmp?\n        --constraints; // Constraint may have been eliminated\n      }\n    }\n\n    if (emptyDomain) {\n      return ops;\n    }\n\n    return THROW('Derailed; expected to find STOP before EOF');\n  }\n\n  function min_moveTo(ml, offset, len) {\n    TRACE(\n      ' - trying to move from',\n      offset,\n      'to',\n      offset + len,\n      'delta = ',\n      len\n    );\n    switch (ml_dec8(ml, offset + len)) {\n      case ML_NOOP:\n      case ML_NOOP2:\n      case ML_NOOP3:\n      case ML_NOOP4:\n      case ML_JMP:\n      case ML_JMP32:\n        TRACE('- moving to another jump so merging them now');\n        ml_compileJumpAndConsolidate(ml, offset, len);\n        pc = offset; // Restart, make sure the merge worked\n        break;\n      default:\n        pc = offset + len;\n        break;\n    }\n  }\n\n  function min_same(ml, offset) {\n    // Loop through the args and alias each one to the previous. then eliminate the constraint. it is an artifact.\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(' = min_same', argCount, 'x');\n\n    if (argCount === 2) {\n      if (\n        readIndex(ml, offset + OFFSET_C_A) ===\n        readIndex(ml, offset + OFFSET_C_B)\n      ) {\n        TRACE(' - argcount=2 and A==B so eliminating constraint');\n        ml_eliminate(ml, offset, SIZEOF_C_2);\n        return;\n      }\n    }\n\n    if (argCount > 1) {\n      TRACE(\n        ' - aliasing all args to the first arg, intersecting all domains, and eliminating constraint'\n      );\n      const firstIndex = readIndex(ml, offset + SIZEOF_C);\n      let F = getDomain(firstIndex, true);\n\n      TRACE(' - indexF=', firstIndex, ', F=', domain__debug(F));\n\n      for (let i = 1; i < argCount; ++i) {\n        const indexD = readIndex(ml, offset + SIZEOF_C + i * 2);\n        if (indexD !== firstIndex) {\n          const D = getDomain(indexD, true);\n          TRACE(\n            '   - pos:',\n            i,\n            ', aliasing index',\n            indexD,\n            'to F, intersecting',\n            domain__debug(D),\n            'with',\n            domain__debug(F),\n            'to',\n            domain__debug(domain_intersection(F, D))\n          );\n          F = intersectAndAlias(indexD, firstIndex, D, F);\n          if (!F) {\n            TRACE('   !! Caused an empty domain. Failing.');\n            break;\n          }\n        }\n      }\n    }\n\n    TRACE(' - eliminating same() constraint');\n    ml_eliminate(ml, offset, SIZEOF_C + argCount * 2);\n  }\n\n  function min_diff_2(ml, offset) {\n    TRACE(' - min_diff_2');\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'should be arg count = 2');\n\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' -',\n      indexA,\n      '!=',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '!=',\n      domain__debug(B)\n    );\n    if (!A || !B) return true;\n    if (indexA === indexB) {\n      TRACE(' - A != A, falsum, artifact case');\n      setEmpty(indexA, 'X!=X falsum');\n      return true;\n    }\n\n    let solved = false;\n\n    // If either is solved then the other domain should\n    // become the result of unsolved_set \"minus\" solved_set\n    const vA = domain_getValue(A);\n    if (vA >= 0) {\n      const oB = B;\n      B = domain_removeValue(B, vA);\n      if (oB !== B && updateDomain(indexB, B, 'A != B with A solved'))\n        return true;\n      solved = true;\n    } else {\n      const vB = domain_getValue(B);\n      if (domain_getValue(B) >= 0) {\n        const oA = A;\n        A = domain_removeValue(A, vB);\n        if (A !== oA && updateDomain(indexA, A, 'A != B with B solved'))\n          return true;\n        solved = true;\n      }\n    }\n\n    // If the two domains share no elements the constraint is already satisfied\n    if (!solved && !domain_intersection(A, B)) solved = true;\n\n    TRACE(' ->', domain__debug(A), '!=', domain__debug(B), ', solved?', solved);\n\n    // Solved if the two domains (now) intersect to an empty domain\n    if (solved) {\n      TRACE(\n        ' - No element overlapping between',\n        indexA,\n        'and',\n        indexB,\n        'left so we can eliminate this diff'\n      );\n      ASSERT(\n        domain_sharesNoElements(A, B),\n        'if A or B solves, the code should have solved the diff'\n      );\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return true;\n    }\n\n    TRACE(' - min_diff_2 changed nothing');\n    return false;\n  }\n\n  function min_lt(ml, offset) {\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' = min_lt',\n      indexA,\n      '<',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '<',\n      domain__debug(B)\n    );\n    if (indexA === indexB) return setEmpty(indexA, 'X<X falsum'); // (relevant) artifact case\n    if (!A || !B) return;\n\n    // Relative comparison is easy; cut away any non-intersecting\n    // values that violate the desired outcome. only when a A and\n    // B have multiple intersecting values we have to keep this\n    // constraint\n    const oA = A;\n    A = domain_removeGte(A, domain_max(B));\n    if (A !== oA) {\n      TRACE(' - updating A to', domain__debug(A));\n      if (updateDomain(indexA, A, 'A lt B')) return;\n    }\n\n    const oB = B;\n    B = domain_removeLte(B, domain_min(A));\n    if (B !== oB) {\n      TRACE(' - updating B to', domain__debug(B));\n      if (updateDomain(indexB, B, 'A lt B')) return;\n    }\n\n    // Any value in A must be < any value in B\n    if (domain_max(A) < domain_min(B)) {\n      TRACE(' - Eliminating lt because max(A)<min(B)');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n    } else {\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + SIZEOF_C_2;\n    }\n  }\n\n  function min_lte(ml, offset) {\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' = min_lte',\n      indexA,\n      '<=',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '<=',\n      domain__debug(B)\n    );\n    if (!A || !B) return;\n\n    if (indexA === indexB) {\n      TRACE(\n        ' - Eliminating lte because max(A)<=min(A) is a tautology (once solved)'\n      );\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    // Relative comparison is easy; cut away any non-intersecting\n    // values that violate the desired outcome. only when a A and\n    // B have multiple intersecting values we have to keep this\n    // constraint\n\n    TRACE(\n      ' - index A!=B so remove all >max(B) from A',\n      domain__debug(A),\n      domain_max(B),\n      '->',\n      domain__debug(domain_removeGtUnsafe(A, domain_max(B)))\n    );\n\n    const oA = A;\n    A = domain_removeGtUnsafe(A, domain_max(B));\n    if (A !== oA) {\n      TRACE(' - Updating A to', domain__debug(A));\n      if (updateDomain(indexA, A, 'A lte B')) return;\n    }\n\n    // A is (now) empty so just remove it\n    const oB = B;\n    B = domain_removeLtUnsafe(B, domain_min(A));\n    if (B !== oB) {\n      TRACE(' - Updating B to', domain__debug(B));\n      if (updateDomain(indexB, B, 'A lte B')) return;\n    }\n\n    TRACE(\n      ' ->',\n      domain__debug(A),\n      '<=',\n      domain__debug(B),\n      ', bp?',\n      domain_isBoolyPair(A),\n      '<=',\n      domain_isBoolyPair(B),\n      ', max:',\n      domain_max(A),\n      '<=',\n      domain_max(B)\n    );\n\n    // Any value in A must be < any value in B\n    if (domain_max(A) <= domain_min(B)) {\n      TRACE(' - Eliminating lte because max(A)<=min(B)');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n    } else if (\n      domain_isBoolyPair(A) &&\n      domain_isBoolyPair(B) &&\n      domain_max(A) <= domain_max(B)\n    ) {\n      TRACE(' - A and B boolypair with max(A)<=max(B) so this is implication');\n      TRACE_MORPH('A <= B', 'B -> A');\n      ml_c2c2(ml, offset, 2, ML_IMP, indexA, indexB);\n      // Have to add a solvestack entry to prevent a solution [01]->1 which would satisfy IMP but not LTE\n      solveStack.push((_, force, getDomain, setDomain) => {\n        TRACE(\n          ' - min_lte; enforcing LTE',\n          indexA,\n          '<=',\n          indexB,\n          ' => ',\n          domain__debug(getDomain(indexA)),\n          '<=',\n          domain__debug(getDomain(indexB))\n        );\n        let A = getDomain(indexA);\n        let B = getDomain(indexB);\n\n        if (domain_hasNoZero(A)) {\n          B = domain_removeValue(B, 0);\n          setDomain(indexB, B);\n        } else if (domain_isZero(B) || domain_isBooly(A)) {\n          A = domain_removeGtUnsafe(A, 0);\n          setDomain(indexA, A);\n        }\n\n        ASSERT(getDomain(indexA));\n        ASSERT(getDomain(indexB));\n        ASSERT(\n          domain_max(getDomain(indexA)) <= domain_min(getDomain(indexB)),\n          'must hold lte',\n          domain__debug(A),\n          '<=',\n          domain__debug(B)\n        );\n      });\n    } else {\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + SIZEOF_C_2;\n    }\n  }\n\n  function min_nall(ml, offset) {\n    const offsetCount = offset + 1;\n    let argCount = ml_dec16(ml, offsetCount);\n    const offsetArgs = offset + SIZEOF_C;\n    const opSize = SIZEOF_C + argCount * 2;\n\n    TRACE(' = min_nall', argCount, 'x');\n    TRACE('  - ml for this nall:', ml.slice(offset, offset + opSize).join(' '));\n    TRACE(\n      '  -',\n      Array.from(Array(argCount)).map((n, i) =>\n        readIndex(ml, offsetArgs + i * 2)\n      )\n    );\n    TRACE(\n      '  -',\n      Array.from(Array(argCount)).map((n, i) =>\n        domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n      )\n    );\n\n    if (!argCount) return setEmpty(-1, 'nall without args is probably a bug');\n\n    if (argCount === 2) {\n      if (min_nall_2(ml, offset)) return;\n    }\n\n    const countStart = argCount;\n    let lastIndex = -1;\n    let lastDomain;\n\n    // A nall only ensures at least one of its arg solves to zero\n    for (let i = argCount - 1; i >= 0; --i) {\n      // Backwards because we're pruning dud indexes\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n\n      TRACE(\n        '  - loop i=',\n        i,\n        'index=',\n        index,\n        'domain=',\n        domain__debug(domain)\n      );\n      if (!domain) return;\n\n      if (domain_min(domain) > 0 || lastIndex === index) {\n        // Remove var from list\n        TRACE(\n          lastIndex === index\n            ? ' - removing redundant dupe var from nall'\n            : ' - domain contains no zero so remove var from this constraint'\n        );\n\n        // Now\n        // - move all indexes bigger than the current back one position\n        // - compile the new count back in\n        // - compile a NOOP in the place of the last element\n        TRACE(\n          '  - moving further domains one space forward (from ',\n          i + 1,\n          ' / ',\n          argCount,\n          ')'\n        );\n        min_spliceArgSlow(ml, offsetArgs, argCount, i, false);\n        --argCount;\n      } else if (domain_isZero(domain)) {\n        // Remove constraint\n        TRACE(' - domain solved to zero so constraint is satisfied');\n        ml_eliminate(ml, offset, SIZEOF_C + 2 * countStart);\n        return;\n      } else {\n        // Arg contains a 0 and is unsolved\n        TRACE(' - domain contains zero and is not solved so leave it alone');\n        lastIndex = index;\n        lastDomain = domain;\n      }\n    }\n\n    if (argCount === 0) {\n      TRACE(' - Nall has no var left to be zero; rejecting problem');\n      // This is a bad state: all vars were removed from this constraint which\n      // means none of the args were zero and the constraint doesnt hold\n      return setEmpty(lastIndex, 'nall; none of the args were zero');\n    }\n    if (argCount === 1) {\n      TRACE(' - Nall has one var left; forcing it to zero');\n      // Force set last index to zero and remove constraint. this should not\n      // reject (because then the var would have been removed in loop above)\n      // but do it \"safe\" anyways, just in case.\n      const domain = domain_removeGtUnsafe(lastDomain, 0);\n      if (lastDomain !== domain && updateDomain(lastIndex, domain)) return;\n      ml_eliminate(ml, offset, SIZEOF_C + 2 * countStart);\n    } else if (countStart !== argCount) {\n      TRACE(' - recording new argcount and freeing up space');\n      ml_enc16(ml, offsetCount, argCount); // Write new count\n      const free = (countStart - argCount) * 2;\n      ml_compileJumpSafe(ml, offset + opSize - free, free);\n      // Note: still have to restart op because ml_jump may have clobbered the old end of the op with a new jump\n    } else {\n      TRACE(' - not only jumps...');\n\n      onlyJumps = false;\n      pc = offset + opSize;\n    }\n  }\n\n  function min_nall_2(ml, offset) {\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' = min_nall_2',\n      indexA,\n      '!&',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '!&',\n      domain__debug(B)\n    );\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'nall should have 2 args');\n    if (!A || !B) return true;\n\n    if (indexA === indexB) {\n      TRACE(' - indexA==indexB so A=0 and eliminate constraint');\n      const oA = A;\n      A = domain_removeGtUnsafe(A, 0);\n      if (A !== oA) updateDomain(indexA, A, '`A !& A` means A must be zero');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return true;\n    }\n\n    if (domain_isZero(A) || domain_isZero(B)) {\n      TRACE(' - A=0 or B=0, eliminating constraint');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return true;\n    }\n\n    if (domain_hasNoZero(A)) {\n      TRACE(' - A>=1 so B must be 0');\n      const oB = B;\n      B = domain_removeGtUnsafe(B, 0);\n      if (B !== oB) updateDomain(indexB, B, 'nall[2] B');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return true;\n    }\n\n    if (domain_hasNoZero(B)) {\n      TRACE(' - B>=1 so A must be 0');\n      const oA = A;\n      A = domain_removeGtUnsafe(A, 0);\n      if (A !== oA) updateDomain(indexA, A, 'nall[2] A');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return true;\n    }\n\n    TRACE(' - min_nall_2 changed nothing');\n    return false;\n  }\n\n  function min_some(ml, offset) {\n    const offsetCount = offset + 1;\n    let argCount = ml_dec16(ml, offsetCount);\n    const offsetArgs = offset + SIZEOF_C;\n    const opSize = SIZEOF_C + argCount * 2;\n\n    TRACE(' = min_some', argCount, 'x');\n    TRACE('  - ml for this some:', ml.slice(offset, offset + opSize).join(' '));\n    TRACE(\n      '  -',\n      Array.from(Array(argCount)).map((n, i) =>\n        readIndex(ml, offsetArgs + i * 2)\n      )\n    );\n    TRACE(\n      '  -',\n      Array.from(Array(argCount)).map((n, i) =>\n        domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n      )\n    );\n\n    if (!argCount) return setEmpty(-1, 'some without args is probably a bug');\n\n    if (argCount === 2) {\n      if (min_some_2(ml, offset)) return;\n    }\n\n    const countStart = argCount;\n    let lastIndex = -1;\n    let lastDomain;\n\n    // A some only ensures at least one of its arg solves to zero\n    for (let i = argCount - 1; i >= 0; --i) {\n      // Backwards because we're pruning dud indexes\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n\n      TRACE(\n        '  - loop i=',\n        i,\n        'index=',\n        index,\n        'domain=',\n        domain__debug(domain)\n      );\n      if (!domain) return;\n\n      if (domain_isZero(domain) || lastIndex === index) {\n        // Remove var from list\n        TRACE(\n          lastIndex === index\n            ? ' - removing redundant dupe var from some'\n            : ' - domain contains no zero so remove var from this constraint'\n        );\n\n        // Now\n        // - move all indexes bigger than the current back one position\n        // - compile the new count back in\n        // - compile a NOOP in the place of the last element\n        TRACE(\n          '  - moving further domains one space forward (from ',\n          i + 1,\n          ' / ',\n          argCount,\n          ')'\n        );\n        min_spliceArgSlow(ml, offsetArgs, argCount, i, false);\n        --argCount;\n      } else if (domain_hasNoZero(domain)) {\n        // Remove constraint\n        TRACE(' - domain solved to nonzero so constraint is satisfied');\n        ml_eliminate(ml, offset, SIZEOF_C + 2 * countStart);\n        return;\n      } else {\n        // Arg contains a 0 and is unsolved\n        TRACE(' - domain contains zero and is not solved so leave it alone');\n        lastIndex = index;\n        lastDomain = domain;\n      }\n    }\n\n    if (argCount === 0) {\n      TRACE(' - Some has no var left to be zero; rejecting problem');\n      // This is a bad state: all vars were removed from this constraint which\n      // means all of the args were zero and the constraint doesnt hold\n      return setEmpty(lastIndex, 'some; all of the args were zero');\n    }\n    if (argCount === 1) {\n      TRACE(' - Some has one var left; forcing it to nonzero');\n      // Force set last index to nonzero and remove constraint. this should not\n      // reject (because then the var would have been removed in loop above)\n      // but do it \"safe\" anyways, just in case.\n      const domain = domain_removeValue(lastDomain, 0);\n      if (lastDomain !== domain && updateDomain(lastIndex, domain)) return;\n      ml_eliminate(ml, offset, SIZEOF_C + 2 * countStart);\n    } else if (countStart !== argCount) {\n      TRACE(' - recording new argcount and freeing up space');\n      ml_enc16(ml, offsetCount, argCount); // Write new count\n      const free = (countStart - argCount) * 2;\n      ml_compileJumpSafe(ml, offset + opSize - free, free);\n      // Note: still have to restart op because ml_jump may have clobbered the old end of the op with a new jump\n    } else {\n      TRACE(' - not only jumps...');\n\n      onlyJumps = false;\n      pc = offset + opSize;\n    }\n  }\n\n  function min_isAll(ml, offset) {\n    const offsetCount = offset + 1;\n    let argCount = ml_dec16(ml, offsetCount);\n    const opSize = SIZEOF_C + 2 + argCount * 2;\n    const offsetArgs = offset + SIZEOF_C;\n    const offsetR = offset + opSize - 2;\n\n    const indexR = readIndex(ml, offsetR);\n    let R = getDomainFast(indexR);\n\n    TRACE(' = min_isAll', argCount, 'x');\n    TRACE(\n      '  - ml for this isAll (' + opSize + 'b):',\n      ml.slice(offset, offset + opSize).join(' ')\n    );\n    TRACE(\n      '  -',\n      indexR,\n      '= all?(',\n      [...Array(argCount)].map((n, i) =>\n        readIndex(ml, offsetArgs + i * 2)\n      ),\n      ')'\n    );\n    TRACE(\n      '  -',\n      domain__debug(R),\n      '= all?(',\n      [...Array(argCount)].map((n, i) =>\n        domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n      ),\n      ')'\n    );\n\n    if (!R) return;\n\n    if (domain_isZero(R)) {\n      TRACE(' - R is 0 so morph to nall and revisit');\n      // Compile to nall and revisit\n      ml_enc8(ml, offset, ML_NALL);\n      ml_compileJumpSafe(ml, offset + opSize - 2, 2); // Difference between nall with R=0 and an isAll is the result var (16bit)\n      return;\n    }\n\n    if (domain_hasNoZero(R)) {\n      TRACE(\n        ' - R is non-zero so remove zero from all args and eliminate constraint'\n      );\n      for (let i = 0; i < argCount; ++i) {\n        const index = readIndex(ml, offsetArgs + i * 2);\n        const domain = getDomainFast(index);\n        TRACE('    - index=', index, 'dom=', domain__debug(domain));\n        if (!domain) return;\n        const newDomain = domain_removeValue(domain, 0);\n        if (newDomain !== domain && updateDomain(index, newDomain)) return;\n      }\n\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    // R is unresolved. check whether R can be determined\n    ASSERT(domain_min(R) === 0 && domain_max(R) > 0, 'R is unresolved here', R);\n    let allNonZero = true;\n    let someAreZero = false;\n    let someNonZero = false;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n      TRACE('    - index=', index, 'dom=', domain__debug(domain));\n\n      // Reflect isAll,\n      // R=0 when at least one arg is zero\n      // R>0 when all args have no zero\n\n      if (domain_isZero(domain)) {\n        TRACE(' - found a zero, breaking loop because R=0');\n        someAreZero = true;\n        break; // This permanently sets R to 0; no need to loop further\n      } else if (domain_min(domain) === 0) {\n        // Arg has zero and non-zero values so R (at least) cant be set to 1 yet\n        allNonZero = false;\n      } else {\n        someNonZero = true;\n      }\n    }\n\n    if (someAreZero) {\n      TRACE(\n        ' - At least one arg was zero so R=0 and constraint can be removed'\n      );\n      const oR = R;\n      R = domain_removeGtUnsafe(R, 0);\n      if (R !== oR) updateDomain(indexR, R);\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    if (allNonZero) {\n      TRACE(' - No arg had zero so R=1 and constraint can be removed');\n      const oR = R;\n      R = domain_removeValue(R, 0);\n      if (R !== oR) updateDomain(indexR, R);\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    // Remove all non-zero values from the list. this reduces their connection count and simplifies this isall\n    if (someNonZero) {\n      let removed = 0;\n      for (let i = argCount - 1; i >= 0; --i) {\n        const index = readIndex(ml, offsetArgs + i * 2);\n        const domain = getDomainFast(index);\n        TRACE(\n          '   - checking if index',\n          index,\n          '(domain',\n          domain__debug(domain),\n          ') contains no zero so we can remove it from this isall'\n        );\n        if (domain_hasNoZero(domain)) {\n          // Now\n          // - move all indexes bigger than the current back one position\n          // - compile the new count back in\n          // - compile a NOOP in the place of the last element\n          TRACE(\n            '  - moving further domains one space forward (from ',\n            i + 1,\n            ' / ',\n            argCount,\n            ')'\n          );\n          min_spliceArgSlow(ml, offsetArgs, argCount, i, true);\n          --argCount;\n          ++removed;\n        }\n      }\n\n      ml_enc16(ml, offset + 1, argCount);\n      // Now \"blank out\" the space of eliminated constants, they should be at the end of the op\n      const newOpSize = opSize - removed * 2;\n      ml_compileJumpSafe(ml, offset + newOpSize, opSize - newOpSize);\n\n      TRACE(\n        ' - Removed',\n        removed,\n        'non-zero args from unsolved isall, has',\n        argCount,\n        'left'\n      );\n      TRACE(\n        ' - ml for this sum now:',\n        ml.slice(offset, offset + opSize).join(' ')\n      );\n\n      if (argCount === 1)\n        _min_isAllMorphToXnor(ml, offset, argCount, offsetArgs, indexR);\n      return;\n    }\n\n    if (argCount === 1)\n      return _min_isAllMorphToXnor(ml, offset, argCount, offsetArgs, indexR);\n\n    TRACE(' - not only jumps...');\n    onlyJumps = false;\n    pc = offset + opSize;\n  }\n\n  function _min_isAllMorphToXnor(ml, offset, argCount, offsetArgs, indexR) {\n    // While this usually only happens when eliminating non-zeroes, there may be an artifact where a script\n    // generated an isall with just one arg. kind of silly but whatever, right.\n    TRACE(' - Only one arg remaining; morphing to a XNOR');\n    ASSERT(\n      argCount > 0,\n      'isall must have at least one arg in order to have enough space for the xnor morph'\n    );\n    const index = readIndex(ml, offsetArgs);\n    ml_cr2c2(ml, offset, argCount, ML_XNOR, indexR, index);\n    varChanged = true; // The xnor may need optimization\n  }\n\n  function min_isNall(ml, offset) {\n    const offsetCount = offset + 1;\n    const argCount = ml_dec16(ml, offsetCount);\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n    const offsetArgs = offset + SIZEOF_C;\n    const offsetR = offset + opSize - 2;\n\n    const indexR = readIndex(ml, offsetR);\n    let R = getDomainFast(indexR);\n\n    TRACE(' = min_isNall', argCount, 'x');\n    TRACE(\n      '  - ml for this isNall:',\n      ml.slice(offset, offset + opSize).join(' ')\n    );\n    TRACE(\n      '  -',\n      indexR,\n      '= nall?(',\n      [...Array(argCount)].map((n, i) =>\n        readIndex(ml, offsetArgs + i * 2)\n      ),\n      ')'\n    );\n    TRACE(\n      '  -',\n      domain__debug(R),\n      '= nall?(',\n      [...Array(argCount)].map((n, i) =>\n        domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n      ),\n      ')'\n    );\n\n    if (!R) return;\n\n    if (domain_isZero(R)) {\n      TRACE(\n        ' - R=0 so; !nall so; all so; we must remove zero from all args and eliminate constraint'\n      );\n      for (let i = 0; i < argCount; ++i) {\n        const index = readIndex(ml, offsetArgs + i * 2);\n        const domain = getDomainFast(index);\n        TRACE('    - index=', index, 'dom=', domain__debug(domain));\n        if (!domain) return;\n        const newDomain = domain_removeValue(domain, 0);\n        if (newDomain !== domain && updateDomain(index, newDomain)) return;\n      }\n\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    if (domain_hasNoZero(R)) {\n      TRACE(' - R>0 so; nall. just morph and revisit');\n      ml_enc8(ml, offset, ML_NALL);\n      ml_compileJumpSafe(ml, offset + opSize - 2, 2); // Difference between nall and isNall is the result var (16bit)\n      return;\n    }\n\n    // R is unresolved. check whether R can be determined\n    ASSERT(domain_min(R) === 0 && domain_max(R) > 0, 'R is unresolved here', R);\n    let allNonZero = true;\n    let someAreZero = false;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n      TRACE('    - index=', index, 'dom=', domain__debug(domain));\n\n      // Reflect isNall,\n      // R=0 when all args have no zero\n      // R>0 when at least one arg is zero\n\n      if (domain_isZero(domain)) {\n        TRACE(' - found a zero, breaking loop because R=0');\n        someAreZero = true;\n        break; // This permanently sets R to 0; no need to loop further\n      } else if (domain_min(domain) === 0) {\n        // Arg has zero and non-zero values so R (at least) cant be set to 1 yet\n        allNonZero = false;\n      }\n    }\n\n    if (someAreZero) {\n      TRACE(\n        ' - At least one arg was zero so R>=1 and constraint can be removed'\n      );\n      const oR = R;\n      R = domain_removeValue(R, 0);\n      if (R !== oR)\n        updateDomain(\n          indexR,\n          R,\n          'isnall, R>=1 because at least one var was zero'\n        );\n      ml_eliminate(ml, offset, opSize);\n    } else if (allNonZero) {\n      TRACE(' - No arg had a zero so R=0 and constraint can be removed');\n      const oR = R;\n      R = domain_removeGtUnsafe(R, 0);\n      if (R !== oR) updateDomain(indexR, R);\n      ml_eliminate(ml, offset, opSize);\n    } else {\n      // TODO: prune all args here that are nonzero? is that worth it?\n\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + opSize;\n    }\n  }\n\n  function min_isSome(ml, offset) {\n    const offsetCount = offset + 1;\n    const argCount = ml_dec16(ml, offsetCount);\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n    const offsetArgs = offset + SIZEOF_C;\n    const offsetR = offset + opSize - 2;\n\n    const indexR = readIndex(ml, offsetR);\n    let R = getDomainFast(indexR);\n\n    TRACE(' = min_isSome', argCount, 'x');\n    TRACE(\n      '  - ml for this isSome:',\n      ml.slice(offset, offset + opSize).join(' ')\n    );\n    TRACE(\n      '  -',\n      indexR,\n      '= some?(',\n      [...Array(argCount)].map((n, i) =>\n        readIndex(ml, offsetArgs + i * 2)\n      ),\n      ')'\n    );\n    TRACE(\n      '  -',\n      domain__debug(R),\n      '= some?(',\n      [...Array(argCount)].map((n, i) =>\n        domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n      ),\n      ')'\n    );\n\n    if (!R) return;\n\n    if (domain_isZero(R)) {\n      TRACE(\n        ' - R=0 so; !some so; none so; we must force zero to all args and eliminate constraint'\n      );\n      for (let i = 0; i < argCount; ++i) {\n        const index = readIndex(ml, offsetArgs + i * 2);\n        const domain = getDomainFast(index);\n        TRACE('    - index=', index, 'dom=', domain__debug(domain));\n        if (!domain) return;\n        const newDomain = domain_removeGtUnsafe(domain, 0);\n        if (newDomain !== domain && updateDomain(index, newDomain)) return;\n      }\n\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    if (domain_hasNoZero(R)) {\n      TRACE(' - R>0 so; some. just morph and revisit');\n      ml_enc8(ml, offset, ML_SOME);\n      ml_compileJumpSafe(ml, offset + opSize - 2, 2); // Difference between some and isSome is the result var (16bit)\n      return;\n    }\n\n    // R is unresolved. check whether R can be determined\n    ASSERT(domain_min(R) === 0 && domain_max(R) > 0, 'R is unresolved here', R);\n    let someNonZero = false;\n    let allZero = true;\n    let someZero = false;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n      TRACE('    - index=', index, 'dom=', domain__debug(domain));\n\n      // Reflect isSome,\n      // R=0 when all args are zero (already checked above)\n      // R>0 when at least one arg is nonzero\n\n      if (domain_hasNoZero(domain)) {\n        TRACE(' - found a nonzero, breaking loop because R>0');\n        someNonZero = true;\n        break; // This permanently sets R to 0; no need to loop further\n      } else if (domain_isZero(domain)) {\n        someZero = true;\n      } else {\n        allZero = false;\n      }\n    }\n\n    if (someNonZero) {\n      TRACE(\n        ' - At least one arg was zero so R>=1 and constraint can be removed'\n      );\n      const oR = R;\n      R = domain_removeValue(R, 0);\n      if (R !== oR)\n        updateDomain(\n          indexR,\n          R,\n          'issome, R>=1 because at least one var was nonzero'\n        );\n      ml_eliminate(ml, offset, opSize);\n    } else if (allZero) {\n      TRACE(' - All vars were zero so R=0 and constraint can be removed');\n      const oR = R;\n      R = domain_removeGtUnsafe(R, 0);\n      if (R !== oR)\n        updateDomain(indexR, R, 'issome, R>=1 because all vars were zero');\n      ml_eliminate(ml, offset, opSize);\n    } else if (someZero) {\n      TRACE(' - Some vars were zero, removing them from the args');\n      // Force constants to the end\n      ml_heapSort16bitInline(ml, pc + SIZEOF_C, argCount);\n      // We know\n      // - these args do not contain non-zero args\n      // - all constants are moved to the back\n      // - there is at least one constant 0\n      // - not all args were 0\n      // so we can move back the result var\n      let argOffset = offsetArgs + argCount * 2 - 2;\n      TRACE(\n        ' - offset:',\n        offset,\n        ', argCount:',\n        argCount,\n        ', args offset:',\n        offsetArgs,\n        ', first arg domain:',\n        domain__debug(getDomain(readIndex(ml, offsetArgs))),\n        ', last arg offset:',\n        argOffset,\n        ', last domain:',\n        domain__debug(getDomain(readIndex(ml, argOffset)))\n      );\n      TRACE(' - op before:', ml__debug(ml, offset, 1, problem));\n      ASSERT(\n        domain_isZero(getDomain(readIndex(ml, argOffset))),\n        'at least the last arg should be zero',\n        domain__debug(getDomain(readIndex(ml, argOffset)))\n      );\n      ASSERT(\n        !domain_isZero(getDomain(readIndex(ml, offsetArgs))),\n        'the first arg should not be zero',\n        domain__debug(getDomain(readIndex(ml, offsetArgs)))\n      );\n      // Search for the first non-zero arg\n      let newArgCount = argCount;\n      while (domain_isZero(getDomain(readIndex(ml, argOffset)))) {\n        argOffset -= 2;\n        --newArgCount;\n      }\n\n      TRACE(\n        ' - last non-zero arg is arg number',\n        newArgCount,\n        'at',\n        argOffset,\n        ', index:',\n        readIndex(ml, argOffset),\n        ', domain:',\n        domain__debug(getDomain(readIndex(ml, argOffset)))\n      );\n\n      if (newArgCount === 1) {\n        TRACE(' - there is one arg left, morph to XNOR');\n        TRACE_MORPH('R = some?(A 0 0 ..)', 'R !^ A');\n        const indexA = readIndex(ml, offsetArgs);\n        ml_cr2c2(ml, offset, argCount, ML_XNOR, indexR, indexA);\n      } else {\n        TRACE(\n          ' - moving R to the first zero arg at offset',\n          argOffset + 2,\n          'and compiling a jump for the rest'\n        );\n        // Copy the result var over the first zero arg\n        ml_enc16(ml, offset + 1, newArgCount);\n        ml_enc16(ml, argOffset + 2, indexR);\n        ml_compileJumpSafe(ml, argOffset + 4, (argCount - newArgCount) * 2);\n        ASSERT(ml_validateSkeleton(ml, 'min_isSome; pruning zeroes'));\n      }\n\n      TRACE(' - op after:', ml__debug(ml, offset, 1, problem));\n    } else {\n      // TODO: prune all args here that are zero? is that worth it?\n\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + opSize;\n    }\n  }\n\n  function min_isNone(ml, offset) {\n    const offsetCount = offset + 1;\n    const argCount = ml_dec16(ml, offsetCount);\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n    const offsetArgs = offset + SIZEOF_C;\n    const offsetR = offset + opSize - 2;\n\n    const indexR = readIndex(ml, offsetR);\n    let R = getDomainFast(indexR);\n\n    TRACE(' = min_isNone', argCount, 'x');\n    TRACE(\n      '  - ml for this isNone:',\n      ml.slice(offset, offset + opSize).join(' ')\n    );\n    TRACE(\n      '  -',\n      indexR,\n      '= none?(',\n      [...Array(argCount)].map((n, i) =>\n        readIndex(ml, offsetArgs + i * 2)\n      ),\n      ')'\n    );\n    TRACE(\n      '  -',\n      domain__debug(R),\n      '= none?(',\n      [...Array(argCount)].map((n, i) =>\n        domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n      ),\n      ')'\n    );\n\n    if (!R) return;\n\n    if (domain_hasNoZero(R)) {\n      TRACE('    - R>=1 so set all args to zero and eliminate');\n      for (let i = 0; i < argCount; ++i) {\n        const index = readIndex(ml, offsetArgs + i * 2);\n        const domain = getDomainFast(index);\n        TRACE('    - index=', index, 'dom=', domain__debug(domain));\n        if (!domain) return;\n        const newDomain = domain_removeGtUnsafe(domain, 0);\n        if (newDomain !== domain && updateDomain(index, newDomain)) return;\n      }\n\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    if (domain_isZero(R)) {\n      TRACE(' - R=0 so this is a SOME. just morph and revisit');\n      TRACE_MORPH('0 = none?(A B C ...)', 'some(A B C ...)');\n      ml_enc8(ml, offset, ML_SOME);\n      ml_compileJumpSafe(ml, offset + opSize - 2, 2); // Difference between some and isNone is the result var (16bit)\n      return;\n    }\n\n    // R has a zero or is zero, determine whether there is any nonzero arg, or whether they are all zero\n    let nonZero = false;\n    let allZero = true;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n      TRACE('    - index=', index, 'dom=', domain__debug(domain));\n\n      // Reflect isNone,\n      // R=0 when at least one arg is nonzero\n      // R>0 when all args are zero\n\n      if (domain_hasNoZero(domain)) {\n        nonZero = true;\n        break;\n      }\n\n      if (!domain_isZero(domain)) {\n        allZero = false;\n      }\n    }\n\n    if (nonZero) {\n      TRACE(' - at least one arg had no zero so R=0, eliminate constraint');\n      const oR = R;\n      R = domain_removeGtUnsafe(R, 0);\n      if (R !== oR)\n        updateDomain(indexR, R, 'isnone R=0 because an arg had no zero');\n      ml_eliminate(ml, offset, opSize);\n    } else if (allZero) {\n      TRACE(' - isnone, all args are 0 so R>=1, remove constraint');\n      const oR = R;\n      R = domain_removeValue(R, 0);\n      if (R !== oR)\n        updateDomain(indexR, R, 'isnone R>=1 because all args were zero');\n      ml_eliminate(ml, offset, opSize);\n    } else {\n      // TODO: prune all args here that are zero? is that worth it?\n\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + SIZEOF_C + argCount * 2 + 2;\n    }\n  }\n\n  function min_diff(ml, offset) {\n    let argCount = ml_dec16(ml, offset + 1);\n    const offsetArgs = offset + SIZEOF_C;\n    const opSize = SIZEOF_C + argCount * 2;\n\n    TRACE(' = min_diff', argCount, 'x');\n    TRACE('  - ml for this diff:', ml.slice(offset, offset + opSize).join(' '));\n    TRACE(\n      '  - indexes:',\n      [...Array(argCount)]\n        .map((n, i) => readIndex(ml, offsetArgs + i * 2))\n        .join(', ')\n    );\n    TRACE(\n      '  - domains:',\n      [...Array(argCount)]\n        .map((n, i) =>\n          domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n        )\n        .join(', ')\n    );\n\n    ASSERT(argCount, 'should have at least one arg or be eliminated');\n    if (!argCount) return setEmpty(-1, 'diff without args is probably a bug');\n\n    const countStart = argCount;\n\n    // A diff is basically a pyramid of neq's; one for each unique pair of the set\n    // we loop back to front because we're splicing out vars while looping\n    for (let i = argCount - 1; i >= 0; --i) {\n      const indexA = readIndex(ml, offsetArgs + i * 2);\n      const A = getDomainFast(indexA);\n      TRACE('  - loop i=', i, 'index=', indexA, 'domain=', domain__debug(A));\n      if (!A) return;\n\n      const v = domain_getValue(A);\n      if (v >= 0) {\n        TRACE(\n          '   - solved, so removing',\n          v,\n          'from all other domains and index',\n          indexA,\n          'from the constraint'\n        );\n        for (let j = 0; j < argCount; ++j) {\n          // Gotta loop through all args. args wont be removed in this loop.\n          if (j !== i) {\n            const indexB = readIndex(ml, offsetArgs + j * 2);\n            const oB = getDomainFast(indexB);\n            TRACE(\n              '    - loop j=',\n              j,\n              'index=',\n              indexB,\n              'domain=',\n              domain__debug(oB)\n            );\n            if (indexA === indexB)\n              return updateDomain(\n                indexA,\n                domain_createEmpty(),\n                'diff had this var twice, x!=x is a falsum'\n              ); // Edge case\n\n            const B = domain_removeValue(oB, v);\n            if (B !== oB && updateDomain(indexB, B, 'diff arg')) return;\n          }\n        }\n        // So none of the other args have v and none of them ended up empty\n\n        // now\n        // - move all indexes bigger than the current back one position\n        // - compile the new count back in\n        // - compile a NOOP in the place of the last element\n        TRACE(\n          '  - moving further domains one space forward (from ',\n          i + 1,\n          ' / ',\n          argCount,\n          ')',\n          i + 1 < argCount\n        );\n        min_spliceArgSlow(ml, offsetArgs, argCount, i, true); // Move R as well\n        --argCount;\n      }\n    }\n\n    if (argCount <= 1) {\n      TRACE(' - Count is', argCount, '; eliminating constraint');\n      ASSERT(argCount >= 0, 'cant be negative');\n      ml_eliminate(ml, offset, opSize);\n    } else if (argCount !== countStart) {\n      TRACE('  - recompiling new count (', argCount, ')');\n      ml_enc16(ml, offset + 1, argCount);\n      TRACE('  - compiling noop into empty spots'); // This hasnt happened yet\n      ml_compileJumpSafe(\n        ml,\n        offsetArgs + argCount * 2,\n        (countStart - argCount) * 2\n      );\n      // Need to restart op because the skip may have clobbered the next op offset\n    } else if (argCount === 2 && min_diff_2(ml, offset)) {\n      // Do nothing. min_diff_2 has already done something.\n    } else {\n      TRACE(' - not only jumps...', opSize);\n      onlyJumps = false;\n      pc = offset + opSize;\n    }\n  }\n\n  function min_sum_2(ml, sumOffset) {\n    const offsetA = sumOffset + OFFSET_C_A;\n    const offsetB = sumOffset + OFFSET_C_B;\n    const offsetR = sumOffset + OFFSET_C_R;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    const indexR = readIndex(ml, offsetR);\n\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      ' = min_sum_2',\n      indexR,\n      '=',\n      indexA,\n      '+',\n      indexB,\n      '   ->   ',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '+',\n      domain__debug(B)\n    );\n    if (!A || !B || !R) return false;\n\n    ASSERT(ml_dec8(ml, sumOffset) === ML_SUM, 'should be a sum with 2 args');\n    ASSERT(ml_dec16(ml, sumOffset + 1) === 2, 'should have 2 args');\n\n    // Note: A + B = C   ==>   <loA + loB, hiA + hiB>\n    // but:  A - B = C   ==>   <loA - hiB, hiA - loB>   (so the lo/hi of B gets swapped!)\n    // keep in mind that any number oob <sub,sup> gets pruned in either case, this makes\n    // plus and minus are not perfect (counter-intuitively): `[0, 2] - [0, 4] = [0, 2]`\n\n    const ooA = A;\n    const ooB = B;\n    const ooR = R;\n\n    let oA;\n    let oB;\n    let oR;\n    let loops = 0;\n    do {\n      ++loops;\n      TRACE(\n        ' - plus propagation step...',\n        loops,\n        domain__debug(R),\n        '=',\n        domain__debug(A),\n        '+',\n        domain__debug(B)\n      );\n      oA = A;\n      oB = B;\n      oR = R;\n\n      R = domain_intersection(R, domain_plus(A, B));\n      A = domain_intersection(A, domain_minus(R, B));\n      B = domain_intersection(B, domain_minus(R, A));\n    } while (A !== oA || B !== oB || R !== oR);\n\n    TRACE(\n      ' ->',\n      'R:',\n      domain__debug(R),\n      '= A:',\n      domain__debug(A),\n      '+ B:',\n      domain__debug(B)\n    );\n\n    if (loops > 1) {\n      if (A !== ooA) updateDomain(indexA, A, 'plus A');\n      if (B !== ooB) updateDomain(indexB, B, 'plus B');\n      if (R !== ooR) updateDomain(indexR, R, 'plus R');\n      if (!A || !B || !R) return false;\n    }\n\n    const vA = domain_getValue(A);\n    const vB = domain_getValue(B);\n    const vR = domain_getValue(R);\n\n    ASSERT(\n      (vA >= 0) + (vB >= 0) + (vR >= 0) !== 2,\n      'if two vars are solved the third should be solved as well'\n    );\n\n    if (vA >= 0 && vB >= 0) {\n      // So vR>=0 as well\n      TRACE(' - All args are solved so removing constraint');\n      ASSERT(vR >= 0, 'if two are solved then all three must be solved');\n      ml_eliminate(ml, sumOffset, SIZEOF_CR_2);\n      return true;\n    }\n\n    if (vA >= 0) {\n      ASSERT(vB < 0 && vR < 0);\n      if (\n        min_plusWithSolvedArg(\n          sumOffset,\n          indexB,\n          indexA,\n          indexR,\n          A,\n          B,\n          R,\n          vA,\n          'A',\n          'B'\n        )\n      ) {\n        return true;\n      }\n    }\n\n    if (vB >= 0) {\n      ASSERT(vA < 0 && vR < 0);\n      if (\n        min_plusWithSolvedArg(\n          sumOffset,\n          indexA,\n          indexB,\n          indexR,\n          B,\n          A,\n          R,\n          vB,\n          'B',\n          'A'\n        )\n      ) {\n        return true;\n      }\n    }\n\n    //\n    // TRACE(' - not only jumps');\n    // onlyJumps = false;\n    // pc = sumOffset + SIZEOF_CR_2;\n    return false;\n  }\n\n  function intersectAndAlias(indexFrom, indexTo, F, T) {\n    TRACE(\n      ' - intersectAndAlias; from index:',\n      indexFrom,\n      ', to index:',\n      indexTo,\n      ', F:',\n      domain__debug(F),\n      ', T:',\n      domain__debug(T),\n      ', FT:',\n      domain__debug(domain_intersection(F, T))\n    );\n    ASSERT(typeof indexFrom === 'number' && indexFrom >= 0, 'indexfrom check');\n    ASSERT(typeof indexTo === 'number' && indexTo >= 0, 'indexto check');\n    ASSERT(F && T, 'should not receive empty domains... catch this at caller');\n    ASSERT_NORDOM(F);\n    ASSERT_NORDOM(T);\n    ASSERT(getDomain(indexFrom) === F, 'F should match domain');\n    ASSERT(getDomain(indexTo) === T, 'T should match domain');\n\n    const FT = domain_intersection(F, T);\n    if (F !== T) {\n      updateDomain(indexTo, FT, 'intersectAndAlias');\n    }\n\n    if (FT && !domain_isSolved(F)) addAlias(indexFrom, indexTo);\n\n    return FT;\n  }\n\n  function min_plusWithSolvedArg(\n    sumOffset,\n    indexY,\n    indexX,\n    indexR,\n    X,\n    Y,\n    R,\n    vX,\n    nameX,\n    nameY\n  ) {\n    TRACE(\n      ' - min_plusWithSolvedArg',\n      nameX,\n      nameY,\n      domain__debug(R),\n      '=',\n      domain__debug(X),\n      '+',\n      domain__debug(Y)\n    );\n    ASSERT(vX >= 0, 'caller should assert that X is solved');\n    ASSERT(\n      domain_isSolved(Y) + domain_isSolved(R) === 0,\n      'caller should assert that only one of the three is solved'\n    );\n\n    if (vX === 0) {\n      TRACE(\n        ' -',\n        nameX,\n        '= 0, so R =',\n        nameY,\n        '+ 0, so R ==',\n        nameY,\n        ', morphing op to eq'\n      );\n      // Morph R=0+Y to R==Y\n\n      intersectAndAlias(indexR, indexY, R, Y);\n      ml_eliminate(ml, sumOffset, SIZEOF_CR_2);\n      varChanged = true;\n      return true;\n    }\n\n    // Try to morph R=x+Y to x=R==?Y when R has two values and Y is [0, 1] (because it cant be solved, so not 0 nor 1)\n    // R    = A + B           ->        B    = A ==? R    (when B is [01] and A is solved)\n    // [01] = 1 + [01]        ->        [01] = 1 !=? [0 1]\n    // [12] = 1 + [01]        ->        [01] = 1 !=? [1 2]\n    // [10 11] = 10 + [01]    ->        [01] = 10 !=? [10 11]\n    // rationale; B=bool means the solved value in A can only be A or\n    // A+1. when B=1 then R=A+1 and diff. when B=0 then R=A and eq.\n    // this only works when vX==max(R) because its either +0 or +1\n    if (domain_isBool(Y) && domain_size(R) === 2 && domain_min(R) === vX) {\n      TRACE(\n        ' - R = X + Y   ->   Y = X ==? R    (Y is [01] and X is solved to',\n        vX,\n        ')'\n      );\n      TRACE(\n        '   - R =',\n        vX,\n        '+',\n        nameY,\n        'to',\n        nameY,\n        '=',\n        vX,\n        domain_max(R) === vX ? '==?' : '!=? R'\n      );\n      TRACE(\n        '   -',\n        domain__debug(R),\n        '=',\n        vX,\n        '+',\n        domain__debug(Y),\n        'to ',\n        domain__debug(Y),\n        '=',\n        vX,\n        '==?',\n        domain__debug(R)\n      );\n      TRACE(\n        ' - morphing R=A+B to B=A!=?R with A solved and B=[01] and size(R)=2'\n      );\n      ml_cr2cr2(ml, sumOffset, 2, ML_ISDIFF, indexR, indexX, indexY);\n      varChanged = true;\n      return true;\n    }\n\n    TRACE('   - min_plusWithSolvedArg did nothing');\n    return false;\n  }\n\n  function min_minus(ml, offset) {\n    const offsetA = offset + 1;\n    const offsetB = offset + 3;\n    const offsetR = offset + 5;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    const indexR = readIndex(ml, offsetR);\n\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      ' = min_minus',\n      indexR,\n      '=',\n      indexA,\n      '-',\n      indexB,\n      '   ->   ',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '-',\n      domain__debug(B)\n    );\n    if (!A || !B || !R) return;\n\n    // C = A - B   -> A = B + C, B = C - A\n    // note: A - B = C   ==>   <loA - hiB, hiA - loB>\n    // but:  A + B = C   ==>   <loA + loB, hiA + hiB>   (so the lo/hi of B gets swapped!)\n    // keep in mind that any number oob <sub,sup> gets trimmed in either case.\n    // this trimming may affect \"valid\" numbers in the other domains so that needs back-propagation.\n\n    const ooA = A;\n    const ooB = B;\n    const ooR = R;\n\n    let oA;\n    let oB;\n    let oR;\n    let loops = 0;\n    do {\n      ++loops;\n      TRACE(\n        ' - minus propagation step...',\n        loops,\n        domain__debug(R),\n        '=',\n        domain__debug(A),\n        '+',\n        domain__debug(B)\n      );\n      oA = A;\n      oB = B;\n      oR = R;\n\n      R = domain_intersection(R, domain_minus(A, B));\n      A = domain_intersection(A, domain_plus(R, B));\n      B = domain_intersection(B, domain_minus(A, R));\n    } while (A !== oA || B !== oB || R !== oR);\n\n    TRACE(\n      ' ->',\n      'A:',\n      domain__debug(A),\n      'B:',\n      domain__debug(B),\n      'R:',\n      domain__debug(R)\n    );\n\n    if (loops > 1) {\n      if (A !== ooA) updateDomain(indexA, A, 'minus A');\n      if (B !== ooB) updateDomain(indexB, B, 'minus B');\n      if (R !== ooR) updateDomain(indexR, R, 'minus R');\n      if (!A || !B || !R) return;\n    }\n\n    ASSERT(\n      domain_isSolved(A) + domain_isSolved(B) + domain_isSolved(R) !== 2,\n      'if two vars are solved the third should be solved as well'\n    );\n\n    if (domain_isSolved(R) && domain_isSolved(A)) {\n      // MinR==maxR&&minA==maxA\n      ASSERT(\n        domain_isSolved(B),\n        'if two are solved then all three must be solved'\n      );\n      ml_eliminate(ml, offset, SIZEOF_VVV);\n    } else if (domain_getValue(A) === 0) {\n      // MaxA==0\n      TRACE(' - A=0 so B==R, aliasing R to B, eliminating constraint');\n      intersectAndAlias(indexR, indexB, R, B);\n      ml_eliminate(ml, offset, SIZEOF_VVV);\n      varChanged = true;\n    } else if (domain_getValue(B) === 0) {\n      // MaxB==0\n      TRACE(' - B=0 so A==R, aliasing R to A, eliminating constraint');\n      intersectAndAlias(indexR, indexA, R, A);\n      ml_eliminate(ml, offset, SIZEOF_VVV);\n      varChanged = true;\n    } else {\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + SIZEOF_VVV;\n    }\n  }\n\n  function min_product_2(ml, offset) {\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const offsetR = offset + OFFSET_C_R;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    const indexR = readIndex(ml, offsetR);\n\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      ' = min_product_2',\n      indexR,\n      '=',\n      indexA,\n      '*',\n      indexB,\n      '   ->   ',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '*',\n      domain__debug(B)\n    );\n    if (!A || !B || !R) {\n      TRACE(' - found empty domain, rejecting');\n      return true;\n    }\n\n    // C = A * B, B = C / A, A = C / B\n    // note: A * B = C   ==>   <loA * loB, hiA * hiB>\n    // but:  A / B = C   ==>   <loA / hiB, hiA / loB> and has rounding/div-by-zero issues! instead use \"inv-mul\" tactic\n    // keep in mind that any number oob <sub,sup> gets pruned in either case. x/0=0\n    // when dividing \"do the opposite\" of integer multiplication. 5/4=[] because there is no int x st 4*x=5\n    // only outer bounds are evaluated here...\n\n    const ooA = A;\n    const ooB = B;\n    const ooR = R;\n\n    let oA;\n    let oB;\n    let oR;\n    let loops = 0;\n    do {\n      ++loops;\n      TRACE(\n        ' - mul propagation step...',\n        loops,\n        domain__debug(R),\n        '=',\n        domain__debug(A),\n        '*',\n        domain__debug(B)\n      );\n      oA = A;\n      oB = B;\n      oR = R;\n\n      R = domain_intersection(R, domain_mul(A, B));\n      A = domain_intersection(A, domain_invMul(R, B));\n      B = domain_intersection(B, domain_invMul(R, A));\n    } while (A !== oA || B !== oB || R !== oR);\n\n    TRACE(\n      ' ->',\n      'A:',\n      domain__debug(A),\n      'B:',\n      domain__debug(B),\n      'R:',\n      domain__debug(R)\n    );\n\n    if (loops > 1) {\n      if (A !== ooA) updateDomain(indexA, A, 'mul A');\n      if (B !== ooB) updateDomain(indexB, B, 'mul B');\n      if (R !== ooR) updateDomain(indexR, R, 'mul R');\n      if (!A || !B || !R) {\n        TRACE(' - found empty domain, rejecting');\n        return true;\n      }\n    }\n\n    ASSERT(\n      domain_isSolved(A) + domain_isSolved(B) + domain_isSolved(R) !== 2 ||\n        domain_getValue(R) === 0,\n      'if two vars are solved the third should be solved as well unless R is 0'\n    );\n\n    if (domain_isSolved(R) && domain_isSolved(A)) {\n      TRACE(\n        ' - A B R all solved, eliminating constraint; ABR:',\n        domain__debug(A),\n        domain__debug(B),\n        domain__debug(R)\n      );\n      ASSERT(\n        domain_isZero(R) || domain_isSolved(B),\n        'if two are solved then all three must be solved or R is zero'\n      );\n      ml_eliminate(ml, offset, SIZEOF_CR_2, true);\n      return true;\n    }\n\n    TRACE('   - min_product_2 did not do anything');\n    return false;\n  }\n\n  function min_div(ml, offset) {\n    const offsetA = offset + 1;\n    const offsetB = offset + 3;\n    const offsetR = offset + 5;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    const indexR = readIndex(ml, offsetR);\n\n    const A = getDomainFast(indexA);\n    const B = getDomainFast(indexB);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      ' = min_div',\n      indexR,\n      '=',\n      indexA,\n      '*',\n      indexB,\n      '   ->   ',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '/',\n      domain__debug(B)\n    );\n    if (!A || !B || !R) return;\n\n    // R = A / B, A = R * B, B = A / R\n    // note:  A / B = C   ==>   <loA / hiB, hiA / loB> and has rounding/div-by-zero issues!\n    // but: A * B = C   ==>   <loA * loB, hiA * hiB> use \"inv-div\" tactic\n    // basically remove any value from the domains that can not lead to a valid integer result A/B=C\n\n    TRACE(\n      ' - div propagation step...',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '/',\n      domain__debug(B)\n    );\n    const oR = R;\n    R = domain_intersection(R, domain_divby(A, B));\n    TRACE(\n      ' ->',\n      'R:',\n      domain__debug(R),\n      '=',\n      'A:',\n      domain__debug(A),\n      '/',\n      'B:',\n      domain__debug(B)\n    );\n\n    if (R !== oR) updateDomain(indexR, R, 'div R');\n    if (!A || !B || !R) return;\n\n    TRACE(\n      ' - domains;',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '/',\n      domain__debug(B)\n    );\n    if (domain_isSolved(B) && domain_isSolved(A)) {\n      ASSERT(\n        domain_isSolved(R),\n        'if A and B are solved then R should be solved'\n      );\n      ml_eliminate(ml, offset, SIZEOF_VVV);\n    } else {\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + SIZEOF_VVV;\n    }\n  }\n\n  function min_isSame(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(' = min_isSame, arg count:', argCount);\n\n    if (argCount !== 2) {\n      TRACE(' - argcount !== 2 so bailing for now');\n\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + SIZEOF_C + argCount * 2 + 2;\n      return;\n    }\n\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const offsetR = offset + OFFSET_C_R;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    const indexR = readIndex(ml, offsetR);\n\n    const A = getDomainFast(indexA);\n    const B = getDomainFast(indexB);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      ' - min_isSame',\n      indexR,\n      '=',\n      indexA,\n      '==?',\n      indexB,\n      '   ->   ',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '==?',\n      domain__debug(B)\n    );\n    if (!A || !B || !R) return;\n\n    if (indexA === indexB) {\n      TRACE(' - indexA == indexB so forcing R to 1 and removing constraint');\n      const oR = R;\n      R = domain_removeValue(R, 0);\n      if (R !== oR) updateDomain(indexR, R, 'issame R: A!=B');\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n      ml_eliminate(ml, offset, SIZEOF_CR_2);\n      return;\n    }\n\n    const vA = domain_getValue(A);\n    const vB = domain_getValue(B);\n\n    if (vA >= 0 && vB >= 0) {\n      TRACE(\n        ' - A and B are solved so we can determine R and eliminate the constraint'\n      );\n\n      const oR = R;\n      if (A === B) {\n        R = domain_removeValue(R, 0);\n        if (R !== oR) updateDomain(indexR, R, 'issame R: A==B');\n      } else {\n        R = domain_intersectionValue(R, 0);\n        if (R !== oR) updateDomain(indexR, R, 'issame R: A!=B');\n      }\n\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n      ml_eliminate(ml, offset, SIZEOF_CR_2);\n      return;\n    }\n\n    // A and B arent both solved. check R\n    if (domain_isZero(R)) {\n      TRACE(\n        ' ! R=0 while A or B isnt solved, changing issame to diff and revisiting'\n      );\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n      ml_cr2c2(ml, offset, 2, ML_DIFF, indexA, indexB);\n      varChanged = true;\n      return;\n    }\n\n    if (domain_hasNoZero(R)) {\n      TRACE(\n        ' ! R>=1 while A or B isnt solved, aliasing A to B, eliminating constraint'\n      );\n      intersectAndAlias(indexA, indexB, A, B);\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n      ml_eliminate(ml, offset, SIZEOF_CR_2);\n      varChanged = true;\n      return;\n    }\n\n    if (indexA === indexB) {\n      TRACE(\n        ' ! index A === index B so R should be truthy and we can eliminate the constraint'\n      );\n      const oR = R;\n      R = domain_removeValue(R, 0);\n      if (R !== oR) updateDomain(indexR, R, 'issame R: A==B');\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n      ml_eliminate(ml, offset, SIZEOF_CR_2);\n      return;\n    }\n\n    if (!domain_intersection(A, B)) {\n      TRACE(\n        ' - no overlap between',\n        indexA,\n        'and',\n        indexB,\n        ' (',\n        domain__debug(A),\n        domain__debug(B),\n        ') so R becomes 0 and constraint is removed'\n      );\n      const oR = R;\n      R = domain_removeGtUnsafe(R, 0);\n      if (R !== oR) updateDomain(indexR, R, 'issame; no overlap A B so R=0');\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n      ml_eliminate(ml, offset, SIZEOF_CR_2);\n      return;\n    }\n\n    // There are some bool-domain-specific tricks we can apply\n    // TODO: shouldnt these also confirm that A and/or B are actually solved? and not -1\n    if (domain_isBool(R)) {\n      // If A=0|1, B=[0 1], R=[0 1] we can recompile this to DIFF or SAME\n      if (vA >= 0 && vA <= 1 && domain_isBool(B)) {\n        TRACE(' ! [01]=0|1==?[01] so morphing to n/eq and revisiting');\n        ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n        // - A=0: 0==A=1, 1==A=0: B!=R\n        // - A=1: 0==A=0, 1==A=1: B==R\n        if (vA === 0) {\n          TRACE('   - morphing constraint to diff');\n          ml_cr2c2(ml, offset, 2, ML_DIFF, indexB, indexR);\n        } else {\n          TRACE('   - aliasing R to B, eliminating constraint');\n          intersectAndAlias(indexR, indexB, R, B);\n          ml_eliminate(ml, offset, SIZEOF_CR_2);\n        }\n\n        varChanged = true;\n        return;\n      }\n\n      // If A=[0 1], B=0|1, R=[0 1] we can recompile this to DIFF or SAME\n      if (vB >= 0 && vB <= 1 && domain_isBool(A)) {\n        TRACE(' ! [01]=[01]==?0|1 so morphing to n/eq and revisiting');\n        ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n        // - B=0: 0==B=1, 1==B=0: A!=R\n        // - B=1: 0==B=0, 1==B=1: A==R\n        if (vB === 0) {\n          TRACE('   - morphing constraint to diff');\n          ml_cr2c2(ml, offset, 2, ML_DIFF, indexA, indexR);\n        } else {\n          TRACE('   - aliasing R to A, eliminating constraint');\n          intersectAndAlias(indexR, indexA, R, A);\n          ml_eliminate(ml, offset, SIZEOF_CR_2);\n        }\n\n        varChanged = true;\n        return;\n      }\n\n      // Note: cant do XNOR trick here because that only works on BOOLY vars\n    }\n\n    if (vA === 0) {\n      // This means R^B\n      TRACE(' ! A=0 so R^B, morphing to xor');\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n      ml_cr2c2(ml, offset, 2, ML_XOR, indexR, indexB);\n      varChanged = true;\n      return;\n    }\n\n    if (vB === 0) {\n      // This means R^A\n      TRACE(' ! B=0 so R^A, morphing to xor');\n      ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n      ml_cr2c2(ml, offset, 2, ML_XOR, indexR, indexA);\n      varChanged = true;\n      return;\n    }\n\n    TRACE(\n      ' ->',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '==?',\n      domain__debug(B)\n    );\n    ASSERT(\n      domain_min(R) === 0 && domain_max(R) > 0,\n      'R should be a booly at this point',\n      domain__debug(R)\n    );\n\n    TRACE(' - not only jumps...');\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'arg count should be 2 here');\n    onlyJumps = false;\n    pc = offset + SIZEOF_CR_2;\n  }\n\n  function min_isDiff(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(' = min_isDiff; argCount=', argCount);\n\n    if (argCount !== 2) {\n      TRACE(' - count != 2, bailing for now');\n\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + SIZEOF_C + argCount * 2 + 2;\n      return;\n    }\n\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const offsetR = offset + OFFSET_C_R;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    const indexR = readIndex(ml, offsetR);\n\n    const A = getDomainFast(indexA);\n    const B = getDomainFast(indexB);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      ' = min_isDiff',\n      indexR,\n      '=',\n      indexA,\n      '!=?',\n      indexB,\n      '   ->   ',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '!=?',\n      domain__debug(B)\n    );\n    if (!A || !B || !R) return;\n\n    if (domain_isSolved(A) && domain_isSolved(B)) {\n      TRACE(' - A and B are solved so we can determine R');\n      const oR = R;\n      if (A === B) {\n        R = domain_removeGtUnsafe(R, 0);\n        if (R !== oR) updateDomain(indexR, R, 'isdiff R; A==B');\n      } else {\n        R = domain_removeValue(R, 0);\n        if (R !== oR) updateDomain(indexR, R, 'isdiff R; A!=B');\n      }\n\n      ml_eliminate(ml, offset, SIZEOF_CR_2);\n      return;\n    }\n\n    // R should be 0 if A==B. R should be >0 if A!==B\n    if (domain_isZero(R)) {\n      TRACE(' ! R=0, aliasing A to B, eliminating constraint');\n      intersectAndAlias(indexA, indexB, A, B);\n      ml_eliminate(ml, offset, SIZEOF_CR_2);\n      varChanged = true;\n      return;\n    }\n\n    if (domain_hasNoZero(R)) {\n      TRACE(' ! R>0, changing isdiff to diff and revisiting');\n      ml_cr2c2(ml, offset, 2, ML_DIFF, indexA, indexB);\n      varChanged = true;\n      return;\n    }\n\n    TRACE(\n      ' ->',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '!=?',\n      domain__debug(B)\n    );\n    TRACE(' - not only jumps...');\n    ASSERT(\n      domain_min(R) === 0 && domain_max(R) >= 1,\n      'R should be boolable at this point'\n    );\n    onlyJumps = false;\n    pc = offset + SIZEOF_CR_2;\n  }\n\n  function min_isLt(ml, offset) {\n    const offsetA = offset + 1;\n    const offsetB = offset + 3;\n    const offsetR = offset + 5;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    const indexR = readIndex(ml, offsetR);\n\n    const A = getDomainFast(indexA);\n    const B = getDomainFast(indexB);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      ' = min_isLt',\n      indexR,\n      '=',\n      indexA,\n      '<?',\n      indexB,\n      '   ->   ',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '<?',\n      domain__debug(B)\n    );\n    if (!A || !B || !R) return;\n\n    const oR = R;\n    if (!domain_isSolved(R)) {\n      if (domain_max(A) < domain_min(B)) R = domain_removeValue(R, 0);\n      else if (domain_min(A) >= domain_max(B)) R = domain_removeGtUnsafe(R, 0);\n    }\n\n    if (\n      R !== oR &&\n      !updateDomain(indexR, R, 'islt; solving R because A < B or A >= B')\n    )\n      return;\n\n    // If R is solved replace this isLt with an lt or \"gt\" and repeat.\n    // the appropriate op can then prune A and B accordingly.\n    // in this context, the inverse for lt is an lte with swapped args\n\n    if (domain_isZero(R)) {\n      TRACE(\n        ' ! result var solved to 0 so compiling an lte with swapped args in its place',\n        indexB,\n        'and',\n        indexA\n      );\n      ml_vvv2c2(ml, offset, ML_LTE, indexB, indexA);\n      varChanged = true;\n      return;\n    }\n\n    if (domain_hasNoZero(R)) {\n      TRACE(\n        ' ! result var solved to 1 so compiling an lt in its place for',\n        indexA,\n        'and',\n        indexB\n      );\n      ml_vvv2c2(ml, offset, ML_LT, indexA, indexB);\n      varChanged = true;\n      return;\n    }\n\n    if (domain_isZero(A)) {\n      TRACE(\n        ' - A=0 ! R=0<?B [01]=0<?[0 10] so if B=0 then R=0 and otherwise R=1 so xnor'\n      );\n      TRACE_MORPH('R=0<?B', 'R!^B');\n      ml_vvv2c2(ml, offset, ML_XNOR, indexR, indexB);\n      varChanged = true;\n      return;\n    }\n\n    if (domain_isZero(B)) {\n      TRACE(' - B=0 ! so thats just false');\n      TRACE_MORPH('R=A<?0', 'R=0');\n      ml_eliminate(ml, offset, SIZEOF_VVV);\n      return;\n    }\n\n    TRACE(' - not only jumps...');\n    onlyJumps = false;\n    pc = offset + SIZEOF_VVV;\n  }\n\n  function min_isLte(ml, offset) {\n    const offsetA = offset + 1;\n    const offsetB = offset + 3;\n    const offsetR = offset + 5;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    const indexR = readIndex(ml, offsetR);\n\n    const A = getDomainFast(indexA);\n    const B = getDomainFast(indexB);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      ' = min_isLte',\n      indexR,\n      '=',\n      indexA,\n      '<=?',\n      indexB,\n      '   ->   ',\n      domain__debug(R),\n      '=',\n      domain__debug(A),\n      '<=?',\n      domain__debug(B)\n    );\n    if (!A || !B || !R) return;\n\n    const oR = R;\n    TRACE(' - max(A) <= min(B)?', domain_max(A), '<=', domain_min(B));\n    TRACE(' - min(A) > max(B)?', domain_min(A), '>', domain_max(B));\n    // If R isn't resolved you can't really update A or B. so we don't.\n    if (domain_max(A) <= domain_min(B)) R = domain_removeValue(R, 0);\n    else if (domain_min(A) > domain_max(B)) R = domain_removeGtUnsafe(R, 0);\n    if (R !== oR) {\n      TRACE(' - updated R to', domain__debug(R));\n      if (\n        updateDomain(indexR, R, 'islte; solving R because A and B are solved')\n      )\n        return;\n    }\n\n    const falsyR = domain_isZero(R);\n    const truthyR = falsyR ? false : domain_hasNoZero(R);\n\n    // If R is resolved replace this isLte with an lte or \"gte\" and repeat.\n    // the appropriate op can then prune A and B accordingly.\n    // in this context, the logical inverse for lte is an lt with swapped args\n\n    if (falsyR) {\n      TRACE(\n        ' ! result var solved to 0 so compiling an lt with swapped args in its place',\n        indexB,\n        'and',\n        indexA\n      );\n      ml_vvv2c2(ml, offset, ML_LT, indexB, indexA);\n      varChanged = true;\n      return;\n    }\n\n    if (truthyR) {\n      TRACE(\n        ' ! result var solved to 1 so compiling an lte in its place',\n        indexA,\n        'and',\n        indexB\n      );\n      ml_vvv2c2(ml, offset, ML_LTE, indexA, indexB);\n      varChanged = true;\n      return;\n    }\n\n    // TODO: C=A<=?B   ->   [01] = [11] <=? [0 n]   ->   B !^ C\n\n    if (domain_isBool(R) && domain_max(A) <= 1 && domain_max(B) <= 1) {\n      TRACE(\n        ' - R is bool and A and B are bool-bound so checking bool specific cases'\n      );\n      ASSERT(\n        !domain_isZero(A) || !domain_isBool(B),\n        'this case should be caught by max<min checks above'\n      );\n\n      if (domain_isBool(A) && domain_isZero(B)) {\n        TRACE_MORPH('[01] = [01] <=? 0', 'A != R');\n        ml_vvv2c2(ml, offset, ML_DIFF, indexA, indexR);\n        varChanged = true;\n        return;\n      }\n\n      if (domain_isBool(A) && B === domain_createValue(1)) {\n        TRACE_MORPH('[01] = [01] <=? 1', 'A == R');\n        intersectAndAlias(indexA, indexR, A, R);\n        ml_eliminate(ml, offset, SIZEOF_VVV);\n        varChanged = true;\n        return;\n      }\n\n      if (domain_isBool(B) && A === domain_createValue(1)) {\n        TRACE_MORPH('[01] = 1 <=? [01]', 'B == R');\n        intersectAndAlias(indexB, indexR, B, R);\n        ml_eliminate(ml, offset, SIZEOF_VVV);\n        varChanged = true;\n        return;\n      }\n    }\n\n    TRACE(' - not only jumps...');\n    onlyJumps = false;\n    pc = offset + SIZEOF_VVV;\n  }\n\n  function min_sum(ml, offset) {\n    const offsetCount = offset + 1;\n    let argCount = ml_dec16(ml, offsetCount);\n\n    if (argCount === 2) {\n      if (min_sum_2(ml, offset)) return; // TOFIX: merge with this function...?\n    }\n\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n    const offsetArgs = offset + SIZEOF_C;\n    const offsetR = offset + opSize - 2;\n\n    const indexR = readIndex(ml, offsetR);\n    let R = getDomainFast(indexR);\n\n    TRACE(' = min_sum', argCount, 'x');\n    TRACE('  - ml for this sum:', ml.slice(offset, offset + opSize).join(' '));\n    TRACE(\n      '  - indexes:',\n      indexR,\n      '= sum(',\n      [...Array(argCount)]\n        .map((n, i) => readIndex(ml, offsetArgs + i * 2))\n        .join(', '),\n      ')'\n    );\n    TRACE(\n      '  - domains:',\n      domain__debug(R),\n      '= sum(',\n      [...Array(argCount)]\n        .map((n, i) =>\n          domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n        )\n        .join(', '),\n      ')'\n    );\n\n    if (!R) return;\n\n    // A sum is basically a pyramid of plusses; (A+B)+(C+D) etc\n    // we loop back to front because we're splicing out vars while looping\n\n    // replace all constants by one constant\n    // prune the result var by intersecting it with the sum of the actual args\n    // in limited cases we can prune some of the arg values if the result forces\n    // that (if the result is max 10 then inputs can be pruned of any value > 10)\n    // we cant really do anything else\n\n    TRACE(' - first loop to get the sum of the args and constants');\n    let sum = domain_createValue(0);\n    let constants = 0;\n    let constantSum = 0;\n    for (let i = 0; i < argCount; ++i) {\n      const argOffset = offsetArgs + i * 2;\n      const index = readIndex(ml, argOffset);\n      const domain = getDomainFast(index);\n      TRACE(\n        '    - i=',\n        i,\n        ', offset=',\n        argOffset,\n        ', index=',\n        index,\n        'dom=',\n        domain__debug(domain),\n        ', constants before:',\n        constants,\n        'sum of constant before:',\n        constantSum\n      );\n      const v = domain_getValue(domain);\n      if (v >= 0) {\n        TRACE('      - this is a constant! value =', v);\n        ++constants;\n        constantSum += v;\n      }\n\n      sum = domain_plus(sum, domain);\n    }\n\n    TRACE(\n      ' - total sum=',\n      domain__debug(sum),\n      ', constantSum=',\n      constantSum,\n      'with',\n      constants,\n      'constants. applying to R',\n      domain__debug(R),\n      '=>',\n      domain__debug(domain_intersection(sum, R))\n    );\n\n    const oR = R;\n\n    if (constants === argCount) {\n      // Bit of an edge case, though it can happen after multiple passes\n      TRACE(\n        ' - all sum args are constants so R must simply eq their sum, eliminating constraint'\n      );\n      R = domain_intersectionValue(R, constantSum);\n      if (R !== oR) updateDomain(indexR, R, 'setting R to sum of constants');\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    R = domain_intersection(sum, R);\n    TRACE(' - Updated R from', domain__debug(oR), 'to', domain__debug(R));\n    if (\n      R !== oR &&\n      updateDomain(indexR, R, 'sum; updating R with outer bounds of its args;')\n    )\n      return;\n\n    ASSERT(\n      constantSum <= domain_max(R),\n      'the sum of constants should not exceed R',\n      constantSum\n    );\n\n    // Get R without constants to apply to var args\n    const subR = constantSum\n      ? domain_minus(R, domain_createValue(constantSum))\n      : R;\n    ASSERT(subR, 'R-constants should not be empty', constantSum);\n\n    TRACE(\n      ' - Now back propagating R to the args. R-constants:',\n      domain__debug(subR)\n    );\n\n    // Have to count constants and sum again because if a var occurs twice and this\n    // updates it to a constant, the second one would otherwise be missed as old.\n    constants = 0;\n    constantSum = 0;\n\n    // We can only trim bounds, not a full intersection (!)\n    // note that trimming may lead to more constants so dont eliminate them here (KIS)\n    const minSR = domain_min(subR);\n    const maxSR = domain_max(subR);\n    let varIndex1 = -1; // Track non-constants for quick optimizations for one or two vars\n    let varIndex2 = -1;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n      TRACE('    - i=', i, ', index=', index, 'dom=', domain__debug(domain));\n      let v = domain_getValue(domain);\n      if (v >= 0) {\n        TRACE(\n          '      - old constant (or var that occurs twice and is now a new constant)',\n          v\n        );\n        ++constants;\n        constantSum += v;\n      } else {\n        // So the idea is that any value in an arg that could not even appear in R if all other args\n        // were zero, is a value that cant ever yield a solution. those are the values we trim here.\n        // this process takes constants in account (hence subR) because they don't have a choice.\n        let newDomain = domain_removeLtUnsafe(domain, minSR);\n        newDomain = domain_removeGtUnsafe(domain, maxSR);\n        if (\n          newDomain !== domain &&\n          updateDomain(index, newDomain, 'plus arg; trim invalid values')\n        )\n          return;\n\n        v = domain_getValue(newDomain);\n        if (v >= 0) {\n          TRACE('      - new constant', v);\n          // Arg is NOW also a constant\n          ++constants;\n          constantSum += v;\n        } else if (varIndex1 === -1) {\n          TRACE('      - first non-constant');\n          varIndex1 = index;\n        } else if (varIndex2 === -1) {\n          TRACE('      - second non-constant');\n          varIndex2 = index;\n        }\n      }\n    }\n\n    TRACE(\n      ' -> There are now',\n      constants,\n      'constants and',\n      argCount - constants,\n      'actual vars. Constants sum to',\n      constantSum,\n      ', R=',\n      domain__debug(R)\n    );\n    TRACE(\n      ' -> Current args: ',\n      [...Array(argCount)]\n        .map((n, i) =>\n          domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n        )\n        .join(' '),\n      ' Result:',\n      domain__debug(R)\n    );\n\n    const valuesToSumLeft = argCount - constants + (constantSum === 0 ? 0 : 1);\n\n    TRACE(\n      ' - args:',\n      argCount,\n      ', constants:',\n      constants,\n      ', valuesToSumLeft=',\n      valuesToSumLeft,\n      ', constantSum=',\n      constantSum,\n      ', varIndex1=',\n      varIndex1,\n      ', varIndex2=',\n      varIndex2\n    );\n    ASSERT(\n      valuesToSumLeft > 0 || (constantSum === 0 && argCount === constants),\n      'a sum with args cant have no values left here unless there are only zeroes (it implies empty domains and should incur early returns)',\n      valuesToSumLeft\n    );\n\n    if (valuesToSumLeft === 1) {\n      // ignore constants if they are zero!\n      TRACE(' - valuesToSumLeft = 1');\n      ASSERT(\n        varIndex2 === -1,\n        'we shouldnt have found a second var',\n        varIndex2\n      );\n      ASSERT(\n        constantSum > 0 ? varIndex1 === -1 : varIndex1 >= 0,\n        'with one value left it should either be a nonzero constant or an actual variable'\n      );\n      if (constantSum > 0) {\n        TRACE(' - Setting R to the sum of constants:', constantSum);\n        const nR = domain_intersectionValue(R, constantSum);\n        if (nR !== R) updateDomain(indexR, nR, 'min_sum');\n      } else {\n        TRACE(' - Aliasing R to the single var', varIndex1);\n        intersectAndAlias(indexR, varIndex1, R, getDomain(varIndex1, true));\n      }\n\n      TRACE(' - eliminating constraint now');\n      ml_eliminate(ml, offset, opSize);\n    } else if (constants > 1 || (constants === 1 && constantSum === 0)) {\n      TRACE(\n        ' - valuesToSumLeft > 1. Unable to morph but there are',\n        constants,\n        'constants to collapse to a single arg with value',\n        constantSum\n      );\n      // There are constants and they did not morph or eliminate the constraint; consolidate them.\n      // loop backwards, remove all constants except one, move all other args back to compensate,\n      // only update the index of the last constant, update the count, compile a jump for the new trailing space\n\n      const newOpSize = opSize - (constants - (constantSum > 0 ? 1 : 0)) * 2;\n\n      for (let i = argCount - 1; i >= 0 && constants; --i) {\n        const argOffset = offsetArgs + i * 2;\n        const index = readIndex(ml, argOffset);\n        const domain = getDomainFast(index);\n        TRACE('    - i=', i, ', index=', index, 'dom=', domain__debug(domain));\n        if (domain_isSolved(domain)) {\n          if (constants === 1 && constantSum !== 0) {\n            // If constantSum>0 then we should encounter at least one constant to do this step on\n            TRACE(\n              '      - Overwriting the last constant at',\n              argOffset,\n              'with an index for total constant value',\n              constantSum\n            );\n            const newConstantIndex = addVar(\n              undefined,\n              constantSum,\n              false,\n              false,\n              true\n            );\n            ml_enc16(ml, offsetArgs + i * 2, newConstantIndex);\n            break; // Probably not that useful, might even be bad to break here\n          } else {\n            TRACE(\n              '      - found a constant to remove at',\n              argOffset,\n              ', moving further domains one space forward (from ',\n              i + 1,\n              ' / ',\n              argCount,\n              ')',\n              i + 1 < argCount\n            );\n            ASSERT(constants > 0, 'should have some constants');\n            min_spliceArgSlow(ml, offsetArgs, argCount, i, true); // Also moves R\n            --argCount;\n          }\n\n          --constants;\n        }\n      }\n\n      ml_enc16(ml, offset + 1, argCount);\n      // Now \"blank out\" the space of eliminated constants, they should be at the end of the op\n      ml_compileJumpSafe(ml, offset + newOpSize, opSize - newOpSize);\n\n      TRACE(' - Cleaned up constant args');\n      TRACE(\n        ' - ml for this sum now:',\n        ml.slice(offset, offset + opSize).join(' ')\n      );\n    } else {\n      TRACE(' - unable to improve this sum at this time');\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + opSize;\n    }\n  }\n\n  function min_spliceArgSlow(\n    ml,\n    argsOffset,\n    argCount,\n    argIndex,\n    includingResult\n  ) {\n    TRACE(\n      '      - min_spliceArgSlow(',\n      argsOffset,\n      argCount,\n      argIndex,\n      includingResult,\n      ')'\n    );\n    let toCopy = argCount;\n    if (includingResult) ++toCopy;\n    for (let i = argIndex + 1; i < toCopy; ++i) {\n      const fromOffset = argsOffset + i * 2;\n      const toOffset = argsOffset + (i - 1) * 2;\n      TRACE(\n        '        - moving',\n        includingResult && i === argCount - 1\n          ? 'R'\n          : 'arg ' + (i + (includingResult ? 0 : 1)) + '/' + argCount,\n        'at',\n        fromOffset,\n        'and',\n        fromOffset + 1,\n        'moving to',\n        toOffset,\n        'and',\n        toOffset + 1\n      );\n      ml[toOffset] = ml[fromOffset];\n      ml[toOffset + 1] = ml[fromOffset + 1];\n    }\n  }\n\n  function min_product(ml, offset) {\n    const offsetCount = offset + 1;\n    let argCount = ml_dec16(ml, offsetCount);\n\n    TRACE(' = min_product', argCount, 'x');\n\n    if (argCount === 2) {\n      // TODO: merge this\n      if (min_product_2(ml, offset)) return;\n    }\n\n    const opSize = SIZEOF_C + argCount * 2 + 2;\n    const offsetArgs = offset + SIZEOF_C;\n    const offsetR = offset + opSize - 2;\n\n    const indexR = readIndex(ml, offsetR);\n    let R = getDomainFast(indexR);\n\n    TRACE(\n      '  - ml for this product:',\n      ml.slice(offset, offset + opSize).join(' ')\n    );\n    TRACE(\n      '  - indexes:',\n      indexR,\n      '= product(',\n      [...Array(argCount)]\n        .map((n, i) => readIndex(ml, offsetArgs + i * 2))\n        .join(', '),\n      ')'\n    );\n    TRACE(\n      '  - domains:',\n      domain__debug(R),\n      '= product(',\n      [...Array(argCount)]\n        .map((n, i) =>\n          domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n        )\n        .join(', '),\n      ')'\n    );\n\n    if (!R) return;\n\n    // A product is basically a pyramid of muls; (A*B)*(C*D) etc\n    // we loop back to front because we're splicing out vars while looping\n\n    // replace all constants by one constant\n    // prune the result var by intersecting it with the product of the actual args\n    // in limited cases we can prune some of the arg values if the result forces\n    // that (if the result is max 10 then inputs can be pruned of any value > 10)\n    // we cant really do anything else\n\n    TRACE(' - first loop to get the product of the args and constants');\n    let product = domain_createValue(1);\n    let constants = 0;\n    let constantProduct = 1;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n      TRACE(\n        '    - i=',\n        i,\n        ', index=',\n        index,\n        'dom=',\n        domain__debug(domain),\n        ', constant product before:',\n        constantProduct\n      );\n      const v = domain_getValue(domain);\n      if (v >= 0) {\n        ++constants;\n        constantProduct *= v;\n      }\n\n      product = domain_mul(product, domain);\n    }\n\n    TRACE(\n      ' - total product=',\n      domain__debug(product),\n      ', constantProduct=',\n      constantProduct,\n      'with',\n      constants,\n      'constants. applying to R',\n      domain__debug(R),\n      '=',\n      domain__debug(domain_intersection(product, R))\n    );\n\n    const oR = R;\n\n    if (constants === argCount) {\n      // Bit of an edge case, though it can happen after multiple passes\n      TRACE(\n        ' - all product args are constants so R must simply eq their product, eliminating constraint;',\n        domain__debug(R),\n        '&',\n        domain__debug(domain_createValue(constantProduct)),\n        '=',\n        domain__debug(domain_intersectionValue(R, constantProduct))\n      );\n      R = domain_intersectionValue(R, constantProduct);\n      if (R !== oR)\n        updateDomain(indexR, R, 'setting R to product of constants');\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    if (constantProduct === 0) {\n      // Edge case; if a constant produced zero then R will be zero and all args are free\n      TRACE(\n        ' - there was a zero constant so R=0 and all args are free, eliminating constraint'\n      );\n      R = domain_intersectionValue(R, 0);\n      if (R !== oR) updateDomain(indexR, R, 'setting R to zero');\n      ml_eliminate(ml, offset, opSize);\n      return;\n    }\n\n    R = domain_intersection(product, R);\n    TRACE(' - Updated R from', domain__debug(oR), 'to', domain__debug(R));\n    if (\n      R !== oR &&\n      updateDomain(\n        indexR,\n        R,\n        'product; updating R with outer bounds of its args;'\n      )\n    )\n      return;\n\n    if (domain_isZero(R)) {\n      TRACE(' - R=0 so at least one arg must be 0, morph this to a nall');\n      ml_enc8(ml, offset, ML_NALL);\n      ml_compileJumpSafe(ml, offset + opSize - 2, 2); // Cuts off R\n      return;\n    }\n\n    // From this point R isnt zero and none of the args is solved to zero (but could still have it in their domain!)\n    // this simplifies certain decisions :)\n\n    ASSERT(\n      domain_invMul(R, constantProduct),\n      'R should be a multiple of the constant sum'\n    );\n    ASSERT(\n      domain_min(R) === 0 || Number.isFinite(domain_min(R) / constantProduct),\n      'min(R) should be the result of the constants multiplied by other values, so dividing it should result in an integer'\n    );\n    ASSERT(\n      Number.isFinite(domain_max(R) / constantProduct),\n      'max(R) should be the result of the constants multiplied by other values, so dividing it should result in an integer'\n    );\n\n    // Get R without constants to apply to var args\n    const subR =\n      constantProduct === 1\n        ? R\n        : domain_invMul(R, domain_createValue(constantProduct));\n    ASSERT(subR, 'R-constants should not be empty');\n\n    TRACE(\n      ' - Now back propagating R to the args, R without constants:',\n      domain__debug(subR)\n    );\n\n    // We can only trim bounds, not a full intersection (!)\n    // note that trimming may lead to more constants so dont eliminate them here (KIS)\n    const minSR = domain_min(subR);\n    const maxSR = domain_max(subR);\n    let atLeastOneArgHadZero = false; // Any zero can blow up the result to 0, regardless of other args\n    let varIndex1 = -1; // Track non-constants for quick optimizations for one or two vars\n    let varIndex2 = -1;\n    for (let i = 0; i < argCount; ++i) {\n      const index = readIndex(ml, offsetArgs + i * 2);\n      const domain = getDomainFast(index);\n      TRACE('    - i=', i, ', index=', index, 'dom=', domain__debug(domain));\n      let v = domain_getValue(domain);\n      if (v === 0) atLeastOneArgHadZero = true; // Probably not very useful\n      if (v < 0) {\n        // ignore constants\n        if (!atLeastOneArgHadZero && domain_hasZero(domain))\n          atLeastOneArgHadZero = true;\n        // So the idea is that any value in an arg that could not even appear in R if all other args\n        // were zero, is a value that cant ever yield a solution. those are the values we trim here.\n        // this process takes constants in account (hence subR) because they don't have a choice.\n        let newDomain = domain_removeLtUnsafe(domain, minSR);\n        newDomain = domain_removeGtUnsafe(domain, maxSR);\n        if (\n          newDomain !== domain &&\n          updateDomain(index, newDomain, 'product arg; trim invalid values')\n        )\n          return;\n\n        v = domain_getValue(newDomain);\n        if (v >= 0) {\n          TRACE('      - constant', v);\n          // Arg is NOW also a constant\n          ++constants;\n          constantProduct += v;\n        } else if (varIndex1 === -1) {\n          TRACE('      - first non-constant');\n          varIndex1 = index;\n        } else if (varIndex2 === -1) {\n          TRACE('      - second non-constant');\n          varIndex2 = index;\n        }\n      }\n    }\n\n    TRACE(\n      ' -> There are now',\n      constants,\n      'constants and',\n      argCount - constants,\n      'actual vars. Constants mul to',\n      constantProduct,\n      ', R=',\n      domain__debug(R)\n    );\n    TRACE(\n      ' -> Current args: ',\n      [...Array(argCount)]\n        .map((n, i) =>\n          domain__debug(getDomainFast(readIndex(ml, offsetArgs + i * 2)))\n        )\n        .join(' '),\n      ' Result:',\n      domain__debug(R)\n    );\n\n    const valuesToMulLeft =\n      argCount - constants + (constantProduct === 1 ? 0 : 1);\n    ASSERT(\n      valuesToMulLeft > 0 || (constantProduct === 1 && argCount === constants),\n      'a product with args cant have no values left here unless the constants are all 1 (it implies empty domains and should incur early returns)',\n      valuesToMulLeft\n    );\n\n    if (valuesToMulLeft === 1) {\n      // ignore constants if they are zero!\n      ASSERT(\n        varIndex2 === -1,\n        'we shouldnt have found a second var',\n        varIndex2\n      );\n\n      if (constantProduct !== 1) {\n        TRACE(\n          ' - Setting R to the product of constants:',\n          constantProduct,\n          '(and a zero?',\n          atLeastOneArgHadZero,\n          ')'\n        );\n        if (atLeastOneArgHadZero) {\n          TRACE(\n            '   - Updating to a booly-pair:',\n            domain__debug(domain_createBoolyPair(constantProduct))\n          );\n          const nR = domain_intersection(\n            R,\n            domain_createBoolyPair(constantProduct)\n          );\n          if (nR !== R) updateDomain(indexR, nR, 'min_product');\n        } else {\n          TRACE('   - Updating to a solved value:', constantProduct);\n          const nR = domain_intersectionValue(R, constantProduct);\n          if (nR !== R) updateDomain(indexR, nR, 'min_product');\n        }\n      } else {\n        TRACE(' - Aliasing R to the single var', varIndex1);\n        intersectAndAlias(indexR, varIndex1, R, getDomain(varIndex1, true));\n      }\n\n      TRACE(' - eliminating constraint now');\n      ml_eliminate(ml, offset, opSize);\n    } else if (constants > 1) {\n      TRACE(\n        ' - Unable to morph but there are',\n        constants,\n        'constants to collapse to a single arg with value',\n        constantProduct\n      );\n      // There are constants and they did not morph or eliminate the constraint; consolidate them.\n      // loop backwards, remove all constants except one, move all other args back to compensate,\n      // only update the index of the last constant, update the count, compile a jump for the new trailing space\n\n      const newOpSize = opSize - (constants - 1) * 2;\n\n      for (let i = argCount - 1; i >= 0 && constants; --i) {\n        const index = readIndex(ml, offsetArgs + i * 2);\n        const domain = getDomainFast(index);\n        TRACE(\n          '    - i=',\n          i,\n          ', index=',\n          index,\n          'dom=',\n          domain__debug(domain),\n          ', constant?',\n          domain_isSolved(domain)\n        );\n        if (domain_isSolved(domain)) {\n          if (constants === 1) {\n            TRACE(\n              ' - Overwriting the last constant with an index for the total constant value'\n            );\n            const index = addVar(\n              undefined,\n              constantProduct,\n              false,\n              false,\n              true\n            );\n            ml_enc16(ml, offsetArgs + i * 2, index);\n          } else {\n            TRACE(\n              '  - found a constant, moving further domains one space forward (from ',\n              i + 1,\n              ' / ',\n              argCount,\n              ')',\n              i + 1 < argCount\n            );\n            ASSERT(constants > 0, 'should have some constants');\n            min_spliceArgSlow(ml, offsetArgs, argCount, i, true); // Move R as well\n            --argCount;\n          }\n\n          --constants;\n        }\n      }\n\n      const emptySpace = opSize - newOpSize;\n      TRACE(\n        ' - constants squashed, compiling new length (',\n        argCount,\n        ') and a jump for the empty space (',\n        emptySpace,\n        'bytes )'\n      );\n      ml_enc16(ml, offset + 1, argCount);\n      // Now \"blank out\" the space of eliminated constants, they should be at the end of the op\n      ASSERT(\n        emptySpace > 0,\n        'since at least two constants were squashed there should be some bytes empty now'\n      );\n      ml_compileJumpSafe(ml, offset + newOpSize, emptySpace);\n\n      TRACE(\n        ' - ml for this product now:',\n        ml.slice(offset, offset + opSize).join(' ')\n      );\n      ASSERT(ml_validateSkeleton(ml, 'min_product; case 3'));\n\n      TRACE(' - Cleaned up constant args');\n    } else {\n      TRACE(' - not only jumps...');\n      onlyJumps = false;\n      pc = offset + opSize;\n    }\n  }\n\n  function min_all(ml, offset) {\n    // Loop through the args and remove zero from all of them. then eliminate the constraint. it is an artifact.\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(\n      ' = min_all',\n      argCount,\n      'x. removing zero from all args and eliminating constraint'\n    );\n\n    for (let i = 0; i < argCount; ++i) {\n      const indexD = readIndex(ml, offset + SIZEOF_C + i * 2);\n      const oD = getDomain(indexD, true);\n      const D = domain_removeValue(oD, 0);\n      if (oD !== D) updateDomain(indexD, D, 'ALL D');\n    }\n\n    ml_eliminate(ml, offset, SIZEOF_C + argCount * 2);\n  }\n\n  function min_some_2(ml, offset) {\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' = min_some_2',\n      indexA,\n      '|',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '|',\n      domain__debug(B)\n    );\n    if (!A || !B) return true;\n\n    if (indexA === indexB) {\n      TRACE(\n        ' - argcount=2 and indexA==indexB. so A>0 and eliminating constraint'\n      );\n      const nA = domain_removeValue(A, 0);\n      if (A !== nA) updateDomain(indexA, nA, 'A|A');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_isZero(A)) {\n      TRACE(\n        ' - A=0 so remove 0 from B',\n        domain__debug(B),\n        '->',\n        domain__debug(domain_removeValue(B, 0))\n      );\n      const oB = B;\n      B = domain_removeValue(oB, 0);\n      if (B !== oB) updateDomain(indexB, B, 'OR B');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return true;\n    }\n\n    if (domain_isZero(B)) {\n      TRACE(\n        ' - B=0 so remove 0 from A',\n        domain__debug(A),\n        '->',\n        domain__debug(domain_removeValue(A, 0))\n      );\n      const oA = A;\n      A = domain_removeValue(oA, 0);\n      if (A !== oA) updateDomain(indexA, A, 'OR A');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return true;\n    }\n\n    if (domain_hasNoZero(A) || domain_hasNoZero(B)) {\n      TRACE(' - at least A or B has no zero so remove constraint');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return true;\n    }\n\n    TRACE(' - min_some_2 changed nothing');\n    return false;\n  }\n\n  function min_none(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n    TRACE(\n      ' = min_none on',\n      argCount,\n      'vars. Setting them all to zero and removing constraint.'\n    ); // This is an artifact and that is fine.\n\n    for (let i = 0; i < argCount; ++i) {\n      const indexD = readIndex(ml, offset + SIZEOF_C + i * 2);\n      const D = getDomain(indexD, true);\n      const nD = domain_removeGtUnsafe(D, 0);\n      if (D !== nD) updateDomain(indexD, nD);\n    }\n\n    ml_eliminate(ml, offset, SIZEOF_C + argCount * 2);\n  }\n\n  function min_xor(ml, offset) {\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' = min_xor',\n      indexA,\n      '^',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '^',\n      domain__debug(B)\n    );\n    if (!A || !B) return;\n\n    if (indexA === indexB) {\n      TRACE(' - index A === index B, x^x is falsum');\n      setEmpty(indexA, 'x^x');\n      emptyDomain = true;\n      return;\n    }\n\n    if (domain_isZero(A)) {\n      TRACE(' - A=0 so B must be >=1');\n      const oB = B;\n      B = domain_removeValue(B, 0);\n      if (B !== oB) updateDomain(indexB, B, 'xor B>=1');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_isZero(B)) {\n      TRACE(' - B=0 so A must be >=1');\n      const oA = A;\n      A = domain_removeValue(A, 0);\n      if (A !== oA) updateDomain(indexA, A, 'xor A>=1');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_hasNoZero(A)) {\n      TRACE(' - A>=1 so B must be 0');\n      const oB = B;\n      B = domain_removeGtUnsafe(B, 0);\n      if (B !== oB) updateDomain(indexB, B, 'xor B=0');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_hasNoZero(B)) {\n      TRACE(' - B>=1 so A must be 0');\n      const oA = A;\n      A = domain_removeGtUnsafe(A, 0);\n      if (A !== oA) updateDomain(indexA, A, 'xor A=0');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    TRACE(' - not only jumps...');\n    onlyJumps = false;\n    pc = offset + SIZEOF_C_2;\n  }\n\n  function min_xnor(ml, offset) {\n    const argCount = ml_dec16(ml, offset + 1);\n\n    TRACE(' = min_xnor;', argCount, 'args');\n\n    if (argCount !== 2) {\n      TRACE(' - xnor does not have 2 args, bailing for now');\n      onlyJumps = false;\n      pc = offset + SIZEOF_C + argCount * 2;\n      return;\n    }\n\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' -',\n      indexA,\n      '!^',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '!^',\n      domain__debug(B)\n    );\n    if (!A || !B) return;\n    ASSERT(ml_dec16(ml, offset + 1) === 2, 'should have 2 args now');\n\n    if (indexA === indexB) {\n      TRACE('   - oh... it was the same index. removing op'); // Artifact, can happen\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_isZero(A)) {\n      TRACE(' - A=0 so B must be 0');\n      const oB = B;\n      B = domain_removeGtUnsafe(B, 0);\n      if (B !== oB) updateDomain(indexB, B, 'xnor B');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_isZero(B)) {\n      TRACE(' - B=0 so A must be 0');\n      const oA = A;\n      A = domain_removeGtUnsafe(A, 0);\n      if (A !== oA) updateDomain(indexA, A, 'xnor A');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_hasNoZero(A)) {\n      TRACE(' - A>=1 so B must be >=1');\n      const oB = B;\n      B = domain_removeValue(B, 0);\n      if (B !== oB) updateDomain(indexB, B, 'xnor B');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_hasNoZero(B)) {\n      TRACE(' - B>=1 so A must be >=1');\n      const oA = A;\n      A = domain_removeValue(A, 0);\n      if (A !== oA) updateDomain(indexA, A, 'xnor A');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    // A and B are booly-pairs and equal then they can be considered an alias\n    if (A === B && domain_size(A) === 2) {\n      TRACE(\n        ' - A==B, size(A)=2 so size(B)=2 so max(A)==max(B) so under XNOR: A==B;',\n        domain__debug(A),\n        '!^',\n        domain__debug(B)\n      );\n      ASSERT(\n        domain_size(B) === 2,\n        'If A==B and size(A)=2 then size(B) must also be 2 and they are regular aliases'\n      );\n      addAlias(indexA, indexB);\n      varChanged = true;\n      return;\n      // Note: cutter supports more cases for xnor pseudo alias, but that requires knowing BOOLY state for each var\n    }\n\n    TRACE(' - not only jumps...');\n    onlyJumps = false;\n    pc = offset + SIZEOF_C_2;\n  }\n\n  function min_imp(ml, offset) {\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' = min_imp',\n      indexA,\n      '->',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '->',\n      domain__debug(B)\n    );\n    if (!A || !B) return;\n\n    if (indexA === indexB) {\n      TRACE(' - same index, tautology, eliminating constraint');\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    // If A is nonzero then B must be nonzero and constraint is solved\n    // if A is zero then constraint is solved\n    // if B is nonzero then constraint is solved\n    // if B is zero then A must be zero\n\n    if (domain_isZero(A)) {\n      TRACE(' - A is zero so just eliminate the constraint');\n      // Eliminate constraint. B is irrelevant now.\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_hasNoZero(A)) {\n      TRACE(\n        ' - A is nonzero so remove zero from B and eliminate the constraint'\n      );\n      // Remove zero from B, eliminate constraint\n      const oB = B;\n      B = domain_removeValue(oB, 0);\n      if (oB !== B) updateDomain(indexB, B, 'IMP B');\n\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_isZero(B)) {\n      TRACE(' - B is zero so set A to zero and eliminate the constraint');\n      // Remove zero from A, eliminate constraint\n      const oA = A;\n      A = domain_removeGtUnsafe(oA, 0);\n      if (oA !== A) updateDomain(indexA, A, 'IMP A');\n\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    if (domain_hasNoZero(B)) {\n      TRACE(' - B is nonzero so just eliminate the constraint');\n      // Eliminate constraint. A is irrelevant now.\n      ml_eliminate(ml, offset, SIZEOF_C_2);\n      return;\n    }\n\n    TRACE(' - not only jumps...');\n    onlyJumps = false;\n    pc = offset + SIZEOF_C_2;\n  }\n\n  function min_nimp(ml, offset) {\n    const offsetA = offset + OFFSET_C_A;\n    const offsetB = offset + OFFSET_C_B;\n    const indexA = readIndex(ml, offsetA);\n    const indexB = readIndex(ml, offsetB);\n    let A = getDomainFast(indexA);\n    let B = getDomainFast(indexB);\n\n    TRACE(\n      ' = min_nimp',\n      indexA,\n      '!->',\n      indexB,\n      '   ->   ',\n      domain__debug(A),\n      '!->',\n      domain__debug(B)\n    );\n    if (!A || !B) return;\n\n    // Nimp is trivial since A must be nonzero and B must be zero\n\n    const oA = A;\n    A = domain_removeValue(oA, 0);\n    if (oA !== A) updateDomain(indexA, A, 'NIMP A');\n\n    const oB = B;\n    B = domain_removeGtUnsafe(oB, 0);\n    if (oB !== B) updateDomain(indexB, B, 'NIMP B');\n\n    TRACE(' ->', domain__debug(A), '!->', domain__debug(B));\n\n    ml_eliminate(ml, offset, SIZEOF_C_2);\n  }\n}\n\nexport { min_run, min_optimizeConstraints };\n","import {\n  ASSERT,\n  ASSERT_NORDOM,\n  TRACE,\n  TRACE_SILENT,\n  SUB,\n  SUP,\n  domain__debug,\n  domain_arrToSmallest,\n  domain_createRange,\n  domain_createValue,\n  domain_getValue,\n  domain_intersection,\n  THROW,\n  trie_add,\n  trie_create,\n  trie_get\n} from 'fdlib';\n\nimport {\n  ML_JMP,\n  ML_NOOP,\n  ML_NOOP2,\n  ML_NOOP3,\n  ML_NOOP4,\n  ML_STOP,\n  ml_enc8,\n  ml_compileJumpSafe,\n  ml_validateSkeleton,\n  ml_walk,\n} from './ml';\n\nconst MAX_VAR_COUNT = 0xffff; // 16bit\n\nfunction $addVar(\n  $varTrie,\n  $vars,\n  $domains,\n  $valdist,\n  $constants,\n  $addAlias,\n  $getAnonCounter,\n  $targeted,\n  $targetsFrozen,\n  name,\n  domain,\n  modifier,\n  returnName,\n  returnIndex,\n  _throw\n) {\n  TRACE(\n    'addVar',\n    name,\n    domain,\n    modifier,\n    returnName ? '(return name)' : '',\n    returnIndex ? '(return index)' : ''\n  );\n  if (typeof name === 'number') {\n    domain = name;\n    name = undefined;\n  }\n\n  if (typeof domain === 'number') {\n    domain = domain_createValue(domain);\n  } else if (domain === undefined) {\n    domain = domain_createRange(SUB, SUP);\n  } else {\n    domain = domain_arrToSmallest(domain);\n  }\n\n  let newIndex;\n\n  const v = domain_getValue(domain);\n  if (typeof name === 'string' || v < 0 || returnName) {\n    const wasAnon = name === undefined;\n    if (wasAnon) {\n      name = '__' + $getAnonCounter();\n      TRACE(' - Adding anonymous var for dom=', domain, '->', name);\n    } else if (\n      name[0] === '_' &&\n      name[1] === '_' &&\n      name === '__' + parseInt(name.slice(2), 10)\n    ) {\n      THROW(\n        'Dont use `__xxx` as var names, that structure is preserved for internal/anonymous var names'\n      );\n    }\n\n    newIndex = $vars.length;\n\n    const prev = trie_add($varTrie, name, newIndex);\n    if (prev >= 0) {\n      if (_throw)\n        _throw(\n          'CONSTRAINT_VARS_SHOULD_BE_DECLARED; Dont declare a var [' +\n            name +\n            '] after using it',\n          name,\n          prev\n        );\n      THROW(\n        'CONSTRAINT_VARS_SHOULD_BE_DECLARED; Dont declare a var [' +\n          name +\n          '] after using it',\n        name,\n        prev\n      );\n    }\n\n    $vars.push(name);\n    $domains.push(domain);\n    $targeted[newIndex] = wasAnon ? false : !$targetsFrozen(); // Note: cannot override frozen values since all names must already be declared when using `@custom targets`\n  }\n\n  // Note: if the name is string but domain is constant, we must add the name here as well and immediately alias it to a constant\n  if (v >= 0 && !returnName) {\n    // TODO: we'll phase out the second condition here soon, but right now constants can still end up as regular vars\n    // constants are compiled slightly differently\n    const constIndex = value2index($constants, v);\n    // Actual var names must be registered so they can be looked up, then immediately alias them to a constant\n    if (newIndex >= 0) $addAlias(newIndex, constIndex, '$addvar');\n    newIndex = constIndex;\n  }\n\n  if (modifier) {\n    $valdist[newIndex] = modifier;\n\n    switch (modifier.valtype) {\n      case 'list':\n      case 'max':\n      case 'mid':\n      case 'min':\n      case 'minMaxCycle':\n      case 'naive':\n      case 'splitMax':\n      case 'splitMin':\n        break;\n      default:\n        if (_throw) _throw('implement me (var mod [' + modifier.valtype + '])');\n        THROW('implement me (var mod [' + modifier.valtype + '])');\n    }\n  }\n\n  // Deal with explicitly requested return values...\n  if (returnIndex) return newIndex;\n  if (returnName) return name;\n}\n\nfunction $name2index($varTrie, $getAlias, name, skipAliasCheck, scanOnly) {\n  // ASSERT_LOG2('$name2index', name, skipAliasCheck);\n  let varIndex = trie_get($varTrie, name);\n  if (!scanOnly && varIndex < 0)\n    THROW(\n      'cant use this on constants or vars that have not (yet) been declared',\n      name,\n      varIndex\n    );\n  if (!skipAliasCheck && varIndex >= 0) varIndex = $getAlias(varIndex);\n  return varIndex;\n}\n\nfunction $addAlias(\n  $domains,\n  $valdist,\n  $aliases,\n  $solveStack,\n  $constants,\n  indexOld,\n  indexNew,\n  _origin\n) {\n  TRACE(\n    ' - $addAlias' +\n      (_origin ? ' (from ' + _origin + ')' : '') +\n      ': Mapping index = ',\n    indexOld,\n    '(',\n    domain__debug($domains[indexOld]),\n    ') to index = ',\n    indexNew,\n    '(',\n    indexNew >= $domains.length\n      ? 'constant ' + $constants[indexNew]\n      : domain__debug($domains[indexNew]),\n    ')'\n  );\n  ASSERT(\n    typeof indexOld === 'number',\n    'old index should be a number',\n    indexOld\n  );\n  ASSERT(\n    typeof indexNew === 'number',\n    'new index should be a number',\n    indexNew\n  );\n\n  if ($aliases[indexOld] === indexNew) {\n    TRACE(\n      'ignore constant (re)assignments. we may want to handle this more efficiently in the future'\n    );\n    return;\n  }\n\n  ASSERT(\n    indexOld !== indexNew,\n    'cant make an alias for itself',\n    indexOld,\n    indexNew,\n    _origin\n  );\n  ASSERT(\n    indexOld >= 0 && indexOld <= $domains.length,\n    'should be valid non-constant var index',\n    indexOld,\n    _origin\n  );\n  ASSERT(indexNew >= 0, 'should be valid var index', indexNew, _origin);\n  // ASSERT($domains[indexOld], 'current domain shouldnt be empty', _origin);\n  ASSERT(\n    !indexOld || indexOld - 1 in $domains,\n    'dont create gaps...',\n    indexOld\n  );\n\n  $aliases[indexOld] = indexNew;\n  $domains[indexOld] = false; // Mark as aliased. while this isnt a change itself, it could lead to some dedupes\n  if (!$valdist[indexNew] && $valdist[indexOld])\n    $valdist[indexNew] = $valdist[indexOld]; // This shouldnt happen for constants...\n}\n\nfunction $getAlias($aliases, index) {\n  let alias = $aliases[index]; // TODO: is a trie faster compared to property misses?\n  while (alias !== undefined) {\n    TRACE_SILENT(' ($getAlias,', index, '=>', alias, ')');\n    if (alias === index) THROW('alias is itself?', alias, index);\n    index = alias;\n    alias = $aliases[index];\n  }\n\n  return index;\n}\n\nfunction $getDomain($domains, $constants, $getAlias, varIndex, skipAliasCheck) {\n  // ASSERT_LOG2('    - $getDomain', varIndex, skipAliasCheck, $constants[varIndex]);\n  if (!skipAliasCheck) varIndex = $getAlias(varIndex);\n  ASSERT(\n    varIndex === $getAlias(varIndex),\n    'should only skip alias check when already certain the index is de-aliased',\n    skipAliasCheck,\n    varIndex,\n    $getAlias(varIndex)\n  );\n\n  // Constant var indexes start at the end of the max\n  const v = $constants[varIndex];\n  if (v !== undefined) {\n    ASSERT(SUB <= v && v <= SUP, 'only SUB SUP values are valid here');\n    return domain_createValue(v);\n  }\n\n  return $domains[varIndex];\n}\n\nfunction _assertSetDomain(\n  $domains,\n  $constants,\n  $getAlias,\n  varIndex,\n  domain,\n  skipAliasCheck,\n  explicitlyAllowNewValuesForPseudoAlias\n) {\n  // There's a bunch of stuff to assert. this function should not be called without ASSERT and should be eliminated as dead code by the minifier...\n\n  // args check\n  ASSERT(\n    typeof varIndex === 'number' && varIndex >= 0 && varIndex <= 0xffff,\n    'valid varindex',\n    varIndex\n  );\n  ASSERT_NORDOM(domain);\n  ASSERT(\n    skipAliasCheck === undefined ||\n      skipAliasCheck === true ||\n      skipAliasCheck === false,\n    'skipAliasCheck should be bool or undefined, was:',\n    skipAliasCheck\n  );\n\n  const currentDomain = $getDomain(\n    $domains,\n    $constants,\n    $getAlias,\n    varIndex,\n    false\n  );\n  ASSERT(\n    explicitlyAllowNewValuesForPseudoAlias ||\n      domain_intersection(currentDomain, domain) === domain,\n    'should not introduce values into the domain that did not exist before',\n    domain__debug(currentDomain),\n    '->',\n    domain__debug(domain)\n  );\n  ASSERT(\n    domain,\n    'Should never be set to an empty domain, even with the explicitlyAllowNewValuesForPseudoAlias flag set'\n  );\n\n  return true;\n}\n\nfunction $setDomain(\n  $domains,\n  $constants,\n  $aliases,\n  $addAlias,\n  $getAlias,\n  varIndex,\n  domain,\n  skipAliasCheck,\n  emptyHandled,\n  explicitlyAllowNewValuesForPseudoAlias\n) {\n  TRACE_SILENT(\n    '  $setDomain, index=',\n    varIndex,\n    ', from=',\n    $constants[$getAlias(varIndex)] !== undefined\n      ? 'constant ' + $constants[$getAlias(varIndex)]\n      : domain__debug($domains[$getAlias(varIndex)]),\n    ', to=',\n    domain__debug(domain),\n    ', skipAliasCheck=',\n    skipAliasCheck,\n    ', emptyHandled=',\n    emptyHandled,\n    ', explicitlyAllowNewValuesForPseudoAlias=',\n    explicitlyAllowNewValuesForPseudoAlias\n  );\n  if (!domain) {\n    if (emptyHandled) return; // Todo...\n    THROW('Cannot set to empty domain');\n  } // Handle elsewhere!\n\n  ASSERT(\n    _assertSetDomain(\n      $domains,\n      $constants,\n      $getAlias,\n      varIndex,\n      domain,\n      skipAliasCheck,\n      explicitlyAllowNewValuesForPseudoAlias\n    )\n  );\n\n  const value = domain_getValue(domain);\n  if (value >= 0)\n    return _$setToConstant($constants, $addAlias, varIndex, value);\n  return _$setToDomain(\n    $domains,\n    $constants,\n    $aliases,\n    $getAlias,\n    varIndex,\n    domain,\n    skipAliasCheck\n  );\n}\n\nfunction _$setToConstant($constants, $addAlias, varIndex, value) {\n  // Check if this isnt already a constant.. this case should never happen\n  // note: pseudo aliases should prevent de-aliasing when finalizing the aliased var\n  if ($constants[varIndex] !== undefined) {\n    // TOFIX: this needs to be handled better because a regular var may become mapped to a constant and if it becomes empty then this place cant deal/signal with that properly\n    if ($constants[varIndex] === value) return;\n    THROW(\n      'Cant update a constant (only to an empty domain, which should be handled differently)'\n    );\n  }\n\n  // Note: since the constant causes an alias anyways, we dont need to bother with alias lookup here\n  // note: call site should assert that the varindex domain actually contained the value!\n  const constantIndex = value2index($constants, value);\n  $addAlias(\n    varIndex,\n    constantIndex,\n    '$setDomain; because var is now constant ' + value\n  );\n}\n\nfunction _$setToDomain(\n  $domains,\n  $constants,\n  $aliases,\n  $getAlias,\n  varIndex,\n  domain,\n  skipAliasCheck\n) {\n  if (skipAliasCheck) {\n    // Either index was already unaliased by call site or this is solution generating. unalias the var index just in case.\n    $aliases[varIndex] = undefined;\n  } else {\n    varIndex = $getAlias(varIndex);\n  }\n\n  ASSERT(\n    varIndex < $domains.length || $constants[varIndex] === domain,\n    'either the var is not a constant or it is being updated to itself'\n  );\n  if (varIndex < $domains.length) {\n    // TRACE_SILENT(' - now updating index', varIndex,'to', domain__debug(domain));\n    $domains[varIndex] = domain;\n    // } else {\n    //  TRACE_SILENT(' - ignoring call, updating a constant to itself?', varIndex, '<', $domains.length, ', ', $constants[varIndex],' === ',domain);\n  }\n}\n\nfunction value2index(constants, value) {\n  // ASSERT_LOG2('value2index', value, '->', constants['v' + value]);\n  ASSERT(value >= SUB && value <= SUP, 'value is OOB', value);\n\n  let constantIndex = constants['v' + value];\n  if (constantIndex >= 0) return constantIndex;\n\n  constantIndex = MAX_VAR_COUNT - constants._count++;\n  constants['v' + value] = constantIndex;\n  constants[constantIndex] = value;\n\n  return constantIndex;\n}\n\nfunction problem_create() {\n  let anonCounter = 0;\n  const varNames = [];\n  const varTrie = trie_create(); // Name -> index (in varNames)\n  const domains = [];\n  const constants = { _count: 0 };\n  const aliases = {};\n  const solveStack = [];\n  const leafs = [];\n\n  // Per-var distribution overrides. all vars default to the global distribution setting if set and otherwise naive\n  const valdist = []; // 1:1 with varNames. contains json objects {valtype: 'name', ...}\n\n  const addAlias = $addAlias.bind(\n    undefined,\n    domains,\n    valdist,\n    aliases,\n    solveStack,\n    constants\n  );\n  const getAlias = $getAlias.bind(undefined, aliases);\n  const name2index = $name2index.bind(undefined, varTrie, getAlias);\n\n  const targeted = [];\n  let targetsFrozen = false; // False once a targets directive is parsed\n\n  return {\n    varTrie,\n    varNames,\n    domains,\n    valdist,\n    aliases,\n    solveStack,\n    leafs,\n\n    input: {\n      // See dsl2ml\n      varstrat: 'default',\n      valstrat: 'default',\n      dsl: '',\n    },\n    ml: undefined, // Uint8Array\n    mapping: undefined, // Var index in (this) child to var index of parent\n\n    addVar: $addVar.bind(\n      undefined,\n      varTrie,\n      varNames,\n      domains,\n      valdist,\n      constants,\n      addAlias,\n      _ => ++anonCounter,\n      targeted,\n      _ => targetsFrozen\n    ),\n    getVar: name2index, // Deprecated\n    name2index,\n    addAlias,\n    getAlias,\n    getDomain: $getDomain.bind(undefined, domains, constants, getAlias),\n    setDomain: $setDomain.bind(\n      undefined,\n      domains,\n      constants,\n      aliases,\n      addAlias,\n      getAlias\n    ),\n    isConstant: index => constants[index] !== undefined,\n    freezeTargets: varNames => {\n      if (targetsFrozen) THROW('Only one `targets` directive supported');\n      targetsFrozen = true;\n      targeted.fill(false);\n      varNames.forEach(name => (targeted[name2index(name, true)] = true));\n    },\n\n    targeted, // For each element in $domains; true if targeted, false if not targeted\n  };\n}\n\nfunction problem_from(parentProblem) {\n  TRACE(\n    ' - problem_from(): sweeping parent and generating clean child problem'\n  );\n  const childProblem = problem_create(parentProblem._dsl);\n\n  const parentMl = parentProblem.ml;\n  childProblem.mapping = new Array(parentProblem.varNames.length);\n  const len = parentMl.length;\n  const childMl = new Uint8Array(len); // Worst case there's a lot of empty space to recycle\n  // childMl.fill(0); // note: we shouldnt need to do this. everything but the left-over space is copied over directly. the left-over space is compiled as a full jump which should ignore the remaining contents of the buffer. it may only be a little confusing to debug if you expect that space to be \"empty\"\n  childProblem.ml = childMl;\n\n  let childOffset = 0;\n  let lastJumpSize = 0;\n  let lastJumpOffset = 0;\n  let stopOffset = 0;\n  ml_walk(parentMl, 0, (ml, offset, op, sizeof) => {\n    switch (op) {\n      case ML_JMP:\n      case ML_NOOP:\n      case ML_NOOP2:\n      case ML_NOOP3:\n      case ML_NOOP4:\n        lastJumpOffset = offset;\n        lastJumpSize = sizeof;\n        return; // Eliminate these\n      case ML_STOP:\n        stopOffset = offset;\n    }\n\n    // Copy the bytes to the new problem ml\n    // TODO: consolidate consecutive copies (probably faster to do one long copy than 10 short ones?)\n    ml.copy(childMl, childOffset, offset, offset + sizeof);\n    childOffset += sizeof;\n  });\n  TRACE(\n    'ML len:',\n    len,\n    'parent content len:',\n    stopOffset - lastJumpSize === lastJumpOffset\n      ? lastJumpOffset + 1\n      : stopOffset,\n    ', child content len:',\n    childOffset\n  );\n  ASSERT(\n    childMl[childOffset - 1] === ML_STOP,\n    'expecting last copied op to be a STOP',\n    childOffset,\n    childMl[childOffset - 1],\n    childMl\n  );\n  if (childOffset < len) {\n    TRACE(\n      ' - there are',\n      len - childOffset - 1,\n      'available bytes left, compiling a jump and moving the STOP back'\n    );\n    ml_compileJumpSafe(childMl, childOffset - 1, len - childOffset);\n    ml_enc8(childMl, len - 1, ML_STOP);\n  }\n\n  TRACE('PML:', parentMl);\n  TRACE('CML:', childMl);\n  ASSERT(ml_validateSkeleton(childMl, 'after streaming to a child ml'));\n\n  return childProblem;\n}\n\nexport { problem_create, problem_from };\n","// Import dsl\n// generate ml\n// minimize -> reduce constraints\n// generate propagators\n// stabilize\n// exit\n\nimport {\n  ASSERT,\n  ASSERT_NORDOM,\n  TRACE,\n  $CHANGED,\n  $REJECTED,\n  $SOLVED,\n  $STABLE,\n  domain__debug,\n  domain_arrToSmallest,\n  domain_containsValue,\n  domain_createValue,\n  domain_getValue,\n  domain_intersection,\n  domain_max,\n  domain_middleElement,\n  domain_min,\n  domain_toArr,\n  getTerm,\n  INSPECT,\n  setTerm,\n  THROW,\n} from 'fdlib';\n\nimport { bounty_collect } from './bounty';\n\nimport { cutter } from './cutter';\nimport { deduper } from './deduper';\n\nimport { dsl2ml } from './dsl2ml';\nimport { ml_countConstraints, ml_getOpList, ml_hasConstraint } from './ml';\nimport { ml2dsl } from './ml2dsl';\nimport { min_run } from './minimizer';\n\nimport {\n  problem_create,\n  // problem_from,\n} from './problem';\n\n/**\n * @param {string} dsl The input problem\n * @param {Function} solver The function to brute force the remainder of the problem after FDP reduces it, not called if already solved. Called with `solver(dsl, options)`.\n * @param {Object} fdpOptions\n * @property {boolean} [fdpOptions.singleCycle=false] Only do a single-nonloop minimization step before solving? Can be faster but sloppier.\n * @property {boolean} [fdpOptions.repeatUntilStable=true] Keep calling minimize/cutter per cycle until nothing changes?\n * @property {boolean} [fdpOptions.debugDsl=false] Enable debug output (adds lots of comments about vars)\n * @property {boolean} [fdpOptions.hashNames=true] Replace original varNames with `$<base36(index)>$` of their index in the output\n * @property {boolean} [fdpOptions.indexNames=false] Replace original varNames with `_<index>_` in the output\n * @property {boolean} [fdpOptions.groupedConstraints=true] When debugging only, add all constraints below a var decl where that var is used\n * @property {boolean} [fdpOptions.flattened=false] Solve all vars in the solution even if there are multiple open fdpOptions left\n * @property {boolean|Function} [fdpOptions.printDslBefore] Print the dsl after parsing it but before crunching it.\n * @property {boolean|Function} [fdpOptions.printDslAfter] Print the dsl after crunching it but before calling FD on it\n * @param {Object} solverOptions Passed on to the solver directly\n */\nfunction solve(\n  dsl,\n  solver,\n  fdpOptions = {},\n  solverOptions = { log: 1, vars: 'all' }\n) {\n  ASSERT(typeof dsl === 'string');\n  ASSERT(\n    typeof fdpOptions !== 'function',\n    'confirming this isnt the old solver param'\n  );\n\n  // fdpOptions.hashNames = false;\n  // fdpOptions.repeatUntilStable = true;\n  // fdpOptions.debugDsl = false;\n  // fdpOptions.singleCycle = true;\n  // fdpOptions.indexNames = true;\n  // fdpOptions.groupedConstraints = true;\n\n  if (solverOptions.logger) setTerm(solverOptions.logger);\n  const term = getTerm();\n\n  term.log('<pre>');\n  term.time('</pre>');\n  const r = _preSolver(dsl, solver, fdpOptions, solverOptions);\n  term.timeEnd('</pre>');\n  return r;\n}\n\nfunction _preSolver(dsl, solver, options, solveOptions) {\n  ASSERT(typeof dsl === 'string');\n  ASSERT(\n    typeof options !== 'function',\n    'making sure this isnt the old Solver param'\n  );\n\n  const term = getTerm();\n  term.log('<pre-solving>');\n  term.time('</pre-solving total>');\n  const {\n    hashNames = true,\n    debugDsl = false,\n    indexNames = false,\n    groupedConstraints = true,\n  } = options;\n  if (options.hashNames === undefined) options.hashNames = hashNames;\n  if (options.debugDsl === undefined) options.debugDsl = debugDsl;\n  if (options.indexNames === undefined) options.indexNames = indexNames;\n  if (options.groupedConstraints === undefined)\n    options.groupedConstraints = groupedConstraints;\n\n  const problem = problem_create();\n  const { varNames, domains } = problem;\n\n  TRACE(\n    dsl.slice(0, 1000) + (dsl.length > 1000 ? ' ... <trimmed>' : '') + '\\n'\n  );\n\n  const state = crunch(dsl, problem, options);\n\n  let bounty;\n  let betweenDsl;\n  if (state === $REJECTED) {\n    TRACE(\n      'Skipping ml2dsl because problem rejected and bounty/ml2dsl dont handle empty domains well'\n    );\n  } else {\n    term.time('ml->dsl');\n    bounty = bounty_collect(problem.ml, problem);\n    betweenDsl = ml2dsl(problem.ml, problem, bounty, {\n      debugDsl: false,\n      hashNames: true,\n    }); // Use default generator settings for dsl to pass on to FD\n    term.timeEnd('ml->dsl');\n  }\n\n  term.timeEnd('</pre-solving total>');\n  if (state === $REJECTED) term.log('REJECTED');\n\n  // term.log(domains.map((d,i) => i+':'+problem.targeted[i]).join(', '));\n  // confirm domains has no gaps...\n  // term.log(problem.domains)\n  // for (let i=0; i<domains.length; ++i) {\n  //  ASSERT(i in domains, 'no gaps');\n  //  ASSERT(domains[i] !== undefined, 'no pseudo gaps');\n  // }\n\n  // cutter cant reject, only reduce. may eliminate the last standing constraints.\n  let solution;\n  if (\n    state === $SOLVED ||\n    (state !== $REJECTED && !ml_hasConstraint(problem.ml))\n  ) {\n    term.time('- generating early solution');\n    solution = createSolution(\n      problem,\n      null,\n      options,\n      solveOptions.max || Infinity\n    );\n    term.timeEnd('- generating early solution');\n  }\n\n  if (\n    state !== $REJECTED &&\n    ((betweenDsl && betweenDsl.length < 1000) || options.printDslAfter)\n  ) {\n    const dslForLogging = ml2dsl(problem.ml, problem, bounty, options);\n    const s =\n      '\\nResult dsl (debugDsl=' +\n      debugDsl +\n      ', hashNames=' +\n      hashNames +\n      ', indexNames=' +\n      indexNames +\n      '):\\n' +\n      dslForLogging;\n\n    if (typeof options.printDslAfter === 'function') {\n      options.printDslAfter(s);\n    } else {\n      term.log('#### <DSL> after crunching before FD');\n      term.log(s);\n      term.log('#### </DSL>');\n    }\n  }\n\n  if (solution) {\n    term.log('<solved without fdq>');\n    return solution;\n  }\n\n  if (state === $REJECTED) {\n    term.log('<rejected without fdq>');\n    TRACE('problem rejected!');\n    return 'rejected';\n  }\n\n  if (problem.input.varstrat === 'throw') {\n    // The stats are for tests. dist will never even have this so this should be fine.\n    // it's very difficult to ensure optimizations work properly otherwise\n    if (process.env.NODE_ENV !== 'production') {\n      ASSERT(\n        false,\n        `Forcing a choice with strat=throw; debug: ${\n          varNames.length\n        } vars, ${ml_countConstraints(\n          problem.ml\n        )} constraints, current domain state: ${domains\n          .map(\n            (d, i) =>\n              i +\n              ':' +\n              varNames[i] +\n              ':' +\n              domain__debug(d).replace(/[a-z()\\[\\]]/g, '')\n          )\n          .join(': ')} (${problem.leafs.length} leafs) ops: ${ml_getOpList(\n          problem.ml\n        )} #`\n      );\n    }\n\n    THROW('Forcing a choice with strat=throw');\n  }\n\n  term.log('\\n\\nSolving remaining problem through fdq now...');\n\n  term.log('<FD>');\n  term.time('</FD>');\n  const fdSolution = solver(betweenDsl, solveOptions);\n  term.timeEnd('</FD>');\n  term.log('\\n');\n\n  // Now merge the results from fdSolution to construct the final solution\n  // we need to map the vars from the dsl back to the original names.\n  // \"our\" vars will be constructed like `$<hash>$` where the hash simply\n  // means \"our\" var index as base36. So all we need to do is remove the\n  // dollar signs and parseInt as base 36. Ignore all other vars as they\n  // are temporary vars generated by fdq. We should not see them\n  // anymore once we support targeted vars.\n\n  term.log(\n    'fd result:',\n    typeof fdSolution === 'string' ? fdSolution : 'SOLVED'\n  );\n\n  TRACE(\n    'fdSolution = ',\n    fdSolution\n      ? Object.keys(fdSolution).length > 100\n        ? '<supressed; too big>'\n        : fdSolution\n      : 'REJECT'\n  );\n\n  if (fdSolution && typeof fdSolution !== 'string') {\n    term.log('<solved after fdq>');\n    if (Array.isArray(fdSolution)) {\n      return fdSolution.map(sol => createSolution(problem, sol, options, solveOptions.max || Infinity));\n    }\n    return createSolution(\n      problem,\n      fdSolution,\n      options,\n      solveOptions.max || Infinity\n    );\n  }\n\n  term.log('<' + fdSolution + ' during fdq>');\n  TRACE('problem rejected!');\n  return 'rejected';\n}\n\nfunction crunch(dsl, problem, options = {}) {\n  const { singleCycle = false, repeatUntilStable = true } = options;\n\n  const {\n    varNames,\n    domains,\n    solveStack,\n    $addVar,\n    $getVar,\n    $addAlias,\n    $getAlias,\n  } = problem;\n\n  const term = getTerm();\n\n  term.time('- dsl->ml');\n  dsl2ml(dsl, problem);\n  const { ml } = problem;\n  term.timeEnd('- dsl->ml');\n\n  term.log(\n    'Parsed dsl (' + dsl.length + ' bytes) into ml (' + ml.length + ' bytes)'\n  );\n\n  if (options.printDslBefore) {\n    const bounty = bounty_collect(problem.ml, problem);\n    const predsl = ml2dsl(ml, problem, bounty, options);\n    if (typeof options.printDslBefore === 'function') {\n      options.printDslBefore(predsl);\n    } else {\n      term.log('#### <DSL> after parsing before crunching');\n      term.log(predsl);\n      term.log('#### </DSL>');\n    }\n  }\n\n  let state;\n  if (singleCycle) {\n    // Only single cycle? usually most dramatic reduction. only runs a single loop of every step.\n    term.time('- first minimizer cycle (single loop)');\n\n    state = min_run(ml, problem, domains, varNames, true, !repeatUntilStable);\n    term.timeEnd('- first minimizer cycle (single loop)');\n    TRACE('First minimize pass result:', state);\n\n    if (state !== $REJECTED) {\n      term.time('- deduper cycle #');\n      const deduperAddedAlias = deduper(ml, problem);\n      term.timeEnd('- deduper cycle #');\n\n      if (deduperAddedAlias >= 0) {\n        term.time('- cutter cycle #');\n        cutter(ml, problem, !repeatUntilStable);\n        term.timeEnd('- cutter cycle #');\n      }\n    }\n  } else {\n    // Multiple cycles? more expensive, may not be worth the gains\n    let runLoops = 0;\n    term.time('- all run cycles');\n    do {\n      TRACE('run loop...');\n      state = run_cycle(\n        ml,\n        $getVar,\n        $addVar,\n        domains,\n        varNames,\n        $addAlias,\n        $getAlias,\n        solveStack,\n        runLoops++,\n        problem\n      );\n    } while (state === $CHANGED);\n\n    term.timeEnd('- all run cycles');\n  }\n\n  return state;\n}\n\nfunction run_cycle(\n  ml,\n  getVar,\n  addVar,\n  domains,\n  vars,\n  addAlias,\n  getAlias,\n  solveStack,\n  runLoops,\n  problem\n) {\n  const term = getTerm();\n  term.time('- run_cycle #' + runLoops);\n\n  term.time('- minimizer cycle #' + runLoops);\n  let state = min_run(ml, problem, domains, vars, runLoops === 0);\n  term.timeEnd('- minimizer cycle #' + runLoops);\n\n  if (state === $SOLVED) return state;\n  if (state === $REJECTED) return state;\n\n  term.time('- deduper cycle #' + runLoops);\n  const deduperAddedAlias = deduper(ml, problem);\n  term.timeEnd('- deduper cycle #' + runLoops);\n\n  if (deduperAddedAlias < 0) {\n    state = $REJECTED;\n  } else {\n    term.time('- cutter cycle #' + runLoops);\n    const cutLoops = cutter(ml, problem, false);\n    term.timeEnd('- cutter cycle #' + runLoops);\n\n    if (cutLoops > 1 || deduperAddedAlias) state = $CHANGED;\n    else if (cutLoops < 0) state = $REJECTED;\n    else {\n      ASSERT(\n        state === $CHANGED || state === $STABLE,\n        'minimize state should be either stable or changed here'\n      );\n    }\n  }\n\n  term.timeEnd('- run_cycle #' + runLoops);\n  return state;\n}\n\nfunction createSolution(problem, fdSolution, options, max) {\n  getTerm().time('createSolution()');\n\n  const { flattened = false } = options;\n\n  const { varNames, domains, solveStack, getAlias, targeted } = problem;\n\n  const _getDomainWithoutFd = problem.getDomain;\n  const _setDomainWithoutFd = problem.setDomain;\n\n  function getDomainFromSolverOrLocal(index, skipAliasCheck) {\n    if (!skipAliasCheck) index = getAlias(index);\n\n    if (fdSolution) {\n      let key = '$' + index.toString(36) + '$';\n      let fdval = fdSolution[key];\n      if (typeof fdval === 'number') {\n        return domain_createValue(fdval);\n      } if (fdval !== undefined) {\n        ASSERT(fdval instanceof Array, 'expecting fdq to only create solutions as arrays or numbers', fdval);\n        return domain_arrToSmallest(fdval);\n      }\n      // else the var was already solved by fd2 so just read from our local domains array\n    }\n\n    return _getDomainWithoutFd(index, true);\n  }\n\n  function setDomainInFdAndLocal(\n    index,\n    domain,\n    skipAliasCheck,\n    forPseudoAlias\n  ) {\n    TRACE(\n      ' - solveStackSetDomain, index=',\n      index,\n      ', domain=',\n      domain__debug(domain),\n      ', skipAliasCheck=',\n      skipAliasCheck,\n      ', forPseudoAlias=',\n      forPseudoAlias\n    );\n    ASSERT(domain, 'should not set an empty domain at this point');\n    ASSERT(\n      forPseudoAlias ||\n        domain_intersection(_getDomainWithoutFd(index), domain) === domain,\n      'should not introduce values into the domain that did not exist before unless for xnor pseudo-booly; current:',\n      domain__debug(_getDomainWithoutFd(index)),\n      ', updating to:',\n      domain__debug(domain),\n      'varIndex:',\n      index\n    );\n\n    if (!skipAliasCheck) index = getAlias(index);\n    _setDomainWithoutFd(index, domain, true, false, forPseudoAlias);\n\n    // Update the FD result AND the local data structure to reflect this new domain\n    // the FD value rules when checking intersection with the new domain\n    // (but we can just use the getter abstraction here and overwrite regardless)\n\n    if (fdSolution) {\n      const key = '$' + index.toString(36) + '$';\n      if (fdSolution[key] !== undefined) {\n        const v = domain_getValue(domain);\n        if (v >= 0) fdSolution[key] = v;\n        else fdSolution[key] = domain_toArr(domain);\n      }\n    }\n  }\n\n  function force(varIndex, pseudoDomain) {\n    ASSERT(\n      typeof varIndex === 'number' && varIndex >= 0 && varIndex <= 0xffff,\n      'valid var to solve',\n      varIndex\n    );\n    const finalVarIndex = getAlias(varIndex);\n    let domain = getDomainFromSolverOrLocal(finalVarIndex, true); // NOTE: this will take from fdSolution if it contains a value, otherwise from local domains\n    ASSERT_NORDOM(domain);\n    ASSERT(\n      pseudoDomain === undefined ||\n        domain_intersection(pseudoDomain, domain) === pseudoDomain,\n      'pseudoDomain should not introduce new values'\n    );\n\n    let v = domain_getValue(domain);\n    if (v < 0) {\n      if (pseudoDomain) {\n        TRACE(\n          '   - force() using pseudo domain',\n          domain__debug(pseudoDomain),\n          'instead of actual domain',\n          domain__debug(domain)\n        );\n        domain = pseudoDomain;\n      }\n\n      TRACE(\n        '   - forcing index',\n        varIndex,\n        '(final index=',\n        finalVarIndex,\n        ') to min(' + domain__debug(domain) + '):',\n        domain_min(domain)\n      );\n      const dist = problem.valdist[varIndex];\n      if (dist) {\n        ASSERT(typeof dist === 'object', 'dist is an object');\n        ASSERT(\n          typeof dist.valtype === 'string',\n          'dist object should have a name'\n        ); // TODO: rename valtype to \"name\"? or maybe keep it this way because easier to search for anyways. *shrug*\n        switch (dist.valtype) {\n          case 'list':\n            ASSERT(Array.isArray(dist.list), 'lists should have a prio');\n            dist.list.some(\n              w => domain_containsValue(domain, w) && (v = w) >= 0\n            );\n            if (v < 0) v = domain_min(domain); // None of the prioritized values still exist so just pick one\n            break;\n          case 'max':\n            v = domain_max(domain);\n            break;\n          case 'min':\n          case 'naive':\n            v = domain_min(domain);\n            break;\n          case 'mid':\n            v = domain_middleElement(domain);\n            break;\n          case 'markov':\n          case 'minMaxCycle':\n          case 'splitMax':\n          case 'splitMin':\n            THROW('implement me (var mod) [' + dist.valtype + ']');\n            v = domain_min(domain);\n            break;\n          default:\n            THROW('Unknown dist name: [' + dist.valtype + ']', dist);\n        }\n      } else {\n        // Just an arbitrary choice then\n        v = domain_min(domain);\n      }\n\n      ASSERT(\n        domain_containsValue(domain, v),\n        'force() should not introduce new values'\n      );\n      setDomainInFdAndLocal(varIndex, domain_createValue(v), true);\n    }\n\n    return v;\n  }\n\n  TRACE(\n    '\\n# createSolution(), solveStack.length=',\n    solveStack.length,\n    ', using fdSolution?',\n    !!fdSolution\n  );\n  TRACE(\n    ' - fdSolution:',\n    domains.length < 50 ? INSPECT(fdSolution).replace(/\\n/g, '') : '<big>'\n  );\n  TRACE(\n    ' - domains:',\n    domains.length < 50\n      ? domains\n          .map(\n            (_, i) =>\n              '{index=' +\n              i +\n              ',name=' +\n              problem.varNames[i] +\n              ',' +\n              domain__debug(problem.getDomain(i)) +\n              '}'\n          )\n          .join(', ')\n      : '<big>'\n  );\n\n  ASSERT(\n    domains.length < 50 ||\n      !void TRACE(\n        'domains before; index, unaliased, aliased, fdSolution (if any):\\n',\n        domains.map(\n          (d, i) =>\n            i +\n            ': ' +\n            domain__debug(d) +\n            ', ' +\n            domain__debug(_getDomainWithoutFd(i)) +\n            ', ' +\n            domain__debug(getDomainFromSolverOrLocal(i))\n        )\n      )\n  );\n\n  function flushSolveStack() {\n    TRACE(\n      'Flushing solve stack...',\n      solveStack.length ? '' : ' and done! (solve stack was empty)'\n    );\n    const rev = solveStack.reverse();\n    for (let i = 0; i < rev.length; ++i) {\n      const f = rev[i];\n      TRACE('- solve stack entry', i);\n      f(domains, force, getDomainFromSolverOrLocal, setDomainInFdAndLocal);\n\n      TRACE(\n        domains.length < 50\n          ? ' - domains now: ' +\n              domains\n                .map(\n                  (_, i) =>\n                    '{index=' +\n                    i +\n                    ',name=' +\n                    problem.varNames[i] +\n                    ',' +\n                    domain__debug(problem.getDomain(i)) +\n                    '}'\n                )\n                .join(', ')\n          : ''\n      );\n    }\n\n    ASSERT(\n      domains.length < 50 ||\n        !void TRACE(\n          'domains after solve stack flush; index, unaliased, aliased, fdSolution (if any):\\n',\n          domains.map(\n            (d, i) =>\n              i +\n              ': ' +\n              domain__debug(d) +\n              ', ' +\n              domain__debug(_getDomainWithoutFd(i)) +\n              ', ' +\n              domain__debug(getDomainFromSolverOrLocal(i))\n          )\n        )\n    );\n  }\n\n  flushSolveStack();\n\n  ASSERT(\n    !void domains.forEach((d, i) =>\n      ASSERT(\n        domains[i] === false ? getAlias(i) !== i : ASSERT_NORDOM(d),\n        'domains should be aliased or nordom at this point',\n        'index=' + i,\n        ', alias=',\n        getAlias(i),\n        ', domain=' + domain__debug(d),\n        domains\n      )\n    )\n  );\n\n  function flushValDists() {\n    TRACE(\n      '\\n# flushValDists: One last loop through all vars to force those with a valdist'\n    );\n    for (let i = 0; i < domains.length; ++i) {\n      if (flattened || problem.valdist[i]) {\n        // Can ignore FD here (I think)\n        _setDomainWithoutFd(i, domain_createValue(force(i)), true);\n      } else {\n        // TOFIX: make this more efficient... (cache the domain somehow)\n        const domain = getDomainFromSolverOrLocal(i);\n        const v = domain_getValue(domain);\n        if (v >= 0) {\n          // Can ignore FD here (I think)\n          _setDomainWithoutFd(i, domain, true);\n        }\n      }\n    }\n  }\n\n  flushValDists();\n  TRACE('\\n');\n\n  ASSERT(\n    domains.length < 50 ||\n      !void TRACE(\n        'domains after dist pops; index, unaliased, aliased, fdSolution (if any):\\n',\n        domains.map(\n          (d, i) =>\n            i +\n            ': ' +\n            domain__debug(d) +\n            ', ' +\n            domain__debug(_getDomainWithoutFd(i)) +\n            ', ' +\n            domain__debug(getDomainFromSolverOrLocal(i))\n        )\n      )\n  );\n  ASSERT(\n    !void domains.forEach((d, i) =>\n      ASSERT(\n        d === false\n          ? getAlias(i) !== i\n          : flattened\n          ? domain_getValue(d) >= 0\n          : ASSERT_NORDOM(d),\n        'domains should be aliased or nordom at this point',\n        'index=' + i,\n        ', alias=',\n        getAlias(i),\n        'domain=' + domain__debug(d),\n        domains\n      )\n    )\n  );\n\n  function flushAliases() {\n    TRACE(' - syncing aliases');\n    for (let i = 0; i < domains.length; ++i) {\n      const d = domains[i];\n      if (d === false) {\n        const a = getAlias(i);\n        const v = force(a);\n        TRACE(\n          'Forcing',\n          i,\n          'and',\n          a,\n          'to be equal because they are aliased, resulting value=',\n          v\n        );\n        // Can ignore FD here (I think)\n        _setDomainWithoutFd(i, domain_createValue(v), true);\n      }\n    }\n  }\n\n  flushAliases();\n\n  ASSERT(\n    domains.length < 50 ||\n      !void TRACE(\n        'domains after dealiasing; index, unaliased, aliased, fdSolution (if any):\\n',\n        domains.map(\n          (d, i) =>\n            i +\n            ': ' +\n            domain__debug(d) +\n            ', ' +\n            domain__debug(_getDomainWithoutFd(i)) +\n            ', ' +\n            domain__debug(getDomainFromSolverOrLocal(i))\n        )\n      )\n  );\n\n  function generateFinalSolution() {\n    TRACE(' - generating regular FINAL solution', flattened);\n    const solution = {};\n    for (let index = 0; index < varNames.length; ++index) {\n      if (targeted[index]) {\n        const name = varNames[index];\n        let d = getDomainFromSolverOrLocal(index);\n        const v = domain_getValue(d);\n        if (v >= 0) {\n          d = v;\n        } else if (flattened) {\n          ASSERT(\n            !problem.valdist[index],\n            'only vars without valdist may not be solved at this point'\n          );\n          d = domain_min(d);\n        } else {\n          d = domain_toArr(d);\n        }\n\n        solution[name] = d;\n      }\n    }\n\n    return solution;\n  }\n\n  const solution = generateFinalSolution();\n\n  getTerm().timeEnd('createSolution()');\n  TRACE(\n    ' -> createSolution results in:',\n    domains.length > 100\n      ? '<supressed; too many vars (' + domains.length + ')>'\n      : solution\n  );\n  return solution;\n}\n\nexport default { solve };\n"],"names":["ml_opcodeCounter","ML_START","ML_ALL","ML_DIFF","ML_IMP","ML_LT","ML_LTE","ML_NALL","ML_NIMP","ML_NONE","ML_SAME","ML_SOME","ML_XNOR","ML_XOR","ML_ISALL","ML_ISDIFF","ML_ISLT","ML_ISLTE","ML_ISNALL","ML_ISNONE","ML_ISSAME","ML_ISSOME","ML_SUM","ML_PRODUCT","ML_MINUS","ML_DIV","ML_NOLEAF","ML_NOBOOL","ML_JMP","ML_JMP32","ML_NOOP","ML_NOOP2","ML_NOOP3","ML_NOOP4","ML_STOP","ASSERT","SIZEOF_V","SIZEOF_W","SIZEOF_VVV","SIZEOF_C","SIZEOF_C_2","SIZEOF_CR_2","OFFSET_C_A","OFFSET_C_B","OFFSET_C_C","OFFSET_C_R","ml_sizeof","ml","offset","op","ml_dec16","_dec16","_dec32","getTerm","log","TRACE","THROW","_dec8","pc","ml_dec8","Uint8Array","length","num","TRACE_SILENT","n","ml_dec32","toString","ml_enc8","ml_enc16","ml_enc32","ml_eliminate","sizeof","join","ml_getOpSizeSlow","ml__debug","undefined","ml_compileJumpSafe","ml_validateSkeleton","ml_compileJumpAndConsolidate","len","jmplen","jmplen32","ml_countConstraints","constraints","pcStart","replace","size","ml_hasConstraint","ml_throw","ml_c2c2","argCount","opCode","indexA","indexB","ml__opName","oldLen","ml_cx2cx","args","Array","isArray","sort","a","b","opSize","i","ml_any2c","oldSizeof","count","ml_cr2cr2","indexC","ml_cr2c2","oldArgCount","ml_cr2c","every","v","newArgCount","newLen","ml_vvv2c2","ml_walk","callback","process","env","NODE_ENV","r","msg","started","stopped","ml_getRecycleOffsets","fromOffset","slotCount","sizePerSlot","spaces","push","ml_recycles","bins","loops","sizeofOp","currentRecycleOffset","pop","sizeLeft","stop","max","problem","mlAlways","_from_ml_throw","getDomain","names","varNames","ml_index","index","domain__debug","ml_16","AB","rv","name","vars","varcount","xvars","xvarcount","slice","Math","min","map","c","term","error","before","after","ml_getOpList","ml_heapSort16bitInline","_ml_heapSort16bitInline","fill","_","ml_heapify","end","ml_swap16","call","ml_heapRepair","ml_heapParent","floor","ml_heapLeft","ml_heapRight","start","startIndex","endIndex","parentIndex","parentValue","leftIndex","leftValue","swapIndex","swapValue","rightIndex","rightValue","A","B","bounty_flagCounter","BOUNTY_FLAG_NOT_BOOLY","BOUNTY_FLAG_OTHER","BOUNTY_FLAG_DIFF","BOUNTY_FLAG_IMP_LHS","BOUNTY_FLAG_IMP_RHS","BOUNTY_FLAG_ISALL_ARG","BOUNTY_FLAG_ISALL_RESULT","BOUNTY_FLAG_ISLTE_ARG","BOUNTY_FLAG_ISSAME_ARG","BOUNTY_FLAG_ISSAME_RESULT","BOUNTY_FLAG_ISSOME_RESULT","BOUNTY_FLAG_LTE_LHS","BOUNTY_FLAG_LTE_RHS","BOUNTY_FLAG_NALL","BOUNTY_FLAG_SOME","BOUNTY_FLAG_SUM_RESULT","BOUNTY_FLAG_XOR","BOUNTY_JUST_IGNORE","BOUNTY_LINK_COUNT","BOUNTY_META_FLAGS","BOUNTY_MAX_OFFSETS_TO_TRACK","BOUNTY_BYTES_PER_OFFSET","BOUNTY_SIZEOF_HEADER","BOUNTY_SIZEOF_OFFSETS","BOUNTY_SIZEOF_VAR","bounty_collect","bounty","getAlias","varCount","bountyLoop","getDeadCount","getLeafCount","getOccurrenceCount","getBountyOffset","varIndex","getOffsetsOffset","collect","delta","metaFlags","_bounty__debugMeta","isNaN","domain","ASSERT_NORDOM","domain_getValue","varOffset","countIndex","flagsOffset","_enc32","currentFlags","offsetsOffset","nextOffset","nlen","ilen","dlen","mlen","splen","plen","varMeta","bounty_getCounts","bounty_markVar","bounty_getMeta","_debug","bounty_getOffset","bounty__debug","full","bounty__debugMeta","counts","meta","s","repeat","what","ml2dsl","options","DEBUG","Boolean","debugDsl","HASH_NAMES","hashNames","INDEX_NAMES","indexNames","ADD_GROUPED_CONSTRAINTS","groupedConstraints","domains","valdist","solveStack","targeted","dsl","LEN","toName","valueOrName","vA","domainstr","allParts","partsPerVar","varOps","constraintCount","m2d_innerLoop","varDecls","varsLeft","aliases","solved","unsolved","forEach","str","domain_toArr","vardist","valtype","list","JSON","stringify","varDeclsString","cnts","decl","partIndex","ops","split","filter","d","String","m2d_getTargetsDirective","m2d_dec16","m2d_dec32","m2d_decA","skipIfConstant","_m2d_decAb","vB","__m2d_decAb","m2d_decAbc","_m2d_decAbc","C","vC","__m2d_decAbc","m2d_listVoid","callName","indexes","counters","argNames","debugs","D","vD","m2d_listResult","m2d_listResultBody","R","vR","part","delta32","Bpart","Apart","targets","total","nontargets","m2d__debug","notTrace","was","isTracing","setTracing","ML_BOOLY_NO","ML_BOOLY_YES","ML_BOOLY_MAYBE","cutter","once","setDomain","addAlias","leafs","isConstant","stacksBefore","emptyDomain","changes","requestAnotherCycle","time","cutLoop","timeEnd","somethingChanged","readIndex","arguments","getMeta","keepBoolyFlags","scrubBoolyFlag","hasFlags","flags","getCounts","cut_diff","cut_imp","cut_isall","cut_isdiff","cut_islt","cut_islte","cut_isnall","cut_issame","cut_issome","cut_lt","cut_lte","cut_nall","cut_some","cut_sum","cut_xor","cut_xnor","cut_moveTo","countsA","desubset_diff","countsB","domain_isSolved","leaf_diff_pair","TRICK_INV_DIFF_FLAGS","metaA","hasGoodOps","hasBadOps","trick_diff_elimination","trick_diff_xor","trick_diff_alias","metaB","domain_isBoolyPair","TRACE_MORPH","domain_isBooly","domain_hasNoZero","leaf_imp","trick_only_implhs_leaf","trick_implhs_nall_leaf","trick_implhs_some_leaf","trick_implhs_isall_2shared","trick_isall_implhs_1shared","trick_implhs_nalls_some","trick_impboth_nall_some","domain_isBool","trick_imprhs_isall_entry","argsOffset","indexR","countsR","leaf_isall","metaR","leaf_isall_arg_result","trick_isall_nall_2shared","trick_isall_nall_1shared","leaf_isdiff","canCutIsdiffForArg","domain_isZero","domain_max","indexL","indexO","domain_size","L","O","LO","domain_intersection","domain_createEmpty","leaf_islt","canCutIsltForArg","domain_min","leaf_islte","canCutIslteForArg","trick_imp_islte_c_v","trick_imp_islte_v_c","leaf_isnall","leaf_issame","canCutIssameForArg","leaf_issome","leaf_lt","leaf_lte","trick_ltelhs_nall_leaf","trick_only_ltelhs_leaf","trick_ltelhs_some_leaf","trick_ltelhs_nalls_some","trick_lteboth_nall_some","trick_isall_ltelhs_2shared","trick_isall_ltelhs_1shared","trick_isall_lterhs_entry","trick_issame_lterhs","desubset_nall","trickNallOnly","desubset_some","leaf_some_2","hasZero","trickSomeOnly","RisBoolyPair","allSumArgsBool","allSumArgsBoolyPairs","sum","domain_createValue","argsMinSum","argsMaxSum","constantValue","constantArgIndex","multiConstants","minValue","maxValue","domain_plus","leaf_sum_result","domain_createRange","trick_sum_to_nall","trick_some_sum","trick_issame_sum","trick_islte_sum","trick_issame_issame_sum","trick_sum_booly","leaf_xnor","boolyA","boolyB","trick_xnor_pseudoSame","leaf_xor","AonlyUsedBooly","BonlyUsedBooly","TRICK_INV_XOR_FLAGS","trick_xor_elimination","trick_isall_xor","trick_issome_xor","trick_some_xor","sB","trick_xor_alias","sA","leafIndex","otherIndex","force","domain_removeValue","leafIsA","nA","domain_intersectionValue","nB","domain_removeGtUnsafe","EMPTY","markAndCollectArgs","oR","domain_resolveAsBooly","argOnlyOffsets","resultOnlyOffsets","argAndResultOffsets","allArgs","offsets","indexOf","resultIndex","foundAsArg","j","_leafIsallArgResultMaybe","_leafIsallArgResultOnly","argOnlyIsallOffset","argOnlyIsallArgCount","argAndResultIsallOffset","argAndResultIsallArgCount","indexS","ok","_leafIsallArgResultExcess","nR","vS","argsPerIsall","toCompile","gotOne","currentOffset","allSet","len2","some","V","has","leafSide","maxA","minB","domain_removeLte","domain_removeGte","minA","maxB","domain_removeLtUnsafe","diffOffset","diffArgCount","diffFirstIndex","diffFirstIndexCounts","dealiasAndSortArgs","isSubset","markAllArgs","nallOffset","nallArgCount","nallFirstIndex","nallFirstIndexCounts","someOffset","someArgCount","someFirstIndex","someFirstIndexCounts","someOffset1","argCount1","someOffset2","argCount2","pos1","pos2","index1","index2","argOffset","actual","alias","current","remaining","reduce","none","booly","lteOffset","offset1","offset2","isallOffset","impOffset","toCheck","_trick_isall_ltelhs_2shared","argIndex","_trick_implhs_isall_2shared","S","proceed","trick_isall_lterhs_entry_excess","indexX","indexY","isallArgs","someZero","toRecycle","countsS","trick_imprhs_isall_entry_excess","isSet","isUnset","domain_hasZero","result","found","issameOffset","argCountNall","argCountIsall","indexZ","_updateNallForTrick","indexDropped","concat","removeZero","islteOffset","_trick_imp_islte_c_v","mask","domain_arrToSmallest","_trick_imp_islte_v_c","rhsArgs","il","isallArgCount","isallSizeof","nalls","opcode","sizeofNall","nallSpacesNeeded","offsetCounter","rewrittenNalls","recycledOffset","_trick_isall_nall_1shared_CreateNallAndRemoveNall","lastNallOffset","X","vX","l","nallArgs","recycleOffset","recycleSizeof","countsX","lteLhsOffsets","lteLhsArgs","lteRhsOffsets","lteRhsArgs","someOffsets","someArgs","nallOffsets","seenDiff","impLhsOffsets","impLhsArgs","impRhsOffsets","impRhsArgs","diffArgs","Y","oX","minX","maxX","minD","maxD","xorOffset","seenXor","indexT","T","cutAddPseudoBoolyAlias","Z","sizeY","YisBooly","YisPair","aliased","metaZ","_trick_isall_xor","_trick_issome_xor","issomeOffset","issomeArgCount","issomeResultOffset","issomeArgs","allNone","boolyIndex","lenght","indexesA","setIt","unsetIt","nX","lteLhsOffset","lteRhsOffset","indexD","impLhsOffset","impRhsOffset","sumOffset","issameArgCount","domain_containsValue","Rwant","_trick_issame_sum_tail","_trick_issame_sum_constant","_trick_issame_sum_domain","removeOneConstantFromArgs","addSumToSolveStack","want","targetOp","indexEliminate","indexKeep","isBooly","cut_isBoolyOp","issameOffset1","issameOffset2","indexK","indexM","indexN","vY","checkMaybes","lastIndex","vN","oE","XNOR_EXCEPTION","vK","E","opOffset","except","__runCounter","__opCounter","deduper","addVar","constraintHash","debugHash","removed","innerLoop","dedupePairOc2","key","debugString","checkLtLteFromRegular","checkLtLteFromRegularAB","checkLtLteFromRegularBA","rifop","regop","rifKey","reifierOffset","invRifKey","dedupeTripO","dedupeIsltIslte","regkey","checkLtLteFromReifier","invkey","invOffset","key2","keyr","checkLtLteFromReifierAB","checkLtLteFromReifierBA","reginvkey","dedupeBoolyList","debugArgs","dedupeNonBoolyList","dedupeVoidList","dedupeInvIsSameIsDiff","t","invA","otherValue","indexInvA","invOp","thisKey","$$AND","$$AT","$$BANG","$$COLON","$$COMMA","$$CR","$$LF","$$DASH","$$DIV","$$EQ","$$GT","$$HASH","$$LEFTBRACK","$$LEFTPAREN","$$LT","$$OR","$$PLUS","$$QM","$$SPACE","$$RIGHTBRACK","$$RIGHTPAREN","$$SQUOTE","$$STAR","$$TAB","$$XOR","$$0","$$1","$$2","$$3","$$4","$$5","$$6","$$7","$$8","$$9","$$a","$$c","$$d","$$e","$$f","$$g","$$i","$$l","$$m","$$n","$$o","$$p","$$r","$$s","$$t","$$x","$$z","$$A","$$Z","dsl2ml","dslStr","input","varstrat","valstrat","name2index","freeDirective","dslPointer","dslBuf","Buffer","window","TextEncoder","encode","from","mlBufSize","ceil","mlBuffer","mlPointer","lastAssignmentIndex","lastUnknownIndex","encode8bit","isEof","parseStatement","compileJump","leftFree","splice","startConstraint","grow","encode16bit","encode32bit","forcedExtraSpace","oldSize","ArrayBuffer","transfer","buffer","ArrayBufferTransferPoly","read","readD","substr_expensive","fromCharCode","skip","is","desc","skipWhitespaces","isWhitespace","skipWhites","isWhite","isComment","skipComment","isNewlineChar","atEol","isLineEnd","expectEol","parseVar","parseAtRule","parseVoidConstraint","nameNames","parseIdentifier","parseDomain","mod","parseModifier","addParsedVar","parseQuotedIdentifier","parseUnquotedIdentifier","ident","isValidUnquotedIdentChar","lo","parseNumber","hi","SUB","SUP","stratName","parseList","parseMarkov","parseNumList","matrix","code","func","Function","legend","expandVectorsWith","parseUexpr","parseComplexVoidConstraint","parseVexpr","cop","parseCop","parseAssignment","compileVoidConstraint","rop","parseRop","compileValueConstraint","wasReifier","parseCalledListConstraint","vals","parseVexpList","canBeUnknown","parseGrouping","parseArgs","numstr","parseNumstr","parseInt","defaultBoolResult","refs","nums","parseIdentsTo","target","idents","parseIdents","readLineRest","ruleName","parseVarStrat","parseValStrat","config","parseRestCustom","setValDist","parse","parseTargets","dist","jumpDestination","sizeDifference","growAmount","fallback","inverted","issed","parseVarStratList","addFallbackToVarStrat","strat","type","priorityByName","vs","freezeTargets","Error","source","TypeError","byteLength","sourceView","destView","set","min_run","firstRun","state","min_optimizeConstraints","$SOLVED","$REJECTED","varChanged","onlyJumps","lastPcOffset","lastOp","restartedRelevantOp","min_innerLoop","$STABLE","$CHANGED","getDomainFast","setEmpty","updateDomain","wasMetaOp","min_lt","min_lte","min_none","min_xor","min_xnor","min_imp","min_nimp","min_diff","min_all","min_isDiff","min_nall","min_same","min_some","min_isLt","min_isLte","min_isAll","min_isNall","min_isSame","min_isSome","min_isNone","min_minus","min_div","min_sum","min_product","min_moveTo","firstIndex","F","intersectAndAlias","min_diff_2","offsetA","offsetB","oB","oA","domain_sharesNoElements","offsetCount","offsetArgs","min_nall_2","countStart","lastDomain","min_spliceArgSlow","free","min_some_2","offsetR","newDomain","allNonZero","someAreZero","someNonZero","newOpSize","_min_isAllMorphToXnor","allZero","nonZero","min_sum_2","ooA","ooB","ooR","domain_minus","min_plusWithSolvedArg","indexFrom","indexTo","FT","nameX","nameY","min_product_2","domain_mul","domain_invMul","domain_divby","falsyR","truthyR","constants","constantSum","subR","minSR","maxSR","varIndex1","varIndex2","valuesToSumLeft","newConstantIndex","includingResult","toCopy","toOffset","product","constantProduct","Number","isFinite","atLeastOneArgHadZero","valuesToMulLeft","domain_createBoolyPair","emptySpace","oD","nD","MAX_VAR_COUNT","$addVar","$varTrie","$vars","$domains","$valdist","$constants","$addAlias","$getAnonCounter","$targeted","$targetsFrozen","modifier","returnName","returnIndex","_throw","newIndex","wasAnon","prev","trie_add","constIndex","value2index","$name2index","$getAlias","skipAliasCheck","scanOnly","trie_get","$aliases","$solveStack","indexOld","indexNew","_origin","$getDomain","_assertSetDomain","explicitlyAllowNewValuesForPseudoAlias","currentDomain","$setDomain","emptyHandled","value","_$setToConstant","_$setToDomain","constantIndex","_count","problem_create","anonCounter","varTrie","trie_create","bind","targetsFrozen","mapping","getVar","solve","solver","fdpOptions","solverOptions","logger","setTerm","_preSolver","solveOptions","crunch","betweenDsl","solution","createSolution","printDslAfter","dslForLogging","fdSolution","Object","keys","sol","singleCycle","repeatUntilStable","$getVar","printDslBefore","predsl","deduperAddedAlias","runLoops","run_cycle","cutLoops","flattened","_getDomainWithoutFd","_setDomainWithoutFd","getDomainFromSolverOrLocal","fdval","setDomainInFdAndLocal","forPseudoAlias","pseudoDomain","finalVarIndex","w","domain_middleElement","INSPECT","flushSolveStack","rev","reverse","f","flushValDists","flushAliases","generateFinalSolution"],"mappings":"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"}